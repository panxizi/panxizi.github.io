<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>西北看长安</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="西北看长安"><meta name="msapplication-TileImage" content="/img/zhonglou.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="西北看长安"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="西北看长安"><meta property="og:url" content="https://panxizi.github.io/"><meta property="og:site_name" content="西北看长安"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://panxizi.github.io/img/avatar.png"><meta property="article:author" content="XiZi"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"西北看长安","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Xizi Pan"},"description":""}</script><link rel="icon" href="/img/zhonglou.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">21a4771bbf4007e96ea64a2275e8316e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="21a4771bbf4007e96ea64a2275e8316e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>11 分钟  <i class="fas fa-pencil-alt"> </i>1.7 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）</a></h1><div class="content"><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><ul>
<li>问题情景：程序越来越复杂， 程序中用到的类型也越来越复杂  <ul>
<li>一是一些类型难于“ 拼写”， 它们的名字既难记又容易写错， 还无法明确体现其真实目的和含义  </li>
<li>二是有时候根本搞不清到底需要的类型是什么， 程序员不得不回过头去从程序的上下文中寻求帮助。  </li>
</ul>
</li>
</ul>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ol>
<li><p>类型别名（ type alias)  定义：<br>是一个名字， 它是某种类型的同义词。   </p>
</li>
<li><p>好处：让复杂的类型名字变得简单明了、 易于理解和使用， 还有助于程序员清楚地知道使用该类型的真实目的。  </p>
</li>
<li><p>定义类型别名  </p>
<ol>
<li><p>关键字 typedef  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223950076.png" alt="image-20220705223950076"></p>
</li>
<li><p>别名声明（ aliasdeclaration)   </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705224051565.png" alt="image-20220705224051565"></p>
</li>
</ol>
</li>
<li><p>使用场景：类型别名和类型的名字等价， 只要是类型的名字能出现的地方， 就能使用类型别名：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base 是 double 的同义词， p 是 double *的同义词</span></span><br><span class="line"></span><br><span class="line">wages hourly, weekly;<span class="comment">// 等价于 double hourly、 weekly;</span></span><br><span class="line">SI item; <span class="comment">// 等价于 Sales_item item</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="指针、-常量和类型别名"><a href="#指针、-常量和类型别名" class="headerlink" title="指针、 常量和类型别名"></a>指针、 常量和类型别名</h5><ul>
<li><p>如果某个类型别名指代的是复合类型或常量， 那么把它用到声明语句里就会产生意想不到的后果  </p>
</li>
<li><p>下面的声明语句用到了类型pstring,它实际上是类型 char *的别名：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225345870.png" alt="image-20220705225345870"></p>
<ul>
<li>pstring 实际上是指向 char 的指针， 因此， const pstring 就是指向char 的常量指针， 而非指向常量字符的指针。  </li>
<li>人们往往会错误地尝试把类型别名替换成它本来的样子， 以理解该语句的含义：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225640419.png" alt="image-20220705225640419"></li>
<li>这样改写的结果是， const char 成了基本数据类型。 前后两种声明含义截然不同， 前者声明了一个指向 char 的常量指针， 改写后的形式则声明了一个指向 const char 的指针。  </li>
</ul>
</li>
</ul>
<h4 id="auto-类型说明符"><a href="#auto-类型说明符" class="headerlink" title="auto 类型说明符"></a>auto 类型说明符</h4><ol>
<li>C++11 新标准引入了 auto 类型说明符</li>
<li>让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符（ 比如 double) 不同， auto 让编译器通过初始值来推算变量的类型。 显然， auto 定义的变量必须有初始值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230127843.png" alt="image-20220705230127843"></li>
<li>使用 auto 也能在一条语句中声明多个变量。 因为一条声明语句只能有一个基本数据类型， 所以该语句中所有变量的初始基本数据类型都必须一样：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230215573.png" alt="image-20220705230215573"></li>
</ol>
<h5 id="复合类型、-常量和-auto"><a href="#复合类型、-常量和-auto" class="headerlink" title="复合类型、 常量和 auto"></a>复合类型、 常量和 auto</h5><ol>
<li> 编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样， 编译器会适当地改变结果类型使其更符合初始化规则。</li>
<li>当引用被用作初始值时， 真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为 auto的类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230412863.png" alt="image-20220705230412863"></li>
<li>auto —般会忽略掉顶层 const (参见<a href ="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>）， 同时底层 const 则会 保留下来， 比如当初始值是一个指向常量的指针时：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230626358.png" alt="image-20220705230626358"></li>
<li>如果希望推断出的 auto 类型是一个顶层 const, 需要明确指出：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230709586.png" alt="image-20220705230709586"></li>
<li>将引用的类型设为 auto, 此时原来的初始化规则仍然适用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230754003.png" alt="image-20220705230754003"></li>
<li>要在一条语句中定义多个变量， 切记， 符号&amp;和*只从属于某个声明符， 而非基本数据类型的一部分， 因此初始值必须是同一种类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230843490.png" alt="image-20220705230843490"></li>
</ol>
<h4 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h4><ol>
<li>问题情景：希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量。   </li>
<li>decltype 类型指示符 ：C++11 新标准引入了第二种类型说明符decltype. 它的作用是选择并返回操作数的数据类型。 在此过程中， 编译器分析表达式<br>并得到它的类型， 却不实际计算表达式的值：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231052903.png" alt="image-20220705231052903"></li>
<li>decltype 处理顶层 const 和引用的方式与 auto 有些许不同。 如果 decltype 使用的表达式是一个变量， 则 decltype 返回该变量的类型( 包括顶层 const 和引用在内）：<br>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231159269.png" alt="image-20220705231159269"></li>
</ol>
<h5 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h5><p>如果 decltype 使用的表达式不是一个变量， 则 decltype 返回表达式结果对应的类型。  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231423081.png" alt="image-20220705231423081"></p>
<ol>
<li><p>r 是一个引用， 因此 decltype (r ) 的结果是引用类型  </p>
</li>
<li><p>如果想让结果类型是 r 所指的类型， 可以把 r 作为表达式的一部分， 如 r+0, 显然这个表达式的结果将是一个具体值而非一个引用。  </p>
</li>
<li><p>如果表达式的内容是解引用操作， 则 decltype 将得到引用类型。  </p>
<ol>
<li>解引用指针可以得到指针所指的对象， 而且还能给这个对象赋值  </li>
<li>因此， decltype ( *p) 的结果类艰就是 int &amp;， 而非 int。  </li>
</ol>
</li>
<li><p>decltype 和 auto 的另一处重要区別是， decltype 的结果类型与表达式形式密切相关。<br> 特别注意  ：</p>
<ol>
<li><p>对于 decltype 所用的表达式来说， 如果变量名加上了一对括号， 则得到的类型与不加括号时会有不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype 的表达式如果是加上了括号的变量， 结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span> ( (i) ) d;		<span class="comment">// 错误： d是 int&amp;， 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span> (i) e;			<span class="comment">// 正确： e 是一个（ 未初始化的 ） int</span></span><br></pre></td></tr></table></figure></li>
<li><p>decltype( ( variable ) ) ( 注意是双层括号 ） 的结果永远是引用， 而decltype( variable) 结果只有当 variable 本身就是一个引用时才是引用。  </p>
</li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/#comment-container"><span class="display-none-class">1fb5fb78276704826e2511f75be4a35c</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="1fb5fb78276704826e2511f75be4a35c">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 分钟  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）</a></h1><div class="content"><h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><ol>
<li><p>const 对象一旦创建后其值就不能再改变， 所以 const 对象必须初始化。  </p>
</li>
<li><p>初始值可以是任意复杂的表达式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="built_in">get_size</span>()； <span class="comment">// 正确：运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>；<span class="comment">// 正确：编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k；<span class="comment">//错误，k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="初始化和-const"><a href="#初始化和-const" class="headerlink" title="初始化和 const"></a>初始化和 const</h5><ul>
<li><p>非 const 类型所能参与的操作相比， const 类型的对象能完成其中大部分  </p>
</li>
<li><p>只能在 const 类型的对象上执行不改变其内容的操作  </p>
</li>
<li><p>const对象可以用于初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci  = i；	<span class="comment">// 正确： i的值被拷贝给了 ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci；			<span class="comment">// 正确： ci的值被拷贝给了 j</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="默认状态下，-const-对象仅在文件内有效"><a href="#默认状态下，-const-对象仅在文件内有效" class="headerlink" title="默认状态下， const 对象仅在文件内有效"></a>默认状态下， const 对象仅在文件内有效</h5><ol>
<li><p>const对象的生效过程：</p>
<ul>
<li>当以编译时初始化的方式定义一个const对象时：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>; / / 输入缓冲区大小</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器将在编译过程中把用到该变量的地方都替换成对应的值。 </li>
<li>为了执行上述替换， 编译器必须知道变量的初始值  </li>
<li>如果程序包含多个文件， 则每个用了 const 对象的文件都必须得能访问到它的初始值才行。   </li>
<li>要做到这一点， 就必须在每一个用到变量的文件中都有对它的定义（ <a href = "# 2.2.2    变量声明和定义的关系 ">参见 2.2.2 节， 第 41 页  </a>）。</li>
<li>为了支持这一用法，同时避免对同一变量的重复定义， 默认情况下， const 对象被设定为仅在文件内有效  </li>
<li>当多个文件中出现了同名的 const 变量时， 其实等同于在不同文件中分别定义了独立的变量。  </li>
</ul>
</li>
<li><p>问题场景：</p>
<ul>
<li><p>某些时候有这样一种 const 变量， 它的初始值不是一个常量表达式， 但又确实有必要在文件间共享。 这种情况下， 我们不希望编译器为每个文件分别生成独立的变量。 相反，我们想让这类 const 对象像其他（ 非常量） 对象一样工作， 也就是说， 只在一个文件中定义 const， 而在其他多个文件中声明并使用它  </p>
</li>
<li><p>解决办法：</p>
<ul>
<li><p>如果想在多个文件之间共享 const 对象， 必须在变量的定义之前添加 extern关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_l.cc 定义并初始化了一个常量， 该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span> ( );</span><br><span class="line"><span class="comment">// file_l.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">/// / 与 file_1.cc 中定义的 bufSize 是同一个</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a>const 的引用</h4><ol>
<li><p>对常量 的引用（ reference to const)</p>
<p>把引用绑定到 const 对象上， 就像绑定到其他对象上一样，</p>
</li>
<li><p>对常量的引用不能被用作修改它所绑定的对象：</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// 正确： 引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;	<span class="comment">// 错误： r1 是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">// 错误： 试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>术语：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705153505715.png" alt="image-20220705153505715"></p>
<h5 id="初始化和对-const-的引用"><a href="#初始化和对-const-的引用" class="headerlink" title="初始化和对 const 的引用"></a>初始化和对 const 的引用</h5><ol>
<li><p>引用的类型必须与其所引用对象的类型一致（<a href =  "#2.3.1    引用">2.3.1 第46页</a>）， 但是有两个例外  </p>
<ol>
<li><p>在初始化常量引用时允许用任意表达式作为初始值， 只要该表达式的结果能转换成（<a href = "#2.1.2    类型转换">参见 2.1.2 节， 第 32 页</a> ） 引用的类型即可。  尤其， 允许为一个常量引用绑定非常量的对象、 字面值， 甚至是个一般表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// 允许将 const int &amp;绑定到一个普通 int 对象上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">// 正确： r1 是一个常量引用	</span></span><br><span class="line"><span class="comment">//读者疑问：这里和r1有什么关系？笔误吗？正确的写法是const int &amp;r2 = r1；？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// 正确： r3 是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">// 错误： r4 是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>细节探究1：当一个常量引用被绑定到另外一种类型上时到底发生了什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处 ri 引用了一个 int 型的数。 对 ri 的操作应该是整数运算， 但 dval 却是一个双精<br>度浮点数而非整数。 因此为了确保让 ri 绑定一个整数， 编译器把上述代码变成了如下<br>形式:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval；<span class="comment">// 由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;	<span class="comment">// // 让ri 绑定这个临时量</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下， ri 绑定了一个临时量 ( temporary ) 对象。</p>
<p>所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 </p>
<p>C++程序员们常常把临时量对象简称为临时量。</p>
<p>接下来探讨当ri 不是常量时， 如果执行了类似于上面的初始化过程将带来什么样的<br>后果。</p>
<p> 如果ri 不是常量， 就允许对ri 赋值， 这样就会改变ri 所引用对象的值。</p>
<p> 注意，此时绑定的对象是一个临时量而非 dval。 </p>
<p>程序员既然让 ri 引用 dval, 就肯定想通过ri改变dval的值， 否则干什么要给ri赋值呢？ </p>
<p>如此看来， 既然大家基本上不会想着把引用绑定到临时量上， C++语言也就把这种行为归为非法。  </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="对-const-的引用可能引用一个并非-const-的对象"><a href="#对-const-的引用可能引用一个并非-const-的对象" class="headerlink" title="对 const 的引用可能引用一个并非 const 的对象"></a>对 const 的引用可能引用一个并非 const 的对象</h5><ol>
<li><p>常量引用仅对引用可参与的操作做出了限定， 对于引用的对象本身是不是一个常量未作限定</p>
</li>
<li><p>因为对象也可能是个非常量， 所以允许通过其他途径改变它的值 :</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;<span class="comment">// 引 用 ri绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">// r2 也绑定对象i, 但是不允许通过 r2 修改i的值</span></span><br><span class="line">r1 =  <span class="number">0</span>;<span class="comment">// r1 并非常量 ， i的值修改为 0</span></span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">// 错误： r2 是一个常量引用</span></span><br></pre></td></tr></table></figure>

<p>读者疑问：那么在上面这个例子里面，常量引用r2的值也被改成了0吗？常量引用为什么可以改变？</p>
</li>
</ol>
<h4 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h4><ol>
<li><p>与引用一样， 也可以令指针指向常量或非常量  </p>
</li>
<li><p>类似于常量引用（  <a href ="#2.4.1    const 的引用">参见 2.4.1 节， 第54 页</a>）， 指向常量的指针（pointer to const) 不能用于改变其所指对象的值。  </p>
</li>
<li><p>要想存放常量对象的地址， 只能使用指向常量的指针：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;		<span class="comment">// pi 是个常量， 它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;			<span class="comment">// 错误： ptr 是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;	<span class="comment">// 正确： cptr 可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;					<span class="comment">// 错误： 不能给*cptr 賦值</span></span><br></pre></td></tr></table></figure></li>
<li><p>指针的类型必须与其所指对象的类型一致( <a href ="#2.3.2    指针">2.3.2 节（ 第 47 页）</a>)<br>例外情况：</p>
<ol>
<li><p>允许令一个指向常量的指针指向一个非常量对象  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;<span class="comment">// dval 是一个双精度浮点数， 它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;<span class="comment">//正确： 但是不能通过 cptr 改变 dval 的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>和常量引用一样， 指向常量的指针也没有规定其所指的对象必须是一个常量  </p>
<ol>
<li>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值， 而没有规定那个对象的值不能通过<br>其他途径改变。</li>
</ol>
</li>
<li><p>关于指向常量的指针或者引用的总结：</p>
<p>试试这样想吧： 所谓指向常量的指针或引用， 不过是指针或引用 “ 自以为是’罢了， 它们觉得自己指向了常量， 所以自觉地不去改变所指对象的值。  </p>
</li>
</ol>
</li>
</ol>
<h5 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h5><ol>
<li><p>指针是对象而引用不是， 因此就像其他对象类型一样， 允许把指针本身定为常量  </p>
</li>
<li><p>常量指针 (const pointer) 必须初始化， 而且一旦初始化完成， 则它的值（ 也就是存放在指针中的那个地址） 就不能再改变了。   </p>
</li>
<li><p>不变的是指针本身的值而非指向的那个值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215121742.png" alt="image-20220705215121742"></p>
</li>
<li><p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值， 能否这样做完全依赖于所指对象的类型</p>
<ol>
<li><p>所指向的对象是常量，则不能修改</p>
</li>
<li><p>所指向的对象是非常量，则完全可以通过这个对象或者这个常量指针 去修改这个被指向对象的值</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215732072.png" alt="image-20220705215732072"></p>
</li>
</ol>
</li>
</ol>
<h4 id="顶层-const-读者注：这一小节读者表示看不明白"><a href="#顶层-const-读者注：这一小节读者表示看不明白" class="headerlink" title="顶层 const(读者注：这一小节读者表示看不明白~~~)"></a>顶层 const(读者注：这一小节读者表示看不明白~~~)</h4><ol>
<li><p>问题情景：</p>
<ol>
<li>指针本身是个对象，他又可以指向另外的对象；指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。 </li>
</ol>
</li>
<li><p>顶层const(top-level const)  </p>
<ol>
<li>指针本身是个常量  </li>
</ol>
</li>
<li><p>底层 const (low-level const)  </p>
<ol>
<li>指针所指的对象是一个常量  </li>
</ol>
</li>
<li><p>顶层const和底层 const的区分()</p>
<ol>
<li><p>顶层 const 可以表示任意的对象是常量， 这一点对任何数据类型都适用，如算术类型、 类、 指针等  </p>
</li>
<li><p>底层 const 则与指针和引用等复合类型的基本类型部分有关。  </p>
</li>
<li><p>指针类型既可以是顶层 const 也可以是底层 const  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> pi = &amp;i;<span class="comment">// 不能改变 pi 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">// 不能改变 ci 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">// 允许改变 p2 的值， 这是一个底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的 const 是顶层 const, 靠左的是底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;<span class="comment">// 用于声明引用的 const 都是底层 const</span></span><br></pre></td></tr></table></figure></li>
<li><p>当执行对象的拷贝操作时， 常量是顶层 const 还是底层 const 区别明显。 其中， 顶层 const 不受什么影响：</p>
</li>
<li><p>另一方面， 底层 const 的限制却不能忽视。 当执行对象的拷贝操作时， 拷入和拷出的对象必须具有相同的底层 const 资格， 或者两个对象的数据类型必须能够转换。 一般来说， 非常量可以转换成常量， 反之则不行： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i= ci;<span class="comment">// 正确： 拷贝 ci 的值， ci 是一个顶层 const， 对此操作无影响</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 指向的对象类型相同， p3 顶层 const 的部分不影响</span></span><br><span class="line"><span class="keyword">int</span> *p = p3;<span class="comment">// 错误： p3 包含底层 const 的定义， 而 p 没有</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 都是底层 const</span></span><br><span class="line">p2 = &amp;i;<span class="comment">// 正确： int 能转换成 const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r ci;<span class="comment">// 错误： 普通的 int &amp;不能绑定到 int 常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 =i;<span class="comment">//正确：const int &amp;可以绑定到一个普通 int 上</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h4><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><ol>
<li><p>指值不会改变并且在编译过程就能得到计算结果的表达式 ；字面值属于常量表达式  </p>
</li>
<li><p>常量表达式初始化的 const 对象也是常量表达式  </p>
</li>
<li><p>一个对象（ 或表达式） 是不是常量表达式由它的数据类型和初始值共同决定  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221351129.png" alt="image-20220705221351129"></p>
<p>![image-20220705221413365](D:\书本和读书笔记\Primer C++ 第五版（第一部分 C++基础  第二章 变量和基本类型）.assets\image-20220705221413365.png)</p>
</li>
</ol>
<h5 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h5><ol>
<li>C++11 新标准规定， 允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式 </li>
<li>声明为 constexpr 的变量一定是一个常量， 而且必须用常量表达式初始化：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221643749.png" alt="image-20220705221643749"></li>
<li>注意事项：<ol>
<li>函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量。  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） </li>
<li>相反的， 定义于所有函数体之外的对象其地址固定不变， 能用来初始化 constexpr 指针  </li>
<li>允许函数定义一类有效范围超出函数本身的变量  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） ， 这类变量和定义在函数体之外的变量一样也有固定地址。 因此， constexpr 引用能绑定到这样的变量上， constexpr 指针也能指向这样的变量。  </li>
</ol>
</li>
</ol>
<h5 id="字面值类型-（-literal-type"><a href="#字面值类型-（-literal-type" class="headerlink" title="字面值类型  （ literal type)"></a>字面值类型  （ literal type)</h5><ul>
<li>问题情景：常量表达式的值需要在编译时就得到计算， 因此对声明 constexpr 时用到的类型必须有所限制  </li>
<li>这些类型一般比较简单， 值也显而易见、 容易得到， 就把它们称为“ 字面值类型”（ literal type)。</li>
<li>有哪些？<ul>
<li> 算术类型、 引用和指针都属于字面值类型  </li>
<li> 自定义类 Sales_item、 10 库、 string 类型则不属于字面值类型， 也就不能被定义成constexpr  </li>
<li> 其他字面值类型<a href = "#">7.5.6 节（ 第 267 页） 和 19.3 节（ 第 736 页）  </a></li>
</ul>
</li>
<li>指针和引用都能定义成 constexpr, 但它们的初始值却受到严格限制  </li>
<li>一个constexpr 指针的初始值必须是nullptr 或者 0,或者是存储于某个固定地址中的对象  </li>
</ul>
<h5 id="指针和-constexpr"><a href="#指针和-constexpr" class="headerlink" title="指针和 constexpr"></a>指针和 constexpr</h5><ul>
<li><p>在 constexpr 声明中如果定义了一个指针， 限定符 constexpr 仅  对指针有效， 与指针所指的对象无关</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223219365.png" alt="image-20220705223219365"></p>
</li>
</ul>
<p>​        p 是一个指向常量的指针， 而 q 是一个常量指针， 其中的关键在于 constexpr 把它所定义的对象置为了顶层 const <a href="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>.</p>
<ul>
<li><p>constexpr 指针既可以指向常量也可以指向一个非常量：  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223703473.png" alt="image-20220705223703473"></p>
</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/#comment-container"><span class="display-none-class">ab6347e30ef93c668d39bdf0bae27331</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="ab6347e30ef93c668d39bdf0bae27331">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>15 分钟  <i class="fas fa-pencil-alt"> </i>2.2 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）</a></h1><div class="content"><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>具名的、 可供程序操作的存储空间；  </p>
</li>
<li><p>每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、 该空间能存储的值的范围， 以及变量能参与的运算。  </p>
</li>
</ul>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><h5 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h5><ol>
<li><p>首先是类型说明符 （ type specifier), 随后紧跟由一个或多个变量名组成的列表， 其中变量名以逗号分隔， 最后以分号结束；  </p>
</li>
<li><p>列表中每个变量名的类型都由类型说明符指定， 定义时还可以为一个或多个变量赋初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, value, units_sold = <span class="number">0</span>； 	<span class="comment">// sum、 value 和 units_sold 都是 int</span></span><br><span class="line">										<span class="comment">//units_sold 初值为 0</span></span><br><span class="line"></span><br><span class="line">Sales_item item；			<span class="comment">// item的类型是Sales_item(参见1.5.1节，第17页 ）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string是一种库类型,表示一个可变长的字符序列</span></span><br><span class="line">std::string <span class="built_in">book</span>(<span class="string">&quot;0-201-78345-X&quot;</span> )；<span class="comment">//book通过一个string字面值初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象初识：<br>一块能存储数据并具有某种类型的内存空间 。</p>
</li>
</ol>
<h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><p>当对象在创建时获得了一个特定的值， 我们说这个对象被初始化 （ initialized) 了。  </p>
<ol>
<li><p>于初始化变量的值可以是任意复杂的表达式 ；</p>
</li>
<li><p>当一次定义了两个或多个变量时， 对象的名字随着定义也就马上可以使用了  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ / 正确： price 先被定义并賦值， 随后被用于初始化 discount</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">109.99</span>, discount = price * <span class="number">0.16</span>;</span><br><span class="line">/ /正确： 调用函数 applyDiscount， 然后用函数的返回值初始化 <span class="function">salePrice</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> salePrice <span class="title">applyDiscount</span> <span class="params">(price, discount )</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化是一个异常复杂的问题 ；很多程序序员对于用等号=来初始化变量的方式倍感闲惑， 这种方式容易让人认为初始化足赋值的一种 </p>
<ul>
<li>初始化和赋值是两个完全不同的操作  </li>
<li>在很多编程语言中，二者的区别几乎可以忽略不计  </li>
<li>初始化不是賦值， 初始化的含义是创建变量时賦予其一个初始值， 而赋值的含义是把对象的当前值擦除， 而以一个新值来替代 </li>
</ul>
</li>
</ol>
<h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><ul>
<li><p>C++11 新标准的一部分  </p>
</li>
<li><p>```c++<br>int units_sold = 0；<br>int units_sold = {0}；//列表初始化<br>int units_sold{0}；//列表初始化<br>int units_sold(0)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 无论是初始化对象还是某些时候为对象赋新值， 都可以使用这样一组由花括号括起来的初始值了。</span><br><span class="line"></span><br><span class="line">- 当用于内置类型的变量时， 这种初始化形式有一个重要特点： </span><br><span class="line">      如果我们使用列表初始化初始值存在丢失信息的风险， 则编译器将报错：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  long double Id = 3.1415926536；</span><br><span class="line">  int a&#123;ld&#125;, b = &#123;Id&#125;；	//错误： 转换未执行， 因为存在去失信息的危险</span><br><span class="line">  int c(Id), d = Id；		//正确 ： 转换执行， 且确实丢失了部分值</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><ul>
<li>定义变量时没有指定初值， 则变量被默认初始化 （ default initialized )  </li>
<li>变量类型和定义变量的位置也会对此有影响。</li>
<li>内置类型的变量未被显式初始化， 它的值由定义的位置决定  </li>
<li>定义于任何函数体之外的变量被初始化为 0  </li>
<li>定义在函数体内部的内置类型变量将不被初始化（ uninitialized)。<ul>
<li> 未被初始化的内置类型变量的值是未定义的  </li>
<li> 试图拷贝或以其他形式访问此类值将引发错误。  </li>
</ul>
</li>
</ul>
<h4 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h4><h5 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h5><ol>
<li>目的：为了允许把程序拆分成多个逻辑部分来编写  </li>
<li>形式：允许将程序分割为若干个文件， 每个文件可被独立编译  </li>
<li>要求：需要有在文件间共享代码的方法  </li>
<li>例如：一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是 std::cout 和 std::cin,<br>它们定义于标准库， 却能被我们写的程序使用。</li>
<li>C++的支持模式：声明和定义分开<ol>
<li> 声明（ declaration) 使得名字为程序所知， 一个文件如果想使用别处定义的名字则必须包含对那个名字的声明  </li>
<li> 定义(definition) 负责创建与名字关联的实体。</li>
</ol>
</li>
</ol>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同  </p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同；定义还申请存储空间， 也可能会为变量赋一个初始值 </p>
<h5 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h5><ol>
<li><p>如果想声明一个变量而非定义它， 就在变量名前添加关键字 extern, 而且不要显式地初始化变量  </p>
</li>
<li><p>任何包含了显式初始化的声明即成为定义  </p>
</li>
<li><p>在函数体内部， 如果试图初始化一个由 extern 关键字标记的变量， 将引发错误</p>
</li>
<li><p>变量能且只能被定义一次， 但是可以被多次声明。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i； <span class="comment">// 声 明i而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j； <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>；<span class="comment">//声明并且定义了k，还为k申请了内存空间并且进行了显示初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span><span class="number">.16</span>; <span class="comment">// 定义    </span></span><br></pre></td></tr></table></figure></li>
<li><p>使用情景：</p>
<ol>
<li>如果要在多个文件中使用同一个变量， 就必须将声明和定义分离  </li>
<li>变量的定义必须出现在且只能出现在一个文件中， 而其他用到该变量的文件必须对其进行声明， 却绝对不能重复定义。 </li>
</ol>
</li>
</ol>
<h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110037691.png" alt="image-20220705110037691"></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li><p>由字母、 数字和下画线组成  </p>
</li>
<li><p>必须以字母或下画线开头  </p>
</li>
<li><p>长度没有限制 ；对大小写字母敏感  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ / 定义 <span class="number">4</span> 个不同的 <span class="keyword">int</span> 变量</span><br><span class="line"><span class="keyword">int</span> somename, someName, SomeName, SOMENAME;</span><br></pre></td></tr></table></figure></li>
<li><p>C++语言保留了一些名字供语言本身使用， 这些名字不能被用作标识符  ；如表 2.3 和表 2.4 所示<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110334152.png" alt="image-20220705110334152"><br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110356276.png" alt="image-20220705110356276"></p>
</li>
<li><p>用户自定义的标识符中不能连续出现两个下画线， 也不能以下画线紧连大写字母开头  </p>
</li>
<li><p>定义在函数体外的标识符不能以下画线开头。</p>
</li>
</ul>
<h5 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h5><ul>
<li> 标识符要能体现实际含义。</li>
<li> 变量名一般用小写字母， 如 index, 不要使用 Index 或 INDEX。</li>
<li> 用户自定义的类名一般以大写字母开头， 如 SaleS_item。</li>
<li> 如果标识符由多个单词组成， 则单词间应有明显区分，如student_loan或student_Loan；不要使用 studentloan.</li>
</ul>
<h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><ol>
<li><p>每个名字都会指向一个特定的实体： 变量、 函数、 类型等  </p>
</li>
<li><p>同—个名字如果出现在程序的不同位置， 也可能指向的是不同实体  </p>
</li>
<li><p>作用域  </p>
<ol>
<li>C++语言中大多数作用域都以花括号分隔。</li>
</ol>
</li>
<li><p>实例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705111857075.png" alt="image-20220705111857075"></p>
</li>
</ol>
<h5 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h5><ol>
<li><p>作用域能彼此包含  </p>
</li>
<li><p>内层作用域 ( innerscope )  ：被包含（ 或者说被嵌套） 的作用域  </p>
</li>
<li><p>外层作用域 ( outer scope)  ：包含着别的作用域的作用域  </p>
</li>
<li><p>作用域中一旦声明了某个名字， 它所嵌套着的所有作用域中都能访问该名字  </p>
</li>
<li><p>允许在内层作用域中重新定义外层作用域已有的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 该程序仅用于说明 ： 函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; / / reused 拥有全局作用域</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique <span class="number">0</span>; / / unique 拥有块作用域</span><br><span class="line">    <span class="comment">// 输出 #1: 使用全局变量 reused;输出 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量 reused， 覆盖了全局变量 reused</span></span><br><span class="line">    <span class="comment">// 输出 #2: 使用局部变量 reused; 输出 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出#3: 显式地访问全局变量 reused; 输出 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//全局作用域本身并没有名字， 所以当作用域操作符的左侧为空时， </span></span><br><span class="line">    <span class="comment">//向全局作用域发出请求获取作用域操作符右侧名字对应的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数有可能用到某全局变量， 则不宜再定义一个同名的局部变量 </p>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">83ddaccf0684812d1829b07735b89f52</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="83ddaccf0684812d1829b07735b89f52">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>20 分钟  <i class="fas fa-pencil-alt"> </i>3.0 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）</a></h1><div class="content"><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>基于其他类型定义的类型 </li>
<li>本章将介绍其中的两种： 引用和指针  </li>
<li>声明语句 :基本数据类型（ base type)  +  声明符( declarator) 列表  </li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol>
<li><p>概念：对象起了另外一个名字  </p>
<pre><code>引用类型引用（ refers to) 另外一种类型  ？（这话什么意思?）
</code></pre>
</li>
<li><p>如何定义：将声明符写成 &amp;d 的形式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival； 	<span class="comment">// refVal 指向 ival ( 是 ival 的另一个名字 ）</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal；	<span class="comment">// 报错： 引用必须被初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用的实质：</p>
<ol>
<li><p>定义引用时， 程序把引用和它的初始值绑定（ bind) 在一起， 而不是将初始值拷贝给引用。   </p>
<ol>
<li>定义初始化引用和定义变量的区别：在初始化变量时， 初始值会被拷贝到新建的对象中；  </li>
</ol>
</li>
<li><p>一旦初始化完成， 引用将和它的初始值对象一直绑定在一起。 因为无法令引用重新绑定到另外一个对象， 因此引用必须初始化。 </p>
</li>
<li><p>引用并非对象， 相反的， 它只是为一个已经存在的对象所起的另外一个名字 </p>
</li>
<li><p>定义了一个引用之后， 对其进行的所有操作都是在与之绑定的对象上进行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把 2 賦给 refVal 指向的对象 ， 此处即是賦给了 ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal; <span class="comment">// 与ii = ival 执行结果一样</span></span><br><span class="line"><span class="comment">//正确： refVal3 绑定到了那个与 refVal 绑定的对象上， 这里就是绑定到 ival 上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">// 利 用 与 refVal 绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="keyword">int</span> i = refVal; <span class="comment">// 正确： i被初始化为 ival 的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h5><ul>
<li><p>允许在一条语句中定义多个引用， 其中每个引用标识符都必须以符号 &amp;开头 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>,i2 = <span class="number">2048</span>; <span class="comment">//i和i2 都是 int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r =i, r2 =i2;<span class="comment">// r 是一个引用， 与i绑定在一起， r2 是 int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri =i3; <span class="comment">//i3 是 int, ri是一个引用， 与i3 绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 =i2; <span class="comment">// r3 和 r4 都是引用</span></span><br></pre></td></tr></table></figure></li>
<li><p>所有引用的类型都要和与之绑定的对象严格匹配 ；（<a> </a><a href = "#2.4.1    const 的引用 ">2.4.1节</a>  、 <a href="#15.2.3    ">15.2.3节</a>将会介绍两种特殊情况） </p>
</li>
<li><p>引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起 （<a href= "#2.4.1    const 的引用">2.4.1 节详述 </a>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>; <span class="comment">// 错误： 引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval; <span class="comment">// 错误： 此处引用类型的初始值必须是 int 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol>
<li><p>定义：“ 指向（ point to)” 另外一种类型的复合类型  </p>
</li>
<li><p>作用：实现了对其他对象的间接访问  </p>
</li>
<li><p>指针和引用的区别：</p>
<ol>
<li>指针本身就是一个对象， 允许对指针赋值和拷贝</li>
<li>在指针的生命周期内它可以先后指向几个不同的对象  </li>
<li>指针无须在定义时赋初值</li>
<li>块作用域内定义的指针如果没有被初始化， 也将拥有一个不确定的值，这和和其他内置类型一样</li>
</ol>
</li>
<li><p>定义指针类型的方法 </p>
<ul>
<li><p>将声明符写成*d 的形式 </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ipl，*ip2； <span class="comment">// ipl 和ip2 都是指向 int 型对象的指针</span></span><br><span class="line"><span class="keyword">double</span> dp，*dp2; <span class="comment">// dp2 是指向 double 型对象的指针， dp 是 double 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h5><ol>
<li><p>方法：取地址符（ 操作符 &amp; ):  </p>
</li>
<li><p>作用：指针存放某个对象的地址， &amp;获取该地址， </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p 存放变量 ival 的地址， 或者说p 是指向变量 ival 的指针</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项：</p>
<ol>
<li><p>引用不是对象， 没有实际地址， 所以不能定义指向引用的指针  </p>
</li>
<li><p>所有指针的类型都要和它所指向的对象严格匹配（<a href = "#2.4.2    指针和 const  ">2.4.2节</a>，<a href="#">15.2.3 节  </a>将介绍两种例外情况）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval；<span class="comment">// 正确： 初始值是 double 型对象的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd；<span class="comment">// 正确： 初始值是指向 double 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *pi = pd；<span class="comment">// 错误： 指针 pi 的类型和 pd 的类型不匹配</span></span><br><span class="line">pi = &amp;dval；<span class="comment">// 错误： 试图把 double 型对象的地址赋给 int 型指针</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>指针的值（ 即地址） 应属下列 4 种状态之一:  </p>
<ol>
<li>指向一个对象。  </li>
<li>指向紧邻对象所占空间的下一个位置。  </li>
<li>空指针， 意味着指针没有指向任何对象  </li>
<li>无效指针， 也就是上述情况之外的其他值  </li>
</ol>
<p>注意事项：</p>
<ol>
<li>试图拷贝或以其他方式访问无效指针的值都将引发错误（编译器不检查此类错误）</li>
<li>第 2 种和第 3 种形式的指针是有效的， 但其使用同样受到限制  ；这些指针没有指向任何具体对象， 所以试图访问此类指针（ 假定的） 对象的行为不被允许。</li>
</ol>
<h5 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h5><ol>
<li><p>如果指针指向了一个对象， 则允许使用解引用符（ 操作符* ) 来访问该对象:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">// p 存放着变量ival的地址， 或者说p 是指向变量ival的指针</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">// 由符号*得到指针 p 所指的对象， 输出 42</span></span><br></pre></td></tr></table></figure></li>
<li><p>对指针解引用会得出所指的对象  ;因此如果给解引用的结果赋值， 实际上也就是给指针所<br>指的对象赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;<span class="comment">// 由符号 *得到指针 p 所指的对象， 即可经由 p 为变量 ival 賦值</span></span><br><span class="line">cout &lt;&lt; *p； <span class="comment">//输出0</span></span><br><span class="line">cout &lt;&lt; ival； <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure></li>
<li><p>解引用操作仅适用于那些确实指向了某个对象的有效指针  </p>
</li>
<li><p>重点符号解析 <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705134829386.png" alt="image-20220705134829386"></p>
</li>
</ol>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><ol>
<li><p>空指针  （null pointer )   ：<br>不指向任何对象  </p>
</li>
<li><p>生成空指针的样例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705135446493.png" alt="image-20220705135446493"></p>
</li>
<li><p>注意事项：</p>
<p>在试图使用一个指针之前代码可以首先检查它是否为空  </p>
</li>
<li><p>拓展知识</p>
<ol>
<li>预处理变量（preprocessor variable)  ：NULL  给指针赋值， 这个变量在头文件 cstdlib 中定义， 它的值就是 0  </li>
<li>预处理器 （<a href = "# 2.6.3    编写自己的头文件 ">2.6.3 节</a>） ：是运行于编译过程之前的一段程序  <ol>
<li>预处理变量不属于命名空间 std  </li>
<li>由预处理器负责管理  </li>
</ol>
</li>
<li>关于给指针变量赋空指针的建议：<ol>
<li>最好使用 nullptr,同时尽量避免使用 NULL.  </li>
<li>把 int 变量直接陚给指针是错误的操作， 即使 int 变量的值恰好等于 0 也不行。<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140303477.png" alt="image-20220705140303477"></li>
<li>建议： 初始化所有指针<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140417164.png" alt="image-20220705140417164"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h5><ol>
<li><p>指针和引用的区别：</p>
<ol>
<li><p>指针，指针和他指向的对象之间的对应关系可以修改，也就是说，指针可以修改</p>
</li>
<li><p>引用，并不是一个对象，引用一旦确定是无法修改的</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705142026882.png" alt="image-20220705142026882"></p>
</li>
</ol>
</li>
<li><p>一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值  </p>
<ol>
<li><p>赋值永远改变的是等号左侧的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;ival;<span class="comment">// pi 的值被改变， 现在 pi 指向了 ival</span></span><br><span class="line"></span><br><span class="line">*pi = <span class="number">0</span>;<span class="comment">// ival 的值被改变， 指针pi 并没有改变,</span></span><br><span class="line">		<span class="comment">//*Pi( 也就是指针pi 指向的那个对象） 发生改变。</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h5><p>更过内容参见 <a href = "#3.5.3     指针和数组 ">3.5.3节</a> </p>
<p>只要指针拥有一个合法值， 就能将它用在条件表达式中。 和采用算术值作为条件（ <a href = " # 2.1.2    类型转换">2.1.2 节， 第 32 页</a> ） 遵循的规则类似， 如果指针的值是 0, 条件取 false:  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143008646.png" alt="image-20220705143008646"></p>
<p>指针比较的注意事项：</p>
<ol>
<li>两个类型相同的合法指针， 可以用相等操作符（=) 或不相等操作符（!=) 来比较它们， 比较的结果是布尔类型</li>
<li>两个指针存放的地址值相同， 则它们相等： 反之它们不相等。  </li>
<li>必须使用合法指针， 使用非法指针作为条件或进行比较都会引发不可预计的后果。</li>
</ol>
<h5 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h5><p>特殊的指针类型， 可用于存放任意对象的地址</p>
<p>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143502627.png" alt="image-20220705143502627"></p>
<ol>
<li>void* 指针 的作用<ol>
<li>和别的指针比较  </li>
<li>作为函数的输入或输出  </li>
<li>赋给另外一个 void*指针  </li>
</ol>
</li>
<li>void*不能做的事情<ol>
<li>不能直接操作 void*指针所指的对象， 因为我们并不知道这个对象到底是什么类型， 也就无法确定能在这个对象上做哪些操作  </li>
<li>详情参见<a href = "# ">19.1.1 节（ 第 726 页）  </a></li>
</ol>
</li>
<li>获取 void*指针所存地址的方法<br><a href = "# 4.11.3     显式转换 ">4.11.3 节（ 第 144<br>页）</a></li>
</ol>
<h4 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h4><ul>
<li>变量的定义包括 ：一个基本数据类型 （ base type) 和一组声明符  <ul>
<li>基本数据类型只有一个， 但是声明符的形式却可以不冋  <ul>
<li>一条定义语句可能定义出不同类型的变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144116016.png" alt="image-20220705144116016"></li>
</ul>
</li>
<li>很多程序员容易迷惑于基本数据类型和类型修饰符的关系， 其实后者（类修饰符）不过是声明符的一部分罢了。（读者问：为什么这么说？）  </li>
</ul>
</li>
</ul>
<h5 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h5><ol>
<li>场景误区1：<ol>
<li>在定义语句中， 类型修饰符（ <em>或 &amp; ) 作用于本次定义的全部变量  。样例如下：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144855828.png" alt="image-20220705144855828"></em></li>
<li>基本数据类型是 int 而非 int* ;   *仅仅是修饰了 p 而已， 对该声明语句中的其他变量， 它并不产生任何作用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145027723.png" alt="image-20220705145027723"> </li>
</ol>
</li>
<li>涉及指针（*）和引用（&amp;）的两种良好书写方式：<ol>
<li>把修饰符和变量标识符写在一起<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145121668.png" alt="image-20220705145121668"><br>着重强调变量具有的复合类型  </li>
<li>把修饰符和类型名写在一起， 并且每条语句只定义一个变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145234491.png" alt="image-20220705145234491"><br>着重强调本次声明定义了一种复合类型</li>
</ol>
</li>
</ol>
<h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><ul>
<li> 声明符中修饰符的个数并没有限制  </li>
<li> 多个修饰符连写在一起时， 按照 其逻辑关系详加解释即可  </li>
<li>样例：<ul>
<li>指针是内存中的对象， 像其他对象一样也有自己的地址， 因此允许把指针的地址再存放到另一个指针当中。这就是指向指针的指针  .</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145705407.png" alt="image-20220705145705407"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145719372.png" alt="image-20220705145719372"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145812143.png" alt="image-20220705145812143"></p>
<h5 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h5><ul>
<li><p>引用本身不是一个对象， 因此不能定义指向引用的指针。</p>
</li>
<li><p>但指针是对象， 所以存在对指针的引用  。</p>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145915375.png" alt="image-20220705145915375"></p>
<pre><code>解读方式：int *&amp;r = p;
1.最简单的办法是从右向左阅读 r 的定义
2.离变量名最近的符号（ 此例中是&amp;r 的符号&amp; ) 对变量的类型有最直接的影响， 因此 r 是一个引用。
3.声明符的其余部分用以确定 r 引用的类型是什么， 此例中的符号* 说明 r 引用的是一个指针。
4.最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。
</code></pre>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">4f414a57dff37f6a58bd2f6e4d685fc6</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="4f414a57dff37f6a58bd2f6e4d685fc6">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>12 分钟  <i class="fas fa-pencil-alt"> </i>1.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）</a></h1><div class="content"><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><ul>
<li>包括算术类型（ arithmetic type ) 和空类型（ void)   </li>
</ul>
<h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><ol>
<li><p>整型（ integral type， 包括字符和布尔类型在内）   </p>
</li>
<li><p>浮点型 </p>
<p>算术类型的取值范围 </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630182629855.png" alt="image-20220630182629855"></p>
<ul>
<li>扩展字符集<ul>
<li>wchar_t, char16_t、 char32_t  </li>
<li>用于确保可以存放机器最大扩展字符集士的任意一个字符  </li>
<li>char16_t 和char32_t 则为 Unicode 字符集服务 (Unicode 是用于表示所有自然语言中字符的标准)  </li>
<li>大小关系：short &lt;=  int &lt;= long &lt;= long long;</li>
</ul>
</li>
<li>计算机内存单位转换<ul>
<li>寻址的最小内存块称为“ 字节（ byte )  ，一般一个字节由8比特组成</li>
<li>存储的基本单元称为 ‘‘ 字（ word )”， 它通常由几个字节组成  </li>
<li>字则由 32 或 64 比特构成， 也就是 4 或 8 字节  </li>
</ul>
</li>
<li>带符号类型和无符号类型  <ul>
<li>除去布尔型和扩展的字符型之外， 其他整型可以划分为带符号的（ signed) 和无符号<br>的（ unsigned) 两种  </li>
<li>带符号类型可以表示正数、 负数或 0  </li>
<li>无符号类型则仅能表示大于等于 0 的值。 </li>
</ul>
</li>
<li>字符型   <ul>
<li>char、 signed char 和 unsigned char  </li>
<li>类型 char 和类型 signed char 并不一样 </li>
<li>尽管字符型有三种， 但是字符的表现形式却只有两种： 带符号的和无符号的。 类型 char 实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定  </li>
</ul>
</li>
<li>数据类型选择准则<ul>
<li> 数值不可能为负时， 选用无符号类型</li>
<li> int 执行整数运算（short 常常显得太小  ）  </li>
<li> 整数运算的数值超过了int 的表示范围， 选用 long long（long 一般和 int有一样的尺寸）</li>
<li>算术表达式中不要使用 char 或 bool <ul>
<li> 类型 char 在一些机器上是有符号， 而在另一些机器上又是无符号，行运算特别容易出问题  ；</li>
<li> 如果你需要使用一个不大的整数，明确指定它的类型是 signed char 或者 unsigned char</li>
</ul>
</li>
<li> 执行浮点数运算选用 double, 这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几</li>
<li> long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视 。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>​                将对象从一种给定的类型转换 ( convert) 为另一种相关类型 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>; <span class="comment">// b 为真</span></span><br><span class="line"><span class="keyword">int</span> i = b;	<span class="comment">// i的值为 1</span></span><br><span class="line">i = <span class="number">3.14</span>;	<span class="comment">// i的值为 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;	<span class="comment">// pi 的值为 3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;	<span class="comment">// 假设 char 占 8 比特， c 的值为 255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;	<span class="comment">// 假设 char 占 8 比特， c2 的值是未定义的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非布尔类型  &gt; 布尔类型  :    初始值为 0 则结果为 false,否则结果为 true  </li>
<li>布尔值  &gt; 非布尔类型  :    初始值为 false 则结果为 0, 初始值为true 则结果为 1</li>
<li>浮点数  &gt;整数类型  :      值仅保留浮点数中小数点之前的部分。</li>
<li>整数 &gt;     浮点类型  :   整数部分不变，小数部分记为0；如果该整数所占的空间超过了浮点类型的容量， 精度可能有损失  </li>
<li>值  &gt; 无符号类型  :    初始值对无符号类型表示数值总数取模后的余数  ;</li>
<li>值  &gt;  带符号类型： 结果未定义；程序可能继续工作、可能崩溃，也可能生成垃圾数据</li>
</ul>
<h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><h5 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h5><ol>
<li><p>整型:</p>
<ul>
<li><p>以 0 开头的整数代表八进制数， </p>
</li>
<li><p>以 0x 或 0X 开头的代表十六进制数  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220703112008479.png" alt="image-20220703112008479"></p>
</li>
</ul>
</li>
<li><p>整型字面值具体的数据类型由它的值和符号决定  </p>
<ol>
<li>默认情况下， 十进制字面值是带符号数,八进制和十六进制字面值既可能是带符号的也可能是无符号的  ;</li>
<li>十进制字面值的类型是int、 long 和 long long 中尺寸最小的那个（例如， 三者当中最小是int), 当然前提<br>是这种类型要能容纳下当前的值  </li>
<li>八进制和十六进制字面值的类型是能容纳其数值的int、 unsignedint、 long、 unsigned long、 longlong 和 unsigned long long<br>中的尺寸最小者  </li>
<li>如果一个字面值连与之关联的最大的数据类型都放不下， 将产生错误  ;</li>
</ol>
</li>
</ol>
<h5 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h5><ol>
<li><p>字符字面值：单引号，单个字符</p>
</li>
<li><p>字符串字面值：双引号，零个或者多个字符</p>
<ol>
<li><p>常量字符构成的数组 ( array )  </p>
</li>
<li><p>编译器在每个字符串的结尾处添加一个空字符（ ‘\0’)  ;</p>
</li>
<li><p>字面值’ A’ 表示的就是单独的字符 A, 而字符串”A”则代表了一个字符的数组， 该数组包含两个字符： 一个是字母 A、 另一个是空字符;</p>
</li>
<li><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705093933509.png" alt="image-20220705093933509"></p>
</li>
<li><p>分行书写字符串：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094045581.png" alt="image-20220705094045581"></p>
</li>
</ol>
</li>
</ol>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><ol>
<li>程序员不可使用的两类字符：<ol>
<li>不可打印字符：退格或其他控制字符，因为他们没有可视的图符</li>
<li>转义序列：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094438754.png" alt="image-20220705094438754"></li>
</ol>
</li>
</ol>
<h5 id="泛化的转义序列"><a href="#泛化的转义序列" class="headerlink" title="泛化的转义序列"></a>泛化的转义序列</h5><ol>
<li><p>\x 后紧跟 1 个或多个十六进制数字 </p>
</li>
<li><p>\后紧跟 1 个、 2 个或 3 个八进制数字  </p>
</li>
<li><p>数字部分表示的是字符对应的数值  </p>
</li>
<li><p>以Latin-1 字符集  实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094653556.png" alt="image-20220705094653556"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>;		<span class="comment">// 输出 Hi MOM!, 转到新一行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;			<span class="comment">//输出 M, 转到新一行</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ol>
<li><p>反斜线\后面跟着的八进制数字超过 3 个， 只有前 3 个数字与\构成转义序列<br>例如， “\1234”表示 2 个字符， 即八进制数 123 对应的字符以及字符 4。  </p>
</li>
<li><p>\x要用到后面跟着的所有数字， 例如， “\x1234” 表示一个 16 位的字符， 该字符由这 4 个十六进制数所对应的比特唯一确定。  </p>
<p>读者不理解的地方：    </p>
<ul>
<li>因为大多数机器的 char 型数据占 8 位， 所以上面这个例子可能会报错。 一般来说， 超过 8 位的十六进制字符都是与表 2.2 中某个前缀作为开头的扩展字符集一起使用的。  </li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h5><p>​    通过添加如表 2.2 中所列的前缀和后缀， 可以改变整型、 浮点型和字符型字面值的默认类型。<br> <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095748545.png" alt="image-20220705095748545"></p>
<p>实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095835204.png" alt="image-20220705095835204"></p>
<h5 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h5><ol>
<li>布尔字面值<ol>
<li>true 和 false 是布尔类型的字面值  </li>
</ol>
</li>
<li>指针字面值<ol>
<li>nullptr 是指针字面值， 2.3.2 节（ 第 47 页） 将有更多关丁•指针和指针字面值的介绍  </li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="C++Primer 第五版 第一章"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-03  <a class="commentCountImg" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/#comment-container"><span class="display-none-class">b6ac0b7125778ed92f89b6ee5b71136d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b6ac0b7125778ed92f89b6ee5b71136d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 分钟  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/">C++Primer 第五版 第一章</a></h1><div class="content"><h1 id="C-Primer-第五版-第一章"><a href="#C-Primer-第五版-第一章" class="headerlink" title="C++Primer 第五版 第一章"></a>C++Primer 第五版 第一章</h1><h2 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章    开始"></a>第1章    开始</h2><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1    编写一个简单的C++程序"></a>1.1    编写一个简单的C++程序</h3><ol>
<li><p>函数组成=返回类型+函数名+形参列表+函数体</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/2022-06-30_124642.png"></p>
</li>
<li><p>注意事项</p>
<ul>
<li><p>main 函数的返回类型必须为 int  ；</p>
</li>
<li><p>int 类型是一种内置类型  ；</p>
</li>
<li><p>内置类型 （ built-in type ), 即语言自身定义的类型；</p>
</li>
<li><p>类型 ：不仅定义了数据元素的内容， 还定义了这类数据上可以进行的运算。  </p>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-1-编译、运行程序"><a href="#1-1-1-编译、运行程序" class="headerlink" title="1.1.1    编译、运行程序"></a>1.1.1    编译、运行程序</h4><ol>
<li><p>如何编译程序  ？</p>
<ul>
<li>依赖于操作系统和编译器  </li>
</ul>
</li>
<li><p>IDE  ：集成开发环境（ Integrated Developed Environment, IDE)  </p>
</li>
<li><p>特定编译器的相关使用细节， 请査阅参考手册或询问经验丰富的同事  </p>
</li>
<li><p>程序源文件命名约定  </p>
<ol>
<li>程序文件通常被称为源文件（ source file)  </li>
<li>源文件的名字以一个后缀为结尾  ，后缀是由一个句点后接一个或多个字符组成的  ；最常见的包括.CC、.cxx,.cPP、.cP 及.C </li>
</ol>
</li>
<li><p> 从命令行运行编译器  </p>
</li>
<li><p>源文件 progl.cc  </p>
</li>
<li><p>如下命令来编译  </p>
<ol>
<li><p>$ CC progl.cc  </p>
</li>
<li><p>CC 是编译器程序的名字， $是系统提示符。 编译器生成一个可执行文件。  </p>
</li>
<li><p>Windows  ：progl.exe</p>
<ol>
<li>progl.exe</li>
<li>$ progl  </li>
</ol>
</li>
<li><p>UNIX  :a.out</p>
<ol>
<li>a.out</li>
<li>$ a.out</li>
</ol>
</li>
<li><p>echo 命令获得其返回值  </p>
<ol>
<li>UNIX  : $ echo $?  </li>
<li>Windows  : $ echo %ERRORLKVEL%  </li>
</ol>
</li>
<li><p>特殊情况：须显式指出文件的位置  </p>
<ol>
<li>Windows  ：$ .\progl</li>
<li>Unix: $ ./a.out</li>
</ol>
</li>
<li><p>运行 GNU或微软编译器  </p>
<ol>
<li>Page 30</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2    初识输入输出"></a>1.2    初识输入输出</h3><ol>
<li>C++语言并未定义任何输入输出 (10 ) 语句  ;包含了一个全面的标准库( standard library) 来提供 10 机制（ 以及很多其他设施)</li>
<li>iostream 库  <ol>
<li>istream  输入流  </li>
<li>ostream  输出流  </li>
<li>流  <ol>
<li>一个流就是一个字符序列  </li>
<li>术语“ 流”（ stream)   :随着时间的推移， 字符是顺序生成或消耗的  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h4><ol>
<li><p>定义了 4 个 IO 对象 </p>
<ol>
<li> cin  </li>
<li>istream 类型的对象  </li>
<li>标准输入（ standard input)  </li>
<li>cout    <ol>
<li>ostream 类型的对象  </li>
<li>标准输出（ standard output)  </li>
</ol>
</li>
<li>cerr  <ol>
<li>输出警告和错误消息  </li>
<li>标准错误 （ standard error)  </li>
</ol>
</li>
<li>clog  <ol>
<li>输出程序运行时的一般性信息  </li>
</ol>
</li>
</ol>
</li>
<li><p>一个使用 IO 库的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:</span></span><br><span class="line"><span class="string">	int vl = 0, v2 = 0;</span></span><br><span class="line"><span class="string">	std::cin » vl » v2;</span></span><br><span class="line"><span class="string">	std::cout &lt;&lt; &quot;</span>The sum of <span class="string">&quot; &lt;&lt; vl &lt;&lt; &quot;</span> <span class="keyword">and</span> <span class="string">&quot; &lt;&lt; v2&lt;&lt; &quot;</span> is <span class="string">&quot; &lt;&lt; vl + v2 &lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">	« std::endl;</span></span><br><span class="line"><span class="string">	return 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>头文件（ header)  <ol>
<li>指令和头文件的名字必须写在同一行中  </li>
<li>放在源文件的开始位置  </li>
<li>必须出现在所有函数之外 </li>
</ol>
</li>
</ol>
</li>
<li><p> 向流写入数据  </p>
</li>
<li><p>表达式（ expression)  : 一个或多个运算对象和（ 通常是） 一个运算符组成  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout « <span class="string">&quot;Enter two numbers: &lt;&lt; std::endl;  </span></span><br></pre></td></tr></table></figure></li>
<li><p>输出运算符（&lt;&lt;)  </p>
<ol>
<li><p>&lt;&lt;运算符接受两个运算对象： 左侧的运算对象必须是一个 ostream 对象， 右侧的运算对<br>象是要打印的值  </p>
</li>
<li><p>此运算符返回其左侧的运算对象  </p>
</li>
<li><p>将给定的值写到给定的 ostream 对象中  </p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(std::cout « <span class="string">&quot;Enter two numbers:&quot;</span> ) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span>；</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串字面值常量  “Enter two numbers:”</p>
<ol>
<li>双引号包围的字符序列  ，双引号之间的文本被打印到标准输出  </li>
</ol>
</li>
<li><p>endl  </p>
<ol>
<li>操纵符（ manipulator);  特殊值  </li>
<li>效果是结束当前行， 并将与设备关联的缓冲区 （ buffer) 中的内容刷到设备中  </li>
</ol>
</li>
</ol>
</li>
<li><p>使用标准库中的名字  </p>
<ol>
<li>std::cout 和 std::endl  </li>
<li>std 的命名空间(namespace)   </li>
<li>避免不经意的名字定义冲突  ,以及使用库中相同名字导致的冲突  </li>
<li>作用域运算符 (::)   </li>
</ol>
</li>
<li><p>从流读取数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl &gt;&gt; v2;  </span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入运算符（ &gt;&gt;)</p>
<ol>
<li><p>从给定的 istream 读入数据， 并存入给定对象中  </p>
</li>
<li><p>返回其左侧运算对象作为其计算结果</p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( std::cin &gt;&gt; vl ) &gt;&gt; v2;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl;</span><br><span class="line">std::cin &gt;&gt; v2;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3    注释简介"></a>1.3    注释简介</h3><p>C++中注释的种类  </p>
<ul>
<li>C++中有两种注释： <ul>
<li>单行注释:以双斜线 ( / / ) 开始， 以换行符结束  ;当前行双斜线右侧的所有内容都会被编译器忽略  </li>
</ul>
</li>
<li>界定符对注释  <ul>
<li>继承自 C 语言的两个界定符（ /*<em>和</em> */ )  </li>
<li>落在/<strong>和</strong> <em>/之间的所有内容都当作注释 ; 可以包含除</em> /外的任意内容， 包括换行符  </li>
<li>注释界定符不能嵌套  </li>
</ul>
</li>
</ul>
<h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4    控制流"></a>1.4    控制流</h3><h4 id="1-4-1-while语句"><a href="#1-4-1-while语句" class="headerlink" title="1.4.1    while语句"></a>1.4.1    while语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630141324624.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &#123;condition)</span><br><span class="line">statement  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行过程是交替地检测 condition 条件和执行关联的语句statement  ，直到condition为假时停止  </p>
</li>
<li><p>小于等于运算符（&lt;=)</p>
</li>
<li><p>复合赋值运算符 （ +=)  </p>
</li>
<li><p>前缀递增运算符 （ ++ )  </p>
</li>
</ul>
<h4 id="1-4-2-for语句"><a href="#1-4-2-for语句" class="headerlink" title="1.4.2    for语句"></a>1.4.2    for语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> sum</span><br><span class="line">    / / 从 <span class="number">1</span>加到 <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">      sum += val; <span class="comment">// 等 价 于 + val  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	sum += sum = sum</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3     读取数量不定的输入数据"></a>1.4.3     读取数量不定的输入数据</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630142805148.png"></p>
<ul>
<li>使用一个 istream 对象作为条件时 ,其效果是检测流的状态;</li>
<li>流是有效的， 即流未遇到错误， 那么检测成功    </li>
<li>遇到文件结束符 ( end-of-file), 或遇到一个无效输入时（ 例如读入的值不是一个整数）， istream 对象的状态会变为无效  </li>
<li>如何指出文件结束  <ul>
<li>Windows 系统  <ul>
<li>敲 Ctrl+Z ( 按住 Ctrl 键的同时按 Z 键 ），然后按 Enter 或 Return 键  </li>
</ul>
</li>
<li>UNIX 系统  /MacOSX 系统  <ul>
<li>Ctrl+D  </li>
</ul>
</li>
</ul>
</li>
<li>再 探 编 译  <ul>
<li>语法错误（ syntax error )  </li>
<li>类型错误（ type error )  </li>
<li>声明错误（ declaration error )  </li>
<li>按照错误信息报告的顺序来逐个修正错误， 是一种好习惯  。因为单个错误常常会具有传递效应 ， 导致编译器在其后报告比实际数量多得多的错误信息。 另一个好习惯是在每修正一个错误后就立即重新编译代码， 或者最多是修正了一小部分明显的错误后就重新编译 ： 这就是所谓的 “编辑-编译-调试 ”（ edit-compile-debug ) 周期。  </li>
</ul>
</li>
</ul>
<h4 id="1-4-4-if语句"><a href="#1-4-4-if语句" class="headerlink" title="1.4.4    if语句"></a>1.4.4    if语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630143559254.png"></p>
<ul>
<li><p>相等运算符（ ==) </p>
<ul>
<li>C++用=进行赋值， 用==作为相等运算符；两个运算符都可以出现在条件中 。一个常见的错误是想在条件中使用== ( 相等判断 ）， 却误用了= 。</li>
</ul>
</li>
</ul>
<h3 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5    类简介"></a>1.5    类简介</h3><ul>
<li>类机制是 C++最重要的特性之一  </li>
<li>一个类定义了一个类型， 以及与其关联的一组操作  </li>
<li>通过定义一个类 (class) 来定义自己的数据结构 </li>
<li>使用头文件来访问为自己的应用程序所定义的类  <ul>
<li> 通常使用.h 作为头文件的后缀  </li>
<li>一些程序员习惯.H、 .hpp 或.hxx  </li>
<li>标准库头文件通常不带后缀  </li>
</ul>
</li>
<li>类的作者决定了类类型对象上可以使用的所有操作  </li>
</ul>
<h4 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1    Sales_item类"></a>1.5.1    Sales_item类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item item;</span><br></pre></td></tr></table></figure>

<p>表达 item 是一个 Sales_item 类型的对象。 我们通常将“ 一个 Sales_item 类型的对象” 简单说成“ 一个 Sales_item 对象”， 或更简单的“ 一个 Sales_item”。</p>
<h4 id="读写Sales-item"><a href="#读写Sales-item" class="headerlink" title="读写Sales_item"></a>读写Sales_item</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630150431130.png"></p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li><p>来自标准库的头文件 ：应该用尖括号（&lt; &gt;) 包围头文件名  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>不属于标准库的头文件  ：用双引号（ “ “） 包围  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_item.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Sales-item-对象的加法"><a href="#Sales-item-对象的加法" class="headerlink" title="Sales_item 对象的加法"></a>Sales_item 对象的加法</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630151614240.png"></p>
<p>对于 Sales_item 对象， 我们用了一个全新的“ 和” 的概念 : 两个 Sales_item 对象的成员对应相加的结果。</p>
<h4 id="使用文件取定向"><a href="#使用文件取定向" class="headerlink" title="使用文件取定向"></a>使用文件取定向</h4><p>​        当你测试程序时， 反复从键盘敲入这些销售记录作为程序的输入， 是非常乏味的 。大多数操作系统支持文件重定向， 这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addlterns &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>假定$是操作系统提示符， 我们的加法程序已经编译为名为 addltems.exe 的可执行文件（ 在 UNIX 中addltems ). 则上述命令会从一个名为 infile 的文件读取销售记录， 并将输出结果写入到一个名为 outfile 的文件中， 两个文件都位于当前目录中。  </p>
<h4 id="1-5-2-初识成员函数"><a href="#1-5-2-初识成员函数" class="headerlink" title="1.5.2    初识成员函数"></a>1.5.2    初识成员函数</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152050811.png"></p>
<ol>
<li>什么是成员函数？  <ol>
<li>成员函数是定义为类的一部分的函数， 有时也被称为方法（ method)。</li>
<li>通常以一个类对象的名义来调用成员函数：iteml.isbn ( )      </li>
<li>点运算符（.）  <ol>
<li>只能用于类类型的对象。   </li>
<li>左侧运算对象必须是一个类类型的对象， 右侧运算对象必须是该类型<br>的一个成员名， 运算结果为右侧运算对象指定的成员  </li>
</ol>
</li>
<li>调用运算符（（ ） ）  <ol>
<li>调用运算符是一对圆括号， 里面放置实参( argument) 列表（ 可能为空）  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-6-书店程序"><a href="#1-6-书店程序" class="headerlink" title="1.6    书店程序"></a>1.6    书店程序</h3><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152712392.png"></p>
<h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><ol>
<li>参数（ 实参， argument ) 向函数传递的值。  </li>
<li>赋值 ( assignment) 抹去一个对象的当前值， 用一个新值取代之。</li>
<li>程序块（ block ) 零条或多条语句的序列，用花括号包围。</li>
<li>缓冲区（ buffer ) —个存储区域， 用于保存数据。 IO 设施通常将输入 （ 或输出） 数据保存在一个缓冲区中， 读写缓冲区的动作与程序中的动作是无关的。 我们可以显式地刷新输出缓冲， 以便强制将缓冲区中的<br>数据写入输出设备。 默认情况下， 读 cin会刷新 cout； 程序非正常终止时也会刷新couto  </li>
<li>内置类型（ built-in type ) 由语言定义的类型， 如 int.</li>
<li>Cerr 一 个 ostream 对象， 关联到标准错误， 通常写入到与标准输出相同的设备。 默认情况下， 写到<br>Cerr的数据是不缓冲的，Cerr通常用于输出错误倍息或其他不屑于程序正常逻辑的输出内容  </li>
<li>字 符 串 字 面 值 常 量 （ character string literal) 术语 string literal 的另一种叫法  </li>
<li>cin —个 istream 对象， 用来从标准输入读取数据。  </li>
<li>类 (class) 一种用于定义自己的数据结构及其相关操作的机制。 类是 C++中最基木的特性之 一。 标准库类型中， 如 istream和ostream  都是类  </li>
<li>类 类 型 （ class type ) 类定义的类型。 类名即为类型名  </li>
<li>clog 一 个 ostream 对象， 关联到标准错误。 默认情况下， 写到 clog 的数据是被缓冲的。 clog 通常用于报告程序的执行信息. 存入一个日志文件中  </li>
<li>注 释（ comment) 被编译器忽略的程序文本。 C++有两种类羽的注释： 单行注释和界定符对注释。 单行注释以/ / 开始， 从 / /到行尾的所有内容都是注释。 界定符对注释以/ * 汗始， 其后的所有内容都萣注释,直至遇到* / 为止。    </li>
<li>条 件 ( condition) 求值结果为真或假的表达式。 通常用值 0 表示假， 用非零表示真。  </li>
<li>cout  一个 ostream 对象， 用于将数据写入标准输出。 通常用于程序的正常输出内容。  </li>
<li>花括号 ( curly brace ) 花括号用于划定程序块边界。 左花括号 ( { ) 为程序块开始，右花括号（ } ) 为结朿。  </li>
<li>数据结构 (data structure) 数据及其上所允许的操作的 一种逻辑组合。  </li>
<li>编辑-编译-调试 （ edit-compile-debug ) 使程序能正确执行的开发过程  </li>
<li>文件结束符 （ end-of-file) 系统特定的标识， 指出文件中无更多数据了。</li>
<li>表达式 （ expression ) 最小的计算单元。 一个表达式包含 一 个或多个运算对象， 通常还含 一个或多个运算符。 表达式求值会产生一个结果。 例如， 假设i和 j 是 int对象， 则i+j 是一个表达式, 它产生两个  int 值的和。  </li>
<li>……  </li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/read.jpg" alt="《社会性动物》第一部分：检视阅读笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-05-03  <a class="commentCountImg" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/#comment-container"><span class="display-none-class">230e6212d8810ed62f9830005d23aeaa</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="230e6212d8810ed62f9830005d23aeaa">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>10.9 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/">《社会性动物》第一部分：检视阅读笔记</a></h1><div class="content"><h1 id="社会性动物"><a href="#社会性动物" class="headerlink" title="社会性动物"></a>社会性动物</h1><h2 id="阅读Tips"><a href="#阅读Tips" class="headerlink" title="阅读Tips"></a>阅读Tips</h2><h3 id="阅读步骤"><a href="#阅读步骤" class="headerlink" title="阅读步骤"></a>阅读步骤</h3><ul>
<li><p>检视阅读</p>
<ul>
<li><p>检视阅读第一层</p>
<ul>
<li>子主题 1</li>
</ul>
</li>
<li><p>检视阅读第二层</p>
</li>
<li><p>检视阅读的问题</p>
<ul>
<li>这本书在谈什么</li>
<li>这本书的架构如何</li>
<li>这本书分为哪些部分</li>
<li>这是什么类型的书籍</li>
</ul>
</li>
<li><p>检视阅读的目的</p>
<ul>
<li>有限的时间内，最好最完整的阅读（就是系统的略读）</li>
</ul>
</li>
</ul>
</li>
<li><p>分析阅读</p>
<ul>
<li><p>阅读原则：无限时间内最完整最好的全盘系统化的阅读</p>
</li>
<li><p>分析阅读步骤</p>
<ul>
<li>1、书籍分类</li>
<li>2、简要概括书本内容</li>
<li>3、列出重要篇章，看他们</li>
<li>4、找出作者想问的问题或者想要解决的问题</li>
<li>5、找出共通的词义</li>
<li>6、从重要句子中解析作者想要表达的主旨</li>
<li>7、找出作者的 论述以及前因后果，以明白作者的主张；</li>
<li>8、明确作者解决了哪些问题；哪些是未解决的；在未解决的问题中，哪些是作者认为无法解决的。</li>
<li>10、对一本书进行整体评价；但是要注意评价的智慧礼节和批评观点的特别标准。</li>
</ul>
</li>
</ul>
</li>
<li><p>主题阅读</p>
</li>
</ul>
<h3 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h3><ul>
<li><p>书本笔记</p>
<ul>
<li><p>笔记时间</p>
<ul>
<li>检视阅读第一层</li>
</ul>
</li>
<li><p>笔记规则</p>
<ul>
<li><p>在书上做笔记</p>
<ul>
<li><p>好处</p>
<ul>
<li>1.保持十分清醒，集中注意力</li>
<li>2.主动阅读也是一种思考，既然是思考，我们就应该可以表达出来，不管是用写的还是说的。</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>1.画底线</p>
<ul>
<li>主要的重点、重要切有力的句子</li>
</ul>
</li>
<li><p>2.底线栏外再画一条线</p>
<ul>
<li>着重强调1的重要性，并且避免底线过长。</li>
</ul>
</li>
<li><p>3.空白处画星号或其他符号</p>
<ul>
<li>标记书中少数十分重要的声明或者段落；还可以折角加以标记。慎用！</li>
</ul>
</li>
<li><p>4.空白处编号</p>
<ul>
<li>作者的某个重要论点发展出来的一系列重要论述。</li>
</ul>
</li>
<li><p>5.空白处记下其他的页码</p>
<ul>
<li>标记作者在书中其他位置相同相似的论点甚至是相反的论点；这样可以让全书散落的想法统一起来。CF(参照或者比较)</li>
</ul>
</li>
<li><p>6.关键字或句子圈出来</p>
<ul>
<li>作用同1</li>
</ul>
</li>
<li><p>7.书页中的空白处做笔记</p>
<ul>
<li>1.记录读者的一些问题或者答案</li>
<li>2.将复杂的论点简化说明</li>
<li>3.记录全书主要论点的发展顺序</li>
<li>4.书中最后一页作为读者索引,依序记录作者主要观点</li>
</ul>
</li>
<li><p>8.在最后一页写下读者索引,在第一页写下本书大纲,写出本书整体架构,列出基本大纲和前后篇章次序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结构笔记</p>
<ul>
<li><p>检视阅读的三个问题</p>
<ul>
<li>这是一本什么样的书</li>
<li>整本书在谈什么</li>
<li>作者借着什么样的架构,来发展他的观点或者陈述他对这个主题的理解</li>
</ul>
</li>
<li><p>笔记的重点是全书的结构,而不是内容,至少不是细节</p>
</li>
</ul>
</li>
<li><p>概念笔记</p>
<ul>
<li><p>什么是概念笔记</p>
<ul>
<li>概念既是作者的观点,在我们进行检视阅读的时候,读者也许可以掌握作者所要表达的一些观点。但是对这些观点的准确性和意义，我们需要在分析阅读中去寻找答案。当读者阅读的深度和广度增加之后，自然也会出现自己的观点。</li>
</ul>
</li>
<li><p>另一种概念笔记</p>
<ul>
<li>在我们进行主题阅读的时候，我们会阅读主题相关的多本书籍，这个时候的笔记应该也是概念笔记。只是这个时候我们在书中空白页处记下 的页码不再是本书的，也有些是其他书中的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="阅读反思"><a href="#阅读反思" class="headerlink" title="阅读反思"></a>阅读反思</h3><p>（主动阅读者该做的一些工作）</p>
<ul>
<li>1、整体来说，这本书在谈什么？</li>
<li>2、作者细说了什么？又是怎么说的？</li>
<li>3、作者说的有道理吗？</li>
<li>4、这本书和我有什么关系</li>
</ul>
<h2 id="阅读笔记-1"><a href="#阅读笔记-1" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h3><ul>
<li><p>结构笔记</p>
<ul>
<li><p>包含内容：读者大纲、名词解释、好句摘录</p>
</li>
<li><p>书本大纲</p>
<ul>
<li><p>第一章：什么是社会心理学</p>
<ul>
<li><p>第一部分：定义</p>
<ul>
<li>社会心理学定义</li>
</ul>
</li>
<li><p>关于社会影响的几个问题</p>
<ul>
<li>影响的定义</li>
<li>如何影响人们</li>
<li>影响的隐含意义</li>
<li>影响的持续性和变量因素</li>
<li>影响的强弱和变量因素</li>
</ul>
</li>
<li><p>特定环境影响人类行为的论述</p>
</li>
</ul>
</li>
<li><p>第二章：从众</p>
<ul>
<li><p>第一部分;定义</p>
<ul>
<li>从众的定义</li>
<li>群体压力的定义</li>
<li>群体压力的几个问题</li>
</ul>
</li>
<li><p>第二部分：增强和减弱从众的因素</p>
<ul>
<li>一致性</li>
<li>表态</li>
<li>责任</li>
<li>个体和文化</li>
<li>施加压力的群体</li>
</ul>
</li>
<li><p>第三部分：从众的原因：奖惩和信息</p>
<ul>
<li>浪费水资源和乱丢垃圾</li>
<li>社会影响和情绪</li>
<li>社会影响：生和死</li>
</ul>
</li>
<li><p>第四部分:对社会影响的态度</p>
<ul>
<li><p>依从</p>
<ul>
<li>服从和依从的关系</li>
<li>米尔格拉姆实验中的不服从</li>
</ul>
</li>
<li><p>认同</p>
</li>
<li><p>内化</p>
</li>
</ul>
</li>
<li><p>第四部分：不介入的旁观者是从众者</p>
</li>
<li><p>第五部分：从众实验中的伦理问题</p>
</li>
</ul>
</li>
<li><p>第三章：大众传播、宣传和说服</p>
<ul>
<li><p>第一部分：</p>
<ul>
<li>说服的努力</li>
<li>媒体感染</li>
<li>政治家就是演员</li>
<li>借助感染力的效果</li>
<li>教育还是宣传？</li>
</ul>
</li>
<li><p>第二部分：说服的两种路径</p>
<ul>
<li>中心路径说服</li>
<li>边缘路径说服</li>
</ul>
</li>
<li><p>第三部分：宣传的来源</p>
<ul>
<li>可信性</li>
<li>可信性的增加</li>
<li>吸引力</li>
</ul>
</li>
<li><p>第四部分：宣传的性质</p>
<ul>
<li>借助理性</li>
<li>借助情感</li>
<li>恐怖和恐怖主义的威胁</li>
<li>一致性的统计证据和个别例证</li>
<li>单方面例证和两方面例证</li>
<li>观点呈现的次序</li>
<li>差异的大小</li>
</ul>
</li>
<li><p>第五部分:接受者的特征</p>
<ul>
<li>自尊</li>
<li>接受者的前期经验</li>
</ul>
</li>
<li><p>第六部分：这些原则的作用方式</p>
</li>
</ul>
</li>
<li><p>第四章：社会认知</p>
<ul>
<li><p>第一部分:我们如何理解世界</p>
</li>
<li><p>第二部分：背景对社会判断的影响</p>
<ul>
<li>参照点和对比效应</li>
<li>启动和易接受性的形成</li>
<li>为决策设置框架</li>
<li>信息的先后次序</li>
<li>首因效应和印象形成</li>
<li>信息量</li>
</ul>
</li>
<li><p>第三部分：便捷式判断</p>
<ul>
<li>代表性便捷式判断</li>
<li>易得性便捷式判断</li>
<li>态度便捷式判断</li>
<li>人们何时会使用便捷式判断？</li>
</ul>
</li>
<li><p>第四部分：分类和社会定型</p>
<ul>
<li>定型化认识和预期</li>
<li>发现不存在的关系：虚假关联</li>
<li>内群体-外群体效应</li>
</ul>
</li>
<li><p>第四部分：重构性记忆</p>
</li>
<li><p>第五部分：自传性记忆</p>
<ul>
<li>记忆恢复现象</li>
</ul>
</li>
<li><p>第六部分：人类认知的保守性</p>
</li>
<li><p>第七部分：态度和信念如何指导行动</p>
<ul>
<li>人们心目中的态度和行为关系</li>
<li>什么时候态度可以预测行为</li>
<li>依据感知觉行动</li>
</ul>
</li>
<li><p>第八部分：社会解释中可能出现的三种偏差</p>
<ul>
<li><p>基本归因错误</p>
</li>
<li><p>行动者-观察者偏差</p>
</li>
<li><p>自我偏差</p>
<ul>
<li>自我偏差的价值</li>
</ul>
</li>
<li><p>自我对社会认知产生的影响</p>
<ul>
<li>自我中心思维</li>
<li>自利偏差</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第五章：自我辩护</p>
<ul>
<li><p>第一部分：自我辩护的定义和适用范围</p>
</li>
<li><p>第二部分：减少失调和理性行为</p>
</li>
<li><p>第三部分：决策造成的失调</p>
<ul>
<li>决策后果的一些历史例证</li>
</ul>
</li>
<li><p>第四部分：不可改变的重要性</p>
<ul>
<li>有关不道德行为的决策</li>
</ul>
</li>
<li><p>第五部分：不充分理由心理</p>
<ul>
<li>外部理由的构成</li>
<li>不充分理由</li>
<li>失调和自我概念</li>
<li>不充分奖赏在教育中的运用</li>
<li>不充分惩罚</li>
</ul>
</li>
<li><p>第六部分：为努力进行辩护</p>
</li>
<li><p>第七部分：为残忍进行辩护</p>
</li>
<li><p>第八部分：对待不可避免事件的心理</p>
</li>
<li><p>第九部分：自尊的重要作用</p>
</li>
<li><p>第十部分：是不安？还是自我知觉</p>
</li>
<li><p>第十一部分：失调对生理和动机的影响</p>
</li>
<li><p>第十二部分：失调理论的实际运用</p>
<ul>
<li>理解对灾难的反应</li>
<li>通过减少失调来减肥</li>
<li>失调与艾滋病预防</li>
<li>失调和水资源保护</li>
<li>对宗教领袖权威的解释</li>
<li>本拉登是在利用失调理论吗？</li>
</ul>
</li>
<li><p>第十三部分：减少失调和文化</p>
</li>
<li><p>第十四部分：“人”不能只靠和谐生活</p>
</li>
</ul>
</li>
<li><p>第六章：人类的攻击性</p>
<ul>
<li><p>第一部分：对攻击性的定义</p>
</li>
<li><p>第二部分：攻击性是本能的吗？</p>
</li>
<li><p>第三部分：攻击性是否有益</p>
<ul>
<li>适者生存</li>
<li>宣泄能发挥作用吗？</li>
<li>报复是过激行为</li>
</ul>
</li>
<li><p>第三部分：攻击的原因</p>
<ul>
<li>神经学和化学方面的原因</li>
<li>睾丸素</li>
<li>酒精类饮料</li>
<li>痛苦与不适</li>
<li>挫折与攻击</li>
<li>拒绝、排斥和奚落</li>
<li>社会学习和攻击性</li>
<li>社会学习、暴力和大众传媒</li>
<li>电视暴力的麻木效应</li>
<li>媒体暴力为什么会影响观众的攻击性</li>
<li>媒体、色情描写以及针对女性的暴力</li>
<li>暴力有助于推销吗？</li>
<li>用攻击性去吸引公众的注意</li>
</ul>
</li>
<li><p>第四部分：如何减少暴力</p>
<ul>
<li>纯粹的励志</li>
<li>惩罚</li>
<li>对攻击性榜样的惩罚</li>
<li>对替代性行为的奖赏</li>
<li>非攻击性榜样的作用</li>
<li>建立对他人的移情</li>
</ul>
</li>
</ul>
</li>
<li><p>第七章：偏见</p>
<ul>
<li><p>第一部分：定型和偏见</p>
<ul>
<li>定型威胁</li>
</ul>
</li>
<li><p>第二部分：定型和归因</p>
<ul>
<li>性别定型</li>
</ul>
</li>
<li><p>第三部分：归咎于受害者</p>
</li>
<li><p>第四部分：偏见和科学</p>
</li>
<li><p>第五部分：偏见的一些微妙影响</p>
<ul>
<li>不易察觉的性别歧视和性别角色社会化</li>
</ul>
</li>
<li><p>第六部分：偏见和媒体</p>
</li>
<li><p>第七部分：偏见的原因</p>
<ul>
<li>经济和政治竞争</li>
<li>替代性攻击：替罪羊理论</li>
<li>自我形象和地位的维持</li>
<li>带有偏见的人格</li>
<li>从众引起的偏见</li>
</ul>
</li>
<li><p>第八部分：国家干预可以改变民间偏见</p>
<ul>
<li>地位平等的接触的影响</li>
<li>取消种族隔离的其他影响</li>
<li>其他条件不同的情况</li>
</ul>
</li>
<li><p>第九部分：相互依赖：一种可能的解决办法</p>
<ul>
<li>潜在机制</li>
<li>来自差异的挑战</li>
</ul>
</li>
</ul>
</li>
<li><p>第八章：喜欢、爱和人际敏感性</p>
<ul>
<li><p>第一部分：赞扬和帮助他人的效果</p>
</li>
<li><p>第二部分：个人特征</p>
<ul>
<li>能力</li>
<li>外表吸引力</li>
</ul>
</li>
<li><p>第三部分：相似和吸引</p>
</li>
<li><p>第四部分：喜欢、被人喜欢和自尊</p>
</li>
<li><p>第五部分：尊重的获得和丧失</p>
<ul>
<li>对共有关系的需求</li>
</ul>
</li>
<li><p>第六部分：爱和亲密</p>
<ul>
<li>人们对爱的认识</li>
<li>对爱的界定</li>
<li>得失理论：亲密关系的含义</li>
</ul>
</li>
<li><p>第七部分：亲密、真实性和交流</p>
</li>
<li><p>第八部分：有效交流的特征</p>
<ul>
<li>开门见山 的重要性</li>
<li>情感与看法</li>
<li>交流与完美之爱</li>
</ul>
</li>
</ul>
</li>
<li><p>第九章：作为一门科学的社会心理学</p>
<ul>
<li><p>第一部分：什么是科学的方法</p>
<ul>
<li>科学和艺术的关系</li>
</ul>
</li>
<li><p>第二部分:从推测到实验</p>
<ul>
<li>实验设计</li>
</ul>
</li>
<li><p>第三部分:随机分配的重要性</p>
</li>
<li><p>第四部分：社会心理学实验的挑战性</p>
<ul>
<li>控制和影响</li>
<li>现实性</li>
<li>隐瞒</li>
</ul>
</li>
<li><p>第五部分：伦理问题</p>
<ul>
<li>实验人员对被实验者的责任</li>
</ul>
</li>
<li><p>第六部分：假如作者的发现被误用怎么办？</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>名词解释</p>
<ul>
<li><p>行动者-观察者偏差</p>
<ul>
<li>将他人的行为归因于行动者稳定的人格素质，而自己的行为解释为情境性因素的倾向</li>
</ul>
</li>
<li><p>攻击行为</p>
<ul>
<li>旨在引起身体痛苦或者心理痛苦的有意行为</li>
</ul>
</li>
<li><p>攻击性刺激</p>
<ul>
<li>与攻击反应相关的刺激物品（例如：手枪），仅仅因为他们的出现便增加了攻击的可能性</li>
</ul>
</li>
<li><p>利他行为</p>
<ul>
<li>对他人有益而不会给施助者带来利益的行为，这种行为往往需要帮助者付出一定的代价</li>
</ul>
</li>
<li><p>杏仁核</p>
<ul>
<li>大脑中央区一个和攻击性行为有关的区域</li>
</ul>
</li>
<li><p>态度</p>
<ul>
<li>对人、事务和观点持有的持久的（正面或者负面）的评价；态度包含情感评价和认知评价</li>
</ul>
</li>
<li><p>态度的可通达性</p>
<ul>
<li>某个事物同我们对它的评价之间的联系强度；可通达性可以通过人们报告他们对特定事物、问题感受如何的速度来加以测量</li>
</ul>
</li>
<li><p>态度便捷式判断</p>
<ul>
<li>决策时采取的一种捷径；将认知对象归为有利的一类或者不利的一类。</li>
</ul>
</li>
<li><p>归因理论</p>
<ul>
<li>对人们解释自己或者他人行为原因的方式所做的描述</li>
</ul>
</li>
<li><p>真实性</p>
<ul>
<li>一个人的行为和交往与他自己的感受相一致</li>
</ul>
</li>
<li><p>易得性便捷式判断</p>
<ul>
<li>人们在进行判断时所借助的心里规则依据是轻易想到的事物</li>
</ul>
</li>
<li><p>善意的性别歧视</p>
<ul>
<li>看起来对女性持一种正向的（甚至正直的）态度，但从本质上看却有定型化特征；例如，认为女性必须受到保护。</li>
</ul>
</li>
<li><p>归咎于受害者</p>
<ul>
<li><p>将所受到的伤害归咎于受害者本人（进行素质归因）的倾向，导致这种倾向的动机一般是希望看到世界是公平的</p>
<ul>
<li>这个名词解释我觉得很不理解：这种倾向和动机之间的逻辑关系是如何成立的？</li>
</ul>
</li>
</ul>
</li>
<li><p>旁观者效应</p>
<ul>
<li><p>目睹某个紧急性事件的旁观者人数越多，他们中间某个人出手救助的可能性越小</p>
<ul>
<li>这是否可以理解为从众行为？个体是如何受到旁观者群体影响的？如果不从众，需要承担什么责任？</li>
</ul>
</li>
</ul>
</li>
<li><p>宣泄</p>
<ul>
<li>指的是这样一种看法：“排放系统”（通过实施攻击行为、目睹他人实施攻击行为或者幻想性的攻击行为）释放聚集起来的攻击性能量，并因此减少出现进一步攻击行为的可能性。</li>
</ul>
</li>
<li><p>说服的中心路径</p>
<ul>
<li>在这种情况下，人们会对说服信息进行详细的思考，仔细聆听其中的观点并进行深入地思考；只有在人们既具备一定的信息接受能力又具有相应动机的时候，这种情况出现</li>
</ul>
</li>
<li><p>认知失调</p>
<ul>
<li><p>一种紧张冲突的状态。无论何时只要某个人同时拥有心理上不一致的两种认知（态度、想法、信念、意见），就会出现这种状态</p>
<ul>
<li>当认知失调出现后，言行会受到什么影响？</li>
<li>什么是认知?认知包括态度、想法、信念和意见</li>
</ul>
</li>
</ul>
</li>
<li><p>认知吝啬者</p>
<ul>
<li><p>人们在进行决策的时候，为了尽力保存认知能量，总是想法采用心理捷径</p>
<ul>
<li>什么是认知能量？人为什么想要保存认知能量？</li>
</ul>
</li>
</ul>
</li>
<li><p>共有关系</p>
<ul>
<li>在这种人际关系中，人们首先关系的是对他人的需要进行响应。</li>
</ul>
</li>
<li><p>伴侣之爱</p>
<ul>
<li>人们在深深地关心着另外一个人时所体验到的亲密和情感，但不一定在这个人出现的时候体验到激情</li>
</ul>
</li>
<li><p>依从</p>
<ul>
<li>个体因希望获得奖励或者害怕受到惩罚而对社会影响做出的反应</li>
</ul>
</li>
<li><p>证实偏差</p>
<ul>
<li><p>指的是这样一种倾向：人们一旦持有了某种看法，只要有可能，他们便会待有偏见的看待随后出现的事件，以证实自己的看法</p>
<ul>
<li>这个概念是不是逆向证明了第一印象的重要性？</li>
</ul>
</li>
</ul>
</li>
<li><p>从众</p>
<ul>
<li>由于受到来自他人的真实的或者想象的影响，导致一个人的行为发生了变化。</li>
</ul>
</li>
<li><p>完美之爱</p>
<ul>
<li><p>根据滕伯格的观点，这是激情、亲密和承诺三种成分的混合。</p>
<ul>
<li>滕伯格的什么观点？</li>
</ul>
</li>
</ul>
</li>
<li><p>对比效应</p>
<ul>
<li>某一认知对象看起来比它自身好或者差，取决于同它进行比较的认知对象的质量</li>
</ul>
</li>
<li><p>一致性判断</p>
<ul>
<li>将某个人的行为归因于此人类似的属性或者特质的倾向</li>
</ul>
</li>
<li><p>态度相反的倡议</p>
<ul>
<li>当某个人陈述某种与自己的个人信念或态度 相反的意见或态度时出现的认知失调过程。</li>
</ul>
</li>
<li><p>掩饰性情节</p>
<ul>
<li>设计情境或实验来增加实验的现实性，在这种情境中被试可以自然地行动，他们的行动不会因为知道自己的哪些行为正在被研究而受到妨碍。</li>
</ul>
</li>
<li><p>来源的可信性</p>
<ul>
<li>如果信息来源具有专家身份而且值得相信，她（他）很可能对接收者的信念产生影响</li>
</ul>
</li>
<li><p>心理纾解</p>
<ul>
<li>在一项实验结束时，研究者就研究目的以及所发生的事情对被试者进行解释的程序</li>
</ul>
</li>
<li><p>诱饵</p>
<ul>
<li>消费者在决策的过程中，会遇到的一种明显差于其他可能选择的选择，它出现旨在通过对比让其他可能选择中的一种看上去更好</li>
</ul>
</li>
<li><p>非人化</p>
<ul>
<li>将受害者视为非人的过程，通过这一过程来降低自身攻击行为的限制，从而更容易更有可能进行进一步的攻击行为。</li>
</ul>
</li>
<li><p>去个性化</p>
<ul>
<li>一种自我意识弱化的状态（往往是因为匿名引起的），其结果会导致人们对社会评价的关注度的降低，以及对那些被禁止行为的抑制降低。</li>
</ul>
</li>
<li><p>因变量</p>
<ul>
<li>在一项实验中，研究者用以考察是否会受到自变量影响的变量；研究者假定，因变量依存于自变量的水平</li>
</ul>
</li>
<li><p>稀释效应</p>
<ul>
<li><p>有关某个问题的额外的无关信息会弱化人们对该问题的判断或印象的趋势。</p>
<ul>
<li>这是转移话题、转移视线的理论依据吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>素质归因</p>
<ul>
<li>指的是这样一种假定：一个人的行为取决于他（她）的人格（素质），而不是情境压力</li>
</ul>
</li>
<li><p>自我中心思维</p>
<ul>
<li>倾向于更多地讲自己视为事件的中心，而实际上却并非如此</li>
</ul>
</li>
<li><p>自我防卫</p>
<ul>
<li><p>行为的目的是为了维持对自己的正向看法，但却丧失了对世界的正确认识。</p>
<ul>
<li>谁对自己的看法？是自己还是他人？自我防卫和丧失对世界的正确认识之间的逻辑关系？</li>
</ul>
</li>
</ul>
</li>
<li><p>情绪感染</p>
<ul>
<li>情绪或者行为在人群中迅速传播</li>
</ul>
</li>
<li><p>移情</p>
<ul>
<li>将自己置于他人位置上的能力，即采用此人的体验方式来对事件和情感（例如，喜悦、悲伤）进行体验</li>
</ul>
</li>
<li><p>爱</p>
<ul>
<li><p>弗洛伊德所假定的人类所具有的生的本能</p>
<ul>
<li>这句话就很空泛！！！人类需要哪些生的本能？爱为什么是人类的生的本能？它在人类的生的过程中扮演了什么角色？起到了什么作用？</li>
</ul>
</li>
</ul>
</li>
<li><p>交换关系</p>
<ul>
<li>人们之间受公平需要（例如，收益和成本之间的某种平等的比率）主宰的人际关系</li>
</ul>
</li>
<li><p>实验的现实性</p>
<ul>
<li>一项实验对被试具有影响，促使他们认真对待并参与到实验中来，这一点即使在缺乏世俗的现实性时仍然有效。</li>
</ul>
</li>
<li><p>外部理由</p>
<ul>
<li>一个人对自己不协调行为的理由或解释，不是基于个人，而是基于情境（例如，某种奖励或惩罚）。</li>
</ul>
</li>
<li><p>错误一致效应</p>
<ul>
<li><p>过高估计人们在所有问题上赞同自己的比例的趋势</p>
<ul>
<li>有避免以己度人的认识，那么什么时候更容易出现错误一致效应？</li>
</ul>
</li>
</ul>
</li>
<li><p>虚假记忆综合征</p>
<ul>
<li><p>对以往的某种创伤性经历的记忆，尽管这种经历实际上是虚假的，但人们仍然认为它发生过。</p>
<ul>
<li>为什么会出现这种心理？对人们的有什么影响？</li>
</ul>
</li>
</ul>
</li>
<li><p>登门槛技术</p>
<ul>
<li>通过先提出人们容易接受的小要求，然后提出较大的要求，来促使人们按照更大的要求办事的策略</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li><p>在决策的过程中，是否呈现命题（或者是否为其设置框架）决定着是得还是失。</p>
<ul>
<li>决策得失意味着决策成功还是失败？<br>命题或者框架指的是什么？预先设置的目标吗？<br>这句话指的是在决策之前要先制定好目标吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>挫折-攻击</p>
<ul>
<li><p>因感到自己达到某个目标受阻而产生的挫折，会增加人们做出某种攻击性反应的可能性。</p>
<ul>
<li>这叫恼羞成怒吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>基本归因错误</p>
<ul>
<li>在对人们行为原因进行分析时所存在的、过高的估计人格和气质因素而过低估计情境和环境因素的趋势</li>
</ul>
</li>
<li><p>得失效应</p>
<ul>
<li><p>指的是这样一种理论：假如我们能够从他人的预期中获得（例如，这些人最初不喜欢我们，而现在喜欢我们），那我们便会最喜欢这些人；假如我们从他人那里丧失（例如，这些人最初喜欢我们，而现在不喜欢我们），那么我们会最不喜欢这些人。</p>
<ul>
<li>分手了不能做朋友？可以这样解释吗？失去后最讨厌的人？</li>
</ul>
</li>
</ul>
</li>
<li><p>群体思维</p>
<ul>
<li><p>指的是这样的一种思维：为维持群体的一致而无视那些对事实所做的深思熟虑、事实求实的评价</p>
<ul>
<li>***的小圈子为了维持一致性也会做些考虑不周全的事情，那么是不是群体思维作祟？如何避免被群体思维裹挟？</li>
</ul>
</li>
</ul>
</li>
<li><p>光环效应</p>
<ul>
<li>指的是这样的一种偏见：对某个人良好的或者不好的总体印象，会影响到我们对这个人的推测和期望。</li>
</ul>
</li>
<li><p>事后聪明偏差</p>
<ul>
<li>一旦人们知道了某个事件的结果，他们便会强烈地倾向于（往往是错误地）认为，自己事先能预测到这一结果</li>
</ul>
</li>
<li><p>同质性效应</p>
<ul>
<li>与看待自己所在群体的成员相比，人们在看待某个外群体时会发现其成员之间存在更多相似性的趋势。</li>
</ul>
</li>
<li><p>敌对性攻击</p>
<ul>
<li><p>因愤怒感而起的一种攻击性行为，旨在施加痛苦和伤害。</p>
<ul>
<li>还有哪些性质的攻击行为？</li>
</ul>
</li>
</ul>
</li>
<li><p>敌意的性别歧视</p>
<ul>
<li><p>对女性持有负向的定型化看法——例如，女性不如男性聪明</p>
<ul>
<li>什么是定型化看法？</li>
</ul>
</li>
</ul>
</li>
<li><p>液压理论</p>
<ul>
<li><p>根据这一理论，没有表达出来的情绪会累积起来形成压力，必须采取某种形式将这种压力释放出来</p>
<ul>
<li>如何正确、聪明的释放这些压力？</li>
</ul>
</li>
</ul>
</li>
<li><p>虚伪</p>
<ul>
<li><p>个体实际所做的与口头所说的之间存在差异而认知失调</p>
<ul>
<li>认知失调，是在讲自己的状态还是对别人的一种评价措辞？虚伪是自己的一种状态，还是他人对自己的一种评价？</li>
</ul>
</li>
</ul>
</li>
<li><p>认同</p>
<ul>
<li><p>个体因希望与影响施加者相像而对社会影响做出的反应</p>
<ul>
<li>认同等价于采取相同的行为模式。口头认同只是从众，避免来自影响施加者的压力。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚假关联</p>
<ul>
<li>在两个实际上不存在关联的事件之间发现关联或者相关的趋势</li>
</ul>
</li>
<li><p>内群体</p>
<ul>
<li>个体所认同或者感到自己所从属的群体</li>
</ul>
</li>
<li><p>内群体偏爱</p>
<ul>
<li>人们对自己所确定的内群体成员会持有正向的情感并给以特别的对待，而对其他人则持有负向的情感并给予不公平的对待，这样做仅仅是因为将这些人界定为外群体成员。</li>
</ul>
</li>
<li><p>自变量</p>
<ul>
<li>实验者用以考察其自身的改变或者变化是否会对另外一些变量产生影响的变量；研究者预测这种变量会导致其他一些变量的变化。</li>
</ul>
</li>
<li><p>信息；由信息导致的社会影响</p>
<ul>
<li><p>由于我们将他人作为指导自己行为的信息源，因而来自他人的信息会导致我们从众；研究者这种变量会导致其他一些变量的变化</p>
<ul>
<li>这个名词解释有点莫名其妙！！！<br>我怀疑它和上一条串了，从书本上确认了一下，电子版书籍和纸质书籍一致，具体解答有待更新！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>预防接种效应</p>
<ul>
<li>通过先让人们接触少量与他们的态度不一致的观点，而使人们对改变他们的态度的企图产生免疫。</li>
</ul>
</li>
<li><p>工具性攻击</p>
<ul>
<li>将攻击作为实现某种目标的手段，而不仅仅是为了对他人造成痛苦。</li>
</ul>
</li>
<li><p>不充分惩罚</p>
<ul>
<li><p>当个体对拒绝自己期望的目标或者活动缺乏外部辩护理由而引起失调的时候，他们往往会贬低这个活动或者目标</p>
<ul>
<li>这不就是吃不到葡萄说葡萄酸吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>内部理由</p>
<ul>
<li>通过改变自身的某些方面（例如，一个人的态度或者行为）来减少失调。</li>
</ul>
</li>
<li><p>内化</p>
<ul>
<li>个体因希望自己正确而对社会影响作出反应</li>
</ul>
</li>
<li><p>拼图技术</p>
<ul>
<li>为减少孩子们的偏见和增强他们的自尊而设计的一种课堂结构，这种课堂将孩子们安排在规模很小、种族混杂的合作群体之中。</li>
</ul>
</li>
<li><p>便捷式判断</p>
<ul>
<li><p>为使自己的判断迅速而有效，人们所采取的的心理捷径。</p>
<ul>
<li>这种心理捷径是什么？它是如何帮助人们人们做出快速有效的判断的？</li>
</ul>
</li>
</ul>
</li>
<li><p>为努力进行辩护</p>
<ul>
<li>个体会更喜爱他们经过努力而达到的某个目标的倾向</li>
</ul>
</li>
<li><p>虚报低价</p>
<ul>
<li>一些营销人员所采用的一种不择手段的策略，他们首先诱导消费者在一个很低的价位上购买商品，然后声称出错并提高价格；最终消费者往往会同意按提高了的价格购买商品。</li>
</ul>
</li>
<li><p>最小群体范式</p>
<ul>
<li>完全陌生的人通过微不足道的标准组成一个无意义的群体；最小群体成员之间仍然表现出内群体偏见。</li>
</ul>
</li>
<li><p>世俗的现实性</p>
<ul>
<li>实验室实验在多大的程度上与外部世界经常发生的事情类似</li>
</ul>
</li>
<li><p>看法</p>
<ul>
<li><p>坚持认为是正确的（无需评价和情感表露）</p>
<ul>
<li>例如：请某人谈一下对某事情的看法？那如此来看的话，对这种问题是不是只需要说对错，无需说明缘由或者表达爱憎？</li>
</ul>
</li>
</ul>
</li>
<li><p>外群体</p>
<ul>
<li>不为个体所认同的群体</li>
</ul>
</li>
<li><p>激情之爱</p>
<ul>
<li>对另外一个人所感受到的强烈的渴望并伴有生理唤起的情感；假如这种爱得到回报，人们便会体验到巨大的实现感并欣喜若狂；假如没有得到回报，人们便会感到伤心失望。</li>
</ul>
</li>
<li><p>说服的边缘路径</p>
<ul>
<li><p>在这种情况下，人们不会对说服信息中的观点进行详细考虑，而是受到边缘线索的影响。</p>
<ul>
<li>什么是说服过程中的边缘线索？</li>
</ul>
</li>
</ul>
</li>
<li><p>出丑效应</p>
<ul>
<li>指的是这样一种现象：一些失误现象会增加某个近乎完美的人的吸引力</li>
</ul>
</li>
<li><p>偏见</p>
<ul>
<li>仅仅依据特定群体中部分成员的特征而形成的、对整个群体的敌对的或者负向的态度。</li>
</ul>
</li>
<li><p>首因效应</p>
<ul>
<li>在某种特定的条件下，人们最先听到的论证会对他们产生特别的影响。</li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li>启动过程基于这样一种观点：最近出现的或者被频繁激活的想法更可能出现在脑海里，因而被用于解释社会事件。</li>
</ul>
</li>
<li><p>接近性</p>
<ul>
<li>决定人们是否喜欢或者爱上一个人的重要因素之一是物理上的接近；人们更可能与居住在自己所在的城镇或者城镇附近的人、或者是居住地虽然远但是却在同一所大学的人坠入爱河。</li>
</ul>
</li>
<li><p>随机分配</p>
<ul>
<li>将被试机会均等的分配到任何一种实验条件的过程；通过随机分配，研究者可以比较有把握保证被试的人格或背景均匀地分布在各种条件之下。</li>
</ul>
</li>
<li><p>近因效应</p>
<ul>
<li>在某种特定的条件下，人们最后听到的论证会对他们产生特别的影响。</li>
</ul>
</li>
<li><p>重构性记忆</p>
<ul>
<li><p>人们对某个事件的记忆会受到他们在该事件发生后所接触信息歪曲的过程</p>
<ul>
<li>又是一句看不懂的解释！！！<br>请注意查证！！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>记忆恢复现象</p>
<ul>
<li>对以往已经忘记的或者被压抑的事件（例如，性虐待）的回忆；这类记忆的准确性往往存在着大量的争议。</li>
</ul>
</li>
<li><p>关系性攻击</p>
<ul>
<li>一种非身体形式的攻击，诸如搬弄是非、散布虚假的谣言和排挤</li>
</ul>
</li>
<li><p>相对剥夺</p>
<ul>
<li>感觉自己（或者自己所属的群体）所得到的的，少于自己所应该得到的，少于自己所期望得到的，或者少于与自己相同的人所得到的。</li>
</ul>
</li>
<li><p>代表性便捷式判断</p>
<ul>
<li>人们对某一事物进行归类时所借助的心理捷径是该事物与某一典型事物之间的相似程度</li>
</ul>
</li>
<li><p>浪漫之爱</p>
<ul>
<li>根据斯滕伯格的观点，这是一种激情与亲密相结合的状态</li>
</ul>
</li>
<li><p>替罪羊</p>
<ul>
<li>个体倾向于将攻击矛头转向他们所不喜欢的、明显的而又相对弱小的群体。</li>
</ul>
</li>
<li><p>脚本</p>
<ul>
<li>人们从文化中潜移默化地习得的社会行为方式</li>
</ul>
</li>
<li><p>次级收益</p>
<ul>
<li>在作出依从行为之后，某种未曾预料的、有利的事态使得从众行为更具吸引力</li>
</ul>
</li>
<li><p>自我概念</p>
<ul>
<li>自我的内容，即人们对自身的想法、信念以及人格特征的感知</li>
</ul>
</li>
<li><p>自尊</p>
<ul>
<li>人们对自我价值的评价，即人们对自己的美德、能力和正派方面达到何种程度的看法</li>
</ul>
</li>
<li><p>自证预言</p>
<ul>
<li>人们对另外的一个人是什么样的人所抱有的期望，这种期望会影响到人们对待此人的行为方式，并会促使此人按照人们最初对他预判相一致的方式去行为。</li>
</ul>
</li>
<li><p>自我辩护</p>
<ul>
<li>为了维护自己的自尊二区证明自己的行为合理的倾向</li>
</ul>
</li>
<li><p>自我知觉理论</p>
<ul>
<li><p>指的是这样的一种理论：当我们的归因不确定或者模糊不清的时候，我们会根据自身行为的观测来对其加以推测。</p>
<ul>
<li>这种推测有什么倾向？是素质归因还是情境归因？这种推测是否合理、正确？有没有其他的方法来帮助我们在这种情境下进行归因？</li>
</ul>
</li>
</ul>
</li>
<li><p>自我图式</p>
<ul>
<li>根据我们以往的经历，对我们自身的知识加以组织，以帮助我们理解、解释和预测我们自身的行为。</li>
</ul>
</li>
<li><p>自利偏差</p>
<ul>
<li>个体将自己的成功归因于素质，而将自己的失败归因于情境的情境。</li>
</ul>
</li>
<li><p>相似性</p>
<ul>
<li>人们往往会喜欢或者爱上与自己的看法、态度、价值和长相类似的人</li>
</ul>
</li>
<li><p>社会认知</p>
<ul>
<li>人们如何思考自身以及社会生活；具体而言，人们如何选择、解释、记忆和运用社会信息进行判断和决策。</li>
</ul>
</li>
<li><p>社会影响</p>
<ul>
<li>人们对他人的看法和行为所施加的影响</li>
</ul>
</li>
<li><p>社会学习理论</p>
<ul>
<li>这种理论认为：人们通过观察和模仿他人来习得社会行为（例如，攻击行为）</li>
</ul>
</li>
<li><p>社会心理学</p>
<ul>
<li>对受到真实的或想象的他人在场影响下的人们的思想、情感和行为方式的科学研究</li>
</ul>
</li>
<li><p>定型</p>
<ul>
<li>对某个群体的简单的概括，从个人所持偏见出发，赋予他们完全相同的特征。</li>
</ul>
</li>
<li><p>定型威胁</p>
<ul>
<li>少数族裔的成员对他们自身的行为方式与已有的文化定型相符合的担忧。这种担忧往往会降低他们取得成绩的能力。</li>
</ul>
</li>
<li><p>坦率地谈话</p>
<ul>
<li><p>一个人明确地说出自己的情感和心事，而且不对对方加以指责、挖苦或者嘲笑</p>
<ul>
<li>那么在坦率的谈话情境下，如何才能让谈话的另外一方不产生其他的附带情绪？比如说出自己的情绪后，对方会不会觉得自己是在指责ta，然后继而道歉？然后坦率的谈话该如何把握谈话的方向？从而避免发展成为激烈的互相指责和争吵？</li>
</ul>
</li>
</ul>
</li>
<li><p>睾丸素</p>
<ul>
<li>与攻击性有关的一种激素</li>
</ul>
</li>
<li><p>桑纳托斯</p>
<ul>
<li><p>根据弗洛伊德的观点，这是一种促使人类走向死亡的本能的驱动力，会导致攻击行为。</p>
<ul>
<li>弗洛伊德关于此观点的详细描述请加以查证！！！</li>
<li>桑纳托斯是如何导致攻击性行为的？</li>
</ul>
</li>
</ul>
</li>
<li><p>爱情三角</p>
<ul>
<li>根据斯滕伯格的观点，爱情的三种成分是：激情、亲密和承诺</li>
</ul>
</li>
<li><p>基本归隐偏差</p>
<ul>
<li>在对特定人群进行整体归因时所出现的、与人们对该群体的偏见相一致的素质归因倾向。</li>
</ul>
</li>
</ul>
</li>
<li><p>读者大纲</p>
<ul>
<li><p>第一章：社会心理学概念及分析</p>
<ul>
<li><p>第一部分：什么是社会心理学？</p>
<ul>
<li>读者答：作者并没有直接给社会心理学直接下定义；而是通过通过一系列社会群体和个体对人们施加影响的案例来引导出“社会影响”这个关键论题。社会影响指的是人们对他人的想法产生的影响。</li>
</ul>
</li>
<li><p>第二部分：社会心理学的几个问题</p>
<ul>
<li>第一问：人们是怎么受到影响的？</li>
<li>第二问：对人们而言这些影响的隐含意义是什么？或者说人们为什么会受到影响？<br>读者注释：这个问题问的有点不明白！！！</li>
<li>第三问：哪些因素会增强或者削弱社会影响</li>
<li>第四问：社会影响是长久的还是短暂的?这里讨论的是社会影响的持续性。</li>
<li>第五问：哪些因素会影响社会影响的持续性？</li>
</ul>
</li>
<li><p>第三部分：社会心理学实验</p>
<ul>
<li><p>第一重点：强调社会心理学实验的重要性；不要有“显而易见”的心理；</p>
</li>
<li><p>第二重点：强调社会心理学实验的一些问题</p>
<ul>
<li>重点一：社会心理学实验的组成要素</li>
<li>重点二：社会性理学实验的有利因素、不利因素、伦理难题、激动人心之处、棘手之处和令人痛心之处</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第二章;从众</p>
<ul>
<li><p>第一部分：什么是从众效应？群体压力和从众的关系</p>
<ul>
<li>读者答：群体压力是从众效应的关键性因素之一</li>
</ul>
</li>
<li><p>第二部分：什么导致了群体压力</p>
</li>
<li><p>第三部分：群体压力的本质是什么？（读者注解：第二部分和第三部分的问题解答应该是相似度很高的）</p>
</li>
<li><p>第四部分：群体压力带来的个体行为和意见的改变是真是假？</p>
</li>
<li><p>第五部分：从众效应带来的改变是短暂还是长久的？</p>
</li>
<li><p>第六部分：哪些因素会增强从众效应？</p>
</li>
<li><p>第七部分：如何理解没有群体压力下的从众效应？</p>
</li>
<li><p>第八部分：对社会影响的几个不同的反应</p>
</li>
<li><p>第九部分：从众者和旁观者的关系</p>
</li>
<li><p>第十部分:从众效应实验中应该注意的伦理问题</p>
</li>
</ul>
</li>
<li><p>第三章：大众传播、宣传和说服</p>
<ul>
<li>第一部分：人们生活中的常见的几种宣传、说服的例子</li>
<li>第二部分：说服的两种路径</li>
<li>第三部分;宣传的可信性和宣传的性质以及如何加强宣传的影响？</li>
<li>第四部分；说服接受者的一些特征</li>
<li>第五部分：如何发挥传播、宣传和说服原则的作用？换言之，我们如何利用这些原则来扩大社会影响</li>
</ul>
</li>
<li><p>第四章：社会认知</p>
<ul>
<li>第一部分：社会认知和人们进行行为决策的关系</li>
<li>第二部分:我们应该如何理解世界？换言之，我们应该如何建立我们的社会认知？哪些因素会影响我们的社会认知进而影响我们的行为决策和意见？</li>
<li>第三部分：在社会认知下的几种判断方式和运用这些判断方式的时机</li>
<li>第四部分：社会认知下人们如何对事物和人物进行分类以及分类之后所产生的结果？分类和社会定型的关系？</li>
<li>第五部分:记忆作为社会交往重要部分，重构性记忆和自传性记忆的缺陷。</li>
<li>第六部分：什么是人类认知？人类认知存在哪些保守性？</li>
<li>第七部；人们的态度和信念是如何影响决策并且指导行动的？</li>
<li>第八部分：哪些因素导致了人们在解释和归因社会生活时出现了偏差（证实偏差、自我偏差、行动者-观察者偏差）？</li>
<li>第九部分:影响人们社会认知的自我中心思维和自利偏差</li>
</ul>
</li>
<li><p>第五章：自我辩护</p>
<ul>
<li>第一部分：人们都会对自己的行为、信念和感受加以辩护，以便让自己或者他人相信自己所做事情的合理性，证明自己的正确性</li>
<li>第二部分：认知失调的理论的详解</li>
<li>第三部分：认知失调理论的实际应用</li>
</ul>
</li>
<li><p>第六章：人类的攻击性</p>
<ul>
<li>第一部分：人类的攻击性的定义个攻击性的分类</li>
<li>第二部分：攻击性行为的利弊</li>
<li>第三部分：攻击性行为的动机理论、人类的攻击性行为受哪些因素的影响</li>
<li>第四部分：任何降低人类的攻击性</li>
</ul>
</li>
<li><p>第七章：偏见</p>
<ul>
<li>第一部分：什么是偏见</li>
<li>第二部分：偏见是如何产生的？定型对偏见的产生有何影响？它的人类的言行有哪些威胁？</li>
<li>第三部分：如何消除偏见</li>
</ul>
</li>
<li><p>第八章：喜欢、爱和人际敏感性</p>
<ul>
<li>第一部分：喜欢和不喜欢的定义？它是如何产生的？</li>
<li>第二部分：从喜欢到爱的转变过程？这一过程是如何发生的？哪些因素会对这个过程产生影响</li>
<li>第三部分：爱随着时间的变化趋势？增强或者削弱爱的因素。</li>
</ul>
</li>
<li><p>第八章：作为一门科学的社会性理学</p>
<ul>
<li>第一部分:社会心理学的一些基本实验原理</li>
<li>第二部分：社会心理学实验中存在的一些问题挑战、</li>
</ul>
</li>
</ul>
</li>
<li><p>问题解答</p>
<ul>
<li><p>这本书在谈什么？</p>
<ul>
<li>读者答：这本书在讨论的是社会心理学中的社会影响这个话题。讨论的问题包括什么是社会影响、社会影响有什么含义、增强或者减弱社会影响的因素有哪些、这些影响是短暂的还是持续性的、增强或者削弱影响持续性的一些因素</li>
</ul>
</li>
<li><p>这本书架构如何？</p>
<ul>
<li><p>这本书主要包含一下几个部分</p>
<ul>
<li>第一部分：主要是该书的第一章节内容；主要议题就是提出社会影响这个话题已经关于社会影响的几个问题；并且说明关于社会心理学实验的组成因素和社会心理学实验所面临的的问题。</li>
<li>第二部分:主要包含该书的第二章节~第八章节内容；主要讨论了</li>
</ul>
</li>
</ul>
</li>
<li><p>这本书分为哪些部分？</p>
</li>
<li><p>这是什么类型的书籍？</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h3><ul>
<li><p>分析阅读概念笔记</p>
<ul>
<li>包含内容：作者观点、论据、读者观点</li>
<li>作者论点、论据</li>
<li>好句摘录</li>
<li>读者观点</li>
</ul>
</li>
</ul>
<h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><ul>
<li><p>主题阅读概念笔记</p>
<ul>
<li>包含内容：主题相关书籍中的作者观点、论据</li>
<li>主题观点、论据</li>
</ul>
</li>
</ul>
<h3 id="读者反馈"><a href="#读者反馈" class="headerlink" title="读者反馈"></a>读者反馈</h3><ul>
<li>这本书在谈什么</li>
<li>作者说明了哪些问题？又是怎么说明的？</li>
<li>作者说的内容是否有道理？</li>
<li>这本书和读者之间的关系？</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/18/Git%20Tag%20%E8%AF%A6%E8%A7%A3/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/git_image.png" alt="Git Tag详解"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-04-18  <a class="commentCountImg" href="/2022/04/18/Git%20Tag%20%E8%AF%A6%E8%A7%A3/#comment-container"><span class="display-none-class">5299bbc18182b5fed894d63658586618</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5299bbc18182b5fed894d63658586618">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>11 分钟  <i class="fas fa-pencil-alt"> </i>1.6 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/18/Git%20Tag%20%E8%AF%A6%E8%A7%A3/">Git Tag详解</a></h1><div class="content"><h1 id="Git-tag-详解"><a href="#Git-tag-详解" class="headerlink" title="Git tag 详解"></a>Git tag 详解</h1><h2 id="1、什么是标签？"><a href="#1、什么是标签？" class="headerlink" title="1、什么是标签？"></a>1、什么是标签？</h2><p>​        和大多数的VCS一样，git可以对某一个时间点上的版本打标签，通俗的说法是就是标记某个时间的位置；它的好处是让我们更加容易的找到某个特定的提交记录，方便我们从这个时间进行一些版本管理动作，例如发布发某个版本，或者是从某个特定的时间点拉出分支进行开发。</p>
<h2 id="2、如何列出已有的标签？"><a href="#2、如何列出已有的标签？" class="headerlink" title="2、如何列出已有的标签？"></a>2、如何列出已有的标签？</h2><ol>
<li><p>​        列出所有已有标签的命令是git  tag</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line">    v0.1</span><br><span class="line">    v1.3</span><br></pre></td></tr></table></figure></li>
<li><p>根据指定规则列出所有符合要求的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span></span></span><br><span class="line">    $ git tag</span><br><span class="line">    v0.1</span><br><span class="line">    v1.3</span><br><span class="line">    v1.4</span><br></pre></td></tr></table></figure>

<ul>
<li>注解：以上两种列出标签的结果按照字母先后排序，排序位置不代表重要性。</li>
</ul>
</li>
</ol>
<h2 id="3、如何新建标签？"><a href="#3、如何新建标签？" class="headerlink" title="3、如何新建标签？"></a>3、如何新建标签？</h2><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><ol>
<li>轻量级标签实质上就是一个指向一个特定提交对象的引用。在这里我们将某一次的提交称之为一个提交对象。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">test@test MINGW64 /d/VC_Code/git_test (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0</span></span><br><span class="line">test@LAPTOP-ECCQUA9A MINGW64 /d/VC_Code/git_test (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.0</span></span><br><span class="line">commit e0c54eb32518ba283dc0e1b7a407a369c441ac57 (HEAD -&gt; develop, tag: v1.0, origin/develop)</span><br><span class="line">Author: test&lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:53:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    code test</span><br><span class="line"></span><br><span class="line">diff --git a/git_test/Student.h b/git_test/Student.h</span><br><span class="line">index cc470c6..5cf10d7 100644</span><br><span class="line">--- a/git_test/Student.h</span><br><span class="line">+++ b/git_test/Student.h</span><br><span class="line">@@ -3,6 +3,6 @@ class Student</span><br><span class="line"> &#123;</span><br><span class="line">        //test -1</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">+       //test -2</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test@test MINGW64 /d/VC_Code/git_test (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit e0c54eb32518ba283dc0e1b7a407a369c441ac57 (HEAD -&gt; develop, tag: v1.0, origin/develop)</span><br><span class="line">Author: test&lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:53:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    code test</span><br><span class="line"></span><br><span class="line">commit 4317fd26d5be6c9daaf3fc84a05e5be1a72a27b9</span><br><span class="line">Author: test &lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:53:18 2022 +0800</span><br><span class="line"></span><br><span class="line">    code review</span><br><span class="line"></span><br><span class="line">commit fffede0c1a93246e2574aad82891fd234b79c0e7 (origin/master, master)</span><br><span class="line">Author: test &lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:47:49 2022 +0800</span><br><span class="line"></span><br><span class="line">    first  commit</span><br><span class="line"></span><br><span class="line">commit 5586d72f74a5ea10c664305515b3c7abe9a6bd62</span><br><span class="line">Author: test &lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:35:32 2022 +0800</span><br><span class="line"></span><br><span class="line">    添加项目文件。</span><br><span class="line"></span><br><span class="line">commit 74981babd7cb44a0ae2b96e1c3e80311dc39f664</span><br><span class="line">Author: test &lt;test@hotmail.com&gt;</span><br><span class="line">Date:   Mon Apr 18 23:35:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    添加 .gitignore 和 .gitattributes。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注解：</p>
<ul>
<li><p>创建轻量级标签的时候不需要任何的参数</p>
</li>
<li><p>查看此标签信息，发现其对应的提交对象是最后一次的提交commit。</p>
</li>
</ul>
</li>
</ul>
<h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><ol>
<li>含附注的标签则可以理解为一个特定的提交对象，它有自身的校验和信息，包含了标签名称、邮箱地址、日期和标签说明；标签本身允许使用GPG（GUN Privacy  Guard）来签署或者验证。</li>
<li>建议：推荐使用含附注的标签，他可以保留更多的信息；如果只是临时性、不需要旁注额外信息的，则建议使用轻量级标签。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span></span></span><br><span class="line">    $ git tag</span><br><span class="line">    v0.1</span><br><span class="line">    v1.3</span><br><span class="line">    v1.4</span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br><span class="line">    tag v1.4</span><br><span class="line">    Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">    Date: Mon Feb 9 14:45:11 2009 -0800</span><br><span class="line"></span><br><span class="line">    my version 1.4</span><br><span class="line">    commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">    Merge: 4a447f7... a6b4c97...</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Feb 8 19:02:46 2009 -0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;experiment&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解：<ul>
<li>-a anotated的首字母，指定标签名</li>
<li>-m 指定对应的标签说明，git会将这个标签说明一起存在上次的提交对象中；如果没有给出该项，git会启动文本编辑软件来供作者输入标签说明</li>
</ul>
</li>
</ul>
<h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><ol>
<li>需要私匙，也可以用GPG来验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s v1.5 -m <span class="string">&#x27;my signed 1.5 tag&#x27;</span></span></span><br><span class="line">    You need a passphrase to unlock the secret key for</span><br><span class="line">    user: &quot;Scott Chacon &lt;schacon@gee-mail.com&gt;&quot;</span><br><span class="line">    1024-bit DSA key, ID F721C45A, created 2009-02-09</span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.5</span></span><br><span class="line">    tag v1.5</span><br><span class="line">    Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">    Date: Mon Feb 9 15:22:20 2009 -0800</span><br><span class="line"></span><br><span class="line">    my signed 1.5 tag</span><br><span class="line">    -----BEGIN PGP SIGNATURE-----</span><br><span class="line">    Version: GnuPG v1.4.8 (Darwin)</span><br><span class="line"></span><br><span class="line">    iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</span><br><span class="line">    Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</span><br><span class="line">    =WryJ</span><br><span class="line">    -----END PGP SIGNATURE-----</span><br><span class="line">    commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">    Merge: 4a447f7... a6b4c97...</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Feb 8 19:02:46 2009 -0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;experiment&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解：<ul>
<li>将参数-a 改为-s，即singed的首字母</li>
<li>我们将在在后面学习如何验证签署标签！</li>
</ul>
</li>
</ul>
<h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><ol>
<li>可以使用 <code>git tag -v [tag-name]</code> （译注：取 <code>verify</code> 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v v1.4.2.1</span></span><br><span class="line">    object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">    type commit</span><br><span class="line">    tag v1.4.2.1</span><br><span class="line">    tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</span><br><span class="line"></span><br><span class="line">    GIT 1.4.2.1</span><br><span class="line"></span><br><span class="line">    Minor fixes since 1.4.2, including git-mv and git-http with alternates.</span><br><span class="line">    gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">    gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span><br><span class="line">    gpg: aka &quot;[jpeg image of size 1513]&quot;</span><br><span class="line">    Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注解：</p>
<ul>
<li><p>若是没有签署者的公钥，会报告类似下面这样的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">    gpg: Can&#x27;t check signature: public key not found</span><br><span class="line">    error: could not verify the tag &#x27;v1.4.2.1&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><ol>
<li>可以在后期对早先的某次提交加注标签</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">    15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">    a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">    0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">    6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">    0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">    4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">    166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">    9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">    964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">    8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line">    v0.1</span><br><span class="line">    v1.2</span><br><span class="line">    v1.3</span><br><span class="line">    v1.4</span><br><span class="line">    v1.4-lw</span><br><span class="line">    v1.5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">    tag v1.2</span><br><span class="line">    Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">    Date: Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">    version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><ol>
<li>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.5</span></span><br><span class="line">    Counting objects: 50, done.</span><br><span class="line">    Compressing objects: 100% (38/38), done.</span><br><span class="line">    Writing objects: 100% (44/44), 4.56 KiB, done.</span><br><span class="line">    Total 44 (delta 18), reused 8 (delta 1)</span><br><span class="line">    To git@github.com:schacon/simplegit.git</span><br><span class="line">    * [new tag] v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注解：</p>
<ul>
<li><p>如果要一次推送所有本地新增的标签上去，可以使用 <code>--tags</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line">    Counting objects: 50, done.</span><br><span class="line">    Compressing objects: 100% (38/38), done.</span><br><span class="line">    Writing objects: 100% (44/44), 4.56 KiB, done.</span><br><span class="line">    Total 44 (delta 18), reused 8 (delta 1)</span><br><span class="line">    To git@github.com:schacon/simplegit.git</span><br><span class="line">    * [new tag] v0.1 -&gt; v0.1</span><br><span class="line">    * [new tag] v1.2 -&gt; v1.2</span><br><span class="line">    * [new tag] v1.4 -&gt; v1.4</span><br><span class="line">    * [new tag] v1.4-lw -&gt; v1.4-lw</span><br><span class="line">    * [new tag] v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-如何从一个标签上检出分支进行开发"><a href="#4-如何从一个标签上检出分支进行开发" class="headerlink" title="4.如何从一个标签上检出分支进行开发"></a>4.如何从一个标签上检出分支进行开发</h2><ol>
<li>如我们在第一部分中说的，当我们需要检出某个标签的提交对象进行二次开发的时候，我们可以进行一下操作：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0.0</span></span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:benben/testBranch.git</span><br><span class="line"> * [new tag]         v1.0.0 -&gt; v1.0.0</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b version1 v1.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version1&#x27;</span><br></pre></td></tr></table></figure>

</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Git/">Git</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Git/">Git</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/02/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/read.jpg" alt="《如何阅读一本书》读书笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-02  <a class="commentCountImg" href="/2022/02/02/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/#comment-container"><span class="display-none-class">268f5fc306b6c028b2146f4c048cb8ca</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="268f5fc306b6c028b2146f4c048cb8ca">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>11.6 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/02/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/">《如何阅读一本书》读书笔记</a></h1><div class="content"><h1 id="如何阅读一本书"><a href="#如何阅读一本书" class="headerlink" title="如何阅读一本书"></a>如何阅读一本书</h1><h2 id="阅读的活力和艺术"><a href="#阅读的活力和艺术" class="headerlink" title="阅读的活力和艺术"></a>阅读的活力和艺术</h2><p>阅读就像是一场棒球赛；<br>作者是投手,读者是捕手，既要投手投球投的好，也需要捕手接得住投手的球。<br>提倡主动阅读:<br>1、培养主动阅读、主动学习的习惯<br>2、阅读越主动，效果越好；读者越主动，在阅读的世界里探索能力就强一些，收获多一些，自然也就高明一些；<br>3、读者要求的越多，获得的就越多。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>获得资讯</li>
<li>求得理解</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>指导型学习</li>
<li>自我发现型学习</li>
</ul>
<h3 id="阅读的两种意义"><a href="#阅读的两种意义" class="headerlink" title="阅读的两种意义"></a>阅读的两种意义</h3><ul>
<li>1、在阅读报纸、杂志或者其他的读物的时候，凭借我们的阅读技巧和聪明才智，一下子就可以融会贯通</li>
<li>2、试着阅读一开始并不怎么了解的东西</li>
</ul>
<h2 id="阅读层次大致分类"><a href="#阅读层次大致分类" class="headerlink" title="阅读层次大致分类"></a>阅读层次大致分类</h2><h3 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h3><ul>
<li><p>目标</p>
<ul>
<li>这个句子在说什么,拜托文盲状态,可以识字</li>
</ul>
</li>
<li><p>基础阅读的四个阶段</p>
<ul>
<li><p>阶段一：阅读准备阶段</p>
<ul>
<li>身体准备：良好的听力和视力。</li>
<li>智力准备：起码的认知能力。</li>
<li>个人准备：能与他人一起学习的能力，保持注意力和服从等。</li>
</ul>
</li>
<li><p>阶段二：学会阅读一些简单的食物，并且附带一些事物的观察</p>
</li>
<li><p>阶段三：</p>
<ul>
<li>快速建立字汇的能力</li>
</ul>
</li>
<li><p>阶段四：</p>
<ul>
<li>精进和锻炼前三个阶段学会的阅读技巧</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h3><ul>
<li><p>目标</p>
<ul>
<li>这本书在谈什么</li>
<li>这本书的架构如何</li>
<li>这本书分为哪些部分</li>
<li>这是什么类型的书</li>
</ul>
</li>
<li><p>有限的时间内，最好最完整的阅读</p>
<ul>
<li>系统化略读,</li>
</ul>
</li>
<li><p>检视阅读层次</p>
<ul>
<li><p>第一层次：有系统的粗读或略读</p>
<ul>
<li><p>检视阅读第一次层次建议</p>
<ul>
<li><p>1.先看书名或者序言</p>
<ul>
<li>如果有副标题也需要注意，或者其他的相关说明或者宗旨</li>
</ul>
</li>
<li><p>2.研究目录页</p>
<ul>
<li>对这本书的架构进行概括性的了解</li>
</ul>
</li>
<li><p>3.检阅书中索引</p>
<ul>
<li>了解本书所覆盖的议题范围</li>
</ul>
</li>
<li><p>4.出版者介绍</p>
<ul>
<li>1.吹牛皮</li>
<li>2.作者对本书的主旨摘要</li>
</ul>
</li>
<li><p>5.挑选主题相关的篇章阅读</p>
<ul>
<li>阅读书本开头或者结尾的主题相关篇章，他们通常会是整本书的摘要说明</li>
</ul>
</li>
<li><p>6.全书翻阅一遍</p>
<ul>
<li>1.寻找主要论点的信息</li>
<li>2.留意主题的基本脉动</li>
<li>3.重点阅读书本的最后几个篇章，通常情况下，作者会在最后几个篇章进行观点梳理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第二层次：粗浅的阅读</p>
<ul>
<li><p>检视阅读第二层次建议</p>
<ul>
<li>7.阅读规则：头一次面对一本阅读难读较大的书的时候，先从头到尾读一遍，碰到不懂的地方也不要停下来查询或者思考</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>阅读速度</p>
<ul>
<li>1.我们应该依照读物的性质和复杂程度,使用不同的速度来阅读</li>
<li>2.检视阅读就是一种训练有素的快速阅读。但是检视阅读的快不是因为你读的快（虽然你确实读的快），而是因为我只是选择一部分进行阅读，并且这一部分的阅读速度还不一样</li>
<li>3.分析阅读通常情况下是比检视阅读慢一点的，但是我们同样不应该用相同的速度读完全书。</li>
</ul>
</li>
<li><p>逗留与倒退</p>
<ul>
<li><p>逗留现象</p>
<ul>
<li>未受过阅读训练的读者在阅读的手，会在一行字的几个位置逗留，也就是眼睛移动时看不到，只有停下来了才能看到</li>
</ul>
</li>
<li><p>倒退现象</p>
<ul>
<li>不熟练的读者在阅读完几行内容后，眼睛会不自觉的倒退回远点。会倒退到原先读过的句子上去。</li>
</ul>
</li>
<li><p>矫正要求</p>
<ul>
<li>不能跟着眼部的慢速度来阅读，而是应该跟着脑部的快速度来阅读</li>
</ul>
</li>
<li><p>矫正办法</p>
<ul>
<li>手指指针法：用手指顺着一行一行的字移动下去，保证移动速度比眼睛的速度快一点，然后强迫自己的眼睛跟随手指的移动速度</li>
</ul>
</li>
</ul>
</li>
<li><p>理解的问题</p>
<ul>
<li><p>问题：很多人觉得速度的时候无法理解文字内容？</p>
</li>
<li><p>解答：</p>
<ul>
<li>1.采用手指指针法来快速阅读的时候，不仅可以提高我们的阅读速度，也会让我们保证注意力的高度集中；随着阅读速度的提升，理解能力也会有相应的提高</li>
<li>2.优秀的阅读者在阅读的时候会专心致志，这对我们的理解能力会有帮助；但是如果需要深入的理解我们的读物，我们需要进行下一阶段的分析阅读；如果我们认定手上的读物无需全书进行分析阅读，我们也可以标记需要加强理解的内容，在完成检视阅读之后进行深入的分析和总结。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h3><ul>
<li><p>全盘的、系统的阅读，或者说优质的阅读</p>
</li>
<li><p>无限的时间内，最好最完整的的阅读</p>
</li>
<li><p>分析阅读擅长于寻求理解，如果只是获得资讯或者消遣，则没有必要进行分析阅读。</p>
</li>
<li><p>分析阅读的规则</p>
<ul>
<li><p>1.读者要知道自己读的是哪一类的书，且越早知道越好</p>
<ul>
<li><p>这里涉及到书籍的分类</p>
<ul>
<li><p>虚构作品</p>
<ul>
<li>小说</li>
<li>戏剧</li>
<li>史诗</li>
<li>抒情诗</li>
<li>……</li>
</ul>
</li>
<li><p>论说性作品</p>
<ul>
<li><p>主要内容由一些观点、理论、假设和推断组成，并且作者多少表示了这些主张是有根据的，这种书籍就是传达知识的论说性书籍;不论读者是否同意书中的观点,都不会改变这本书的分类性质</p>
<ul>
<li>历史类</li>
<li>哲学类</li>
<li>物理类</li>
<li>伦理类</li>
<li>……</li>
</ul>
</li>
<li><p>论说性作品基本分类准则</p>
<ul>
<li><p>理论性作品</p>
<ul>
<li><p>在教读者这是什么</p>
</li>
<li><p>典型陈述</p>
<ul>
<li>是</li>
<li>没有</li>
<li>应当</li>
</ul>
</li>
<li><p>理论性作品分类</p>
<ul>
<li><p>哲学类</p>
<ul>
<li>否则就是哲学类</li>
</ul>
</li>
<li><p>科学类</p>
<ul>
<li>如果一本理论的书所强调的内容，超过你日常、例行和经验，那么就是一本科学类书籍</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实用性作品</p>
<ul>
<li><p>在教读者如何去做读者想做的事情,或者是读者认为该做的事情</p>
</li>
<li><p>典型陈述:</p>
<ul>
<li>某件事应该做完、做到</li>
<li>这样做某个东西是对的</li>
<li>这样做比那样做的结果好</li>
<li>这样选择比那样选择更好</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：知与行的区别</p>
<ul>
<li>知:知道这是怎么回事</li>
<li>行:我们想做些什么,我们应该怎么利用它</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>从书籍名称中获取更多的信息，最重要的是对书记进行分类</p>
</li>
</ul>
</li>
<li><p>2.使用单一的句子或者最多几句话来概括本书的主要内容</p>
<ul>
<li><p>结构和规划：叙述整本书的大意</p>
<ul>
<li><p>要点</p>
<ul>
<li><p>1.一位优秀的作者，会经常想要帮助读者来整理书中的要点</p>
<ul>
<li><p>存在的问题</p>
<ul>
<li><p>问题：大多数读者无法说出一本书的重要内容</p>
</li>
<li><p>原因：</p>
<ul>
<li>1.人们不会用简明的语言表达自己</li>
<li>2.忽视了一些阅读的规则，比如没有阅读前言，目录或者后记这些重要内容</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.不要将作者提供的一些书本的重点，当做是绝对且唯一的说明</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.将书中的重要篇章列出来，看他们如何按照顺序组成一个整体的架构</p>
<ul>
<li><p>驾驭复杂的内容：为一本书拟大纲的技巧</p>
<ul>
<li><p>大纲模板</p>
<ul>
<li><p>第一部分谈的什么</p>
<ul>
<li><p>第一段落X</p>
<ul>
<li>第一重点A</li>
<li>第二重点B</li>
<li>第三重点C</li>
<li>……</li>
</ul>
</li>
<li><p>第二段落Y</p>
</li>
<li><p>第三段落Z</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
<li><p>第二部分谈的什么</p>
</li>
<li><p>第四部分谈的什么</p>
</li>
<li><p>第五部分谈的什么</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.找出作者要问的问题或者作者想要解决的问题</p>
<ul>
<li><p>如何找出作者想要问的问题:常用的提问技巧</p>
<ul>
<li><p>理论性的问题</p>
<ul>
<li>某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是、什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的</li>
</ul>
</li>
<li><p>实用性问题</p>
<ul>
<li>有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.找出共通的词义</p>
<ul>
<li><p>本规则的细分</p>
<ul>
<li>找出重要的单字</li>
<li>确认这些单字在文中使用时的准确词义</li>
</ul>
</li>
<li><p>单字和词义</p>
<ul>
<li><p>1.单字词义完全相同</p>
<ul>
<li>找到书中重要的单词,就能和作者达成共识</li>
</ul>
</li>
<li><p>2.单字和词义不同</p>
<ul>
<li>如果读者理解的词义和作者表达的此役出现偏差,那么沟通就会存在模糊地带,双方也就无法达成共识</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是共识</p>
<ul>
<li>共识就是通过文字的技巧,达到沟通沟通知识的目的</li>
</ul>
</li>
<li><p>如何找出关键字(重要的单字)</p>
<ul>
<li><p>读者角度</p>
<ul>
<li>那些让你头疼的字</li>
</ul>
</li>
<li><p>作者角度</p>
<ul>
<li>1.作者强调的某些字,比如进行加粗、斜体、下划线等处理的字，或者某些特殊领域的专门用语</li>
<li>2.本书作者和其他作者产生歧义的字就是关键字</li>
</ul>
</li>
<li><p>片语</p>
</li>
</ul>
</li>
<li><p>如何确定字义</p>
<ul>
<li>1.确定这个字是有一个还是多重含义</li>
<li>2.如果是多重含义，那么这些含义之间有何关联？</li>
<li>3.结合文章上下文，判断每次出现这个字时的含义</li>
</ul>
</li>
</ul>
</li>
<li><p>6.从重要的句子中抓出作者想要表达的主旨</p>
<ul>
<li><p>句子和主旨的关系（语言和思想的关系）</p>
<ul>
<li><p>句子和段落</p>
<ul>
<li>句子和段落是文法的单位、语言的单位</li>
</ul>
</li>
<li><p>主旨和论述</p>
<ul>
<li>主旨和论述是逻辑的单位，也就是思想和知识的单位</li>
</ul>
</li>
</ul>
</li>
<li><p>规则6细分</p>
<ul>
<li><p>第一部分：找出关键句</p>
<ul>
<li>从作者的角度来说，最重要的句子就是在论述的过程中标明作者判断的部分，有些作者会在这样的句子下面划线标注，也有少数的书会将主旨写在开头</li>
<li>从读者角度来说，那些难以理解的句子就是含有重要主旨的部分</li>
</ul>
</li>
<li><p>第二部分：找出句子中的主旨（你必须要知道句子在说什么）</p>
<ul>
<li><p>文字表达的意思和句子诠释的主旨之间的差异</p>
<ul>
<li>1.主旨所牵涉的内容比文字表达的意思多</li>
<li>2.复杂的句子通常要说明的不止一个主旨。</li>
</ul>
</li>
<li><p>如何检测读者找到了主旨</p>
<ul>
<li><p>用自己的话来说</p>
<ul>
<li>如果要求读者对某个重要句子做出解释，而读者只是重复作者的话，或者是在前后顺序上做一些小调整，那么读者最好是怀疑一下自己是否真的理解了这句话中所包含的主旨！</li>
</ul>
</li>
<li><p>举出一个读者经历的主旨内容描述的经验</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>7.找出作者的论述,重新架构这些论述的前因后果,以明白作者的主张</p>
<ul>
<li><p>如何找出一本书中的论述</p>
<ul>
<li><p>1.所有的论述中都包含了一些声明</p>
<ul>
<li><p>其中有些声明是读者为什么要接受作者这个论述的理由</p>
<ul>
<li>先找到结论，就去看看理由是什么</li>
<li>先找到理由，去看看这个理由会把你带到一个什么样的结论上去</li>
</ul>
</li>
</ul>
</li>
<li><p>2.两种论述的不同之处</p>
<ul>
<li><p>归纳法和演绎法的区别</p>
<ul>
<li>归纳法：以一个或者多个共同的事实来证明某个共同的概念</li>
<li>演绎法;以一连串的通则来证明更进一步的共通的概念</li>
</ul>
</li>
</ul>
</li>
<li><p>3.找出作者认为哪些事情是假设的,哪些事情是有根据的或者是能证明的,哪些是不需要证明的自明之理.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>8.确定作者已经解决了哪些问题,还要哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。</p>
</li>
<li><p>智慧礼节的一般规则</p>
<ul>
<li><p>9.除非你已经完成大纲架构，可以完整的诠释一本书的内容了，否则不要轻易批评。（在你说出你懂了之前，不要说你同意、不同意或者是暂缓评论）</p>
<ul>
<li><p>一般思维性的礼节</p>
<ul>
<li><p>1.受教的美德</p>
<ul>
<li>1.没有一本书会好到无懈可击</li>
<li>2.如果一本书可以启发读者，那么说明作者的水平是高于读者的，除非读者是完全了解了这本书，否则是不应该提出批评的。等到读者打到和作者相同的水平，那么读者应该运用自己的批评的才能，否则对作者来说是不公平的。因为作者已经完成了他的工作—让读者和自己齐头并进，那么读者应该也要变现的像一个同辈一样和作者进行对话。</li>
</ul>
</li>
<li><p>2.修辞的作用</p>
<ul>
<li><p>广义上来讲，修辞和人类的任何一种沟通都有关系的；在沟通的过程中，我们不仅希望别人能来了解我们，同样也希望别人能同意我们的话</p>
<ul>
<li>从发言者角度：如果沟通的目的是认真的，我们希望能说服或者劝导对方—更准确的说，说服对方接受我们的理论，劝导对方最终受到我们的行为和理论的影响。</li>
<li>从倾听者角度：如果接收者一方也同样认真，那就不但应该有回应，还要做一个负责的倾听者；你对自己所听到的要有回应，还要注意对方背后的意图；同时你还要有自己的主见；如果倾听者不靠自己，只靠讲述者为自己做出判断，那你就是在做奴隶，不是自由的人了！</li>
</ul>
</li>
</ul>
</li>
<li><p>3.暂缓评论的重要性</p>
<ul>
<li>原则;除非你听清楚了,或者说你了解了,否则不要回话</li>
<li>在分析阅读的第三阶段中,除非读者很满意自己完成的分析阅读的前两个阶段,否则难以自由的表达观点;也只有完成了前两个阶段,读者才能有权利去批评,同样也有义务这么做!</li>
<li>在你说出”我同意”或者“我反对”或者“我暂缓评论”前，请一定要能肯定的说“我了解了”！</li>
<li>请坦诚的说出“我不懂“—其中并没有错在读者身上的可能<br>也请小心的说出”我懂了“—慢慢地举起你评论的长矛</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>10.不要争强好胜，非辩到底不可</p>
<ul>
<li>作者忠告:大多数人以赢得辩论为目标,却没想到要学习的是真理</li>
<li>把谈话当作是战争的人，要赢得战争就得为反对而反对，不论自己对错，都要反对成功。抱持着这种心态来阅读的人，只是想在书中找出反对的地方而已</li>
</ul>
</li>
<li><p>11.在说出自己的观点前，读者要能区别的出真正的知识和个人观点的不同</p>
</li>
</ul>
</li>
<li><p>批评观点的特别标准</p>
<ul>
<li>12.证明作者的知识不足</li>
<li>13.证明作者的知识错误</li>
<li>14.证明作者不合逻辑</li>
<li>15.证明作者的分析和理由是不完整的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><ul>
<li><p>最复杂最系统化的阅读，也称为比较阅读；在进行主题阅读的时候，读者通常会阅读主题相关的多本书籍，并且列举出这些书籍的相关之处。</p>
</li>
<li><p>主题阅读和检视阅读、分析阅读的关系</p>
<ul>
<li><p>复习1、检视阅读中的两个步骤</p>
<ul>
<li>浏览：读的是什么主题，能说明这是什么样的书，并拟出大纲架构</li>
<li>粗浅地阅读：能够与作者达<br>成共识，说明他的主旨，跟随他的论述，才能够诠释整本书的内容</li>
</ul>
</li>
<li><p>分析阅读的困难之处：同一个主题几百本书，不可能全部读完，只需要选择关键的书进行分析阅读</p>
</li>
<li><p>子主题 2</p>
</li>
</ul>
</li>
<li><p>主题阅读和分析阅读之间的误区：一旦你检视过，确定某些书跟你研究的主题相关后，你就可以开始做主题阅读了。要注意的是，我<br>们并没有像你以为的说：“开始做分析阅读”。当然，你需要研读每一本书，再组合起跟你主题相关的资<br>料，你在做分析阅读时就已经学会了这些技巧。但是绝不要忘了，分析阅读的技巧只适用于单一的作品，<br>主要的目标是要了解这本书。而我们会看到，主题阅读的目标却大不相同。</p>
</li>
<li><p>主题阅读的五个步骤：</p>
<ul>
<li><p>主题阅读步骤一：找到相关的章节</p>
<ul>
<li>当然，我们假设你已经学会分析阅读了，如果你愿意，你能把所有相关的书都看透彻了。但是你可能会把阅读单本的书放在第一顺位，而把自己的主题放在其次。事实上，这个顺序应该颠倒过来，在主题阅读中，你及你关心的主题才是基本的重点，而不是你阅读的书。</li>
<li>在你已经确定哪些书是相关的之后，主题阅读的第一个步骤就是把这些书整体检视阅读一遍。你的目标是找出书中与你的主题极为相关的章节。你选择的书不太可能全本都与你的主题或问题相关。就算<br>是如此，也一定是少数，你应该很快地把这本书读完。你不该忘了，你的阅读是别有用心的—也就是说，<br>你是为了要解决自己的问题才阅读—而不是为了这本书本身的目的而阅读。</li>
</ul>
</li>
<li><p>主题阅读步骤二：带引作者与你达成共识。</p>
<ul>
<li><p>真正的困难在于要强迫作者使用你的语言，而不是使<br>用他的语言</p>
<ul>
<li>拒绝接受某一位作者的词汇，避免与某位作者词汇相同的情况；要建立一组词汇，首先帮助我们了解所有的作者，而不是其中<br>一两个作者；其次帮助我们解决我们的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>主题阅读步骤三：厘清问题</p>
<ul>
<li><p>根据步骤二建立词汇，然后建立读者的主旨，并且提出一些问题，由某些作者来回答这个问题；</p>
<ul>
<li>有的时候没有作者能回答读者问题；</li>
</ul>
</li>
</ul>
</li>
<li><p>主题阅读步骤四：界定议题</p>
<ul>
<li>如果一个问题很清楚，如果我们也确定各个作者会用不同的方式来回答—不论赞成或反对—那么这个议题就被定义出来了。这是介于用这种方法回答问题的作者，和用另外一种（可能是相反的）方法来回答问题的作者之间的议题。</li>
<li>当两个作者对同一个问题有相当的了解，所作的回答却完全相反或矛盾时，这才是一个真正有参与的议题</li>
</ul>
</li>
<li><p>主题阅读步骤五：分析讨论。</p>
<ul>
<li>事实上，我们所做的可能超过这些。对一个问题完整地分析过后，将来其他人对同一个问题要作研究时，我们的分析讨论就会提供他一个很好的研究基础。那会清除一些障碍，理出一条路，让一个原创性的思考者能突破困境。如果没有这个分析的工作，就没法做到这一点，因为这个问题的各个层面就无法显现出来。</li>
</ul>
</li>
</ul>
</li>
<li><p>主题阅读所追求的这种特质，可以用这句话来作总结：“辩证的客观。”主题阅读就是要能面面俱到，而自己并不预设立场</p>
</li>
<li><p>主题阅读中的矛盾问题</p>
<ul>
<li>除非你知道要读些什么书，你没法使用主题阅读。但是除非你能做主题阅读，否则你不知道该读些什么书。换句话说，这可以算是主题阅读中的根本问题。也就是说，如果你不知道从何开始，你就没法做主题阅读。就算你对如何开始有粗浅的概念，你花在寻找相关书籍与篇章的时间，远超过其他步骤所需时间的总和</li>
</ul>
</li>
<li><p>主题工具书</p>
<ul>
<li>启动阅读，建议阅读．指导阅读<br>《 西 方 世 界 的 经 典 名<br>著》(GreatBooksoftheWesternWorld）</li>
</ul>
</li>
<li><p>主题阅读精华摘要：<br>一、观察研究范围：主题阅读的准备阶段<br> (1)针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书<br>目索引。<br>(2)浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。<br>二、主题阅读：阅读所有第一阶段收集到的书籍<br>(1)浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。<br>(2)根据主题创造出一套中立的词汇，带引作者与你达成共识—无论作者是否实际用到这些词汇，所<br>有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。<br>(3)建立一个中立的主旨，列出一连串的问题—无论作者是否明白谈过这些问题，所有的作者，或者<br>至少大多数的作者都要能解读为针对这些问题提供了他们的回答。<br>(4)界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记<br>住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范<br>围的事情，把他的观点解读，才能建构出这种议题。<br>(5)分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比<br>较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。注意：理想上，要一直保持对话<br>式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中<br>引一段话来并列。</p>
</li>
</ul>
<h2 id="如何提升读者的自我要求"><a href="#如何提升读者的自我要求" class="headerlink" title="如何提升读者的自我要求"></a>如何提升读者的自我要求</h2><h3 id="好句推荐"><a href="#好句推荐" class="headerlink" title="好句推荐"></a>好句推荐</h3><ul>
<li>弗兰西斯.培根：有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是需要咀嚼和消化的。</li>
<li>在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于理解和满足</li>
<li>一个人如果说他知道自己在想些什么，但是又说不出来，通常是他其实并不知道自己在想什么</li>
<li>你必须要读出言外之意，才会有更大的收货。</li>
<li>一个人只要学习过一个复杂的技巧，就会知道要学习一项新技巧，一开始的复杂过程是不足为惧的。</li>
<li>读的很好这句话，我们生活中通常是用来衡量一个读者读的量，而不是质，不得不承认，生活中的大多数情况下都是这样</li>
<li>一个读的很广泛，却读不精的人，与其值得赞美，不如值得同情</li>
<li>霍布斯：如果我想一个一般人一样多那么多书，我就跟他们一样愚蠢了。</li>
</ul>
<h3 id="主动阅读的四个基础"><a href="#主动阅读的四个基础" class="headerlink" title="主动阅读的四个基础"></a>主动阅读的四个基础</h3><ul>
<li><p>主动阅读过程中应该提出的四个问题</p>
<ul>
<li><p>1.整体来说，这本书在谈什么？</p>
<ul>
<li>找出这本书的主题，作者如何一次发展这个主题的，如何逐步从核心议题分解出关键的从属议题来的？</li>
</ul>
</li>
<li><p>2.作者细说了什么，怎么说的？</p>
<ul>
<li>找出主要的想法、声明和论点，这些内容组成作者想要穿达的主要信息。</li>
</ul>
</li>
<li><p>3.这本书说的有道理吗？</p>
<ul>
<li>是部分有道理还是全部有道理？</li>
</ul>
</li>
<li><p>4.这本书和读者有什么关系？</p>
<ul>
<li>如果一本书给了读者一些资讯，那么一定要反问一下这些资讯对读者有什么意义？为什么作者认为这件事对读者很重要？读者有必要去了解吗？有没有给读者一些其他的启示？</li>
</ul>
</li>
</ul>
</li>
<li><p>作为一个有自我要求的阅读者，要学会在阅读的过程中提出各种各样的问题，其中以上面四个最为重要。只有可以完整的回答上面的四个问题，我们进行的检视阅读才算是功德圆满。</p>
<ul>
<li>在阅读的过程中，读者要养成提出问题的习惯，并且精准、正确的回答这些问题。</li>
</ul>
</li>
</ul>
<h3 id="如何让一本书属于自己"><a href="#如何让一本书属于自己" class="headerlink" title="如何让一本书属于自己"></a>如何让一本书属于自己</h3><ul>
<li><p>在书上做笔记</p>
<ul>
<li><p>好处</p>
<ul>
<li>1.保持十分清醒，集中注意力</li>
<li>2.主动阅读也是一种思考，既然是思考，我们就应该可以表达出来，不管是用写的还是说的。</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>1.画底线</p>
<ul>
<li>主要的重点、重要切有力的句子</li>
</ul>
</li>
<li><p>2.底线栏外再画一条线</p>
<ul>
<li>着重强调1的重要性，并且避免底线过长。</li>
</ul>
</li>
<li><p>3.空白处画星号或其他符号</p>
<ul>
<li>标记书中少数十分重要的声明或者段落；还可以折角加以标记。慎用！</li>
</ul>
</li>
<li><p>4.空白处编号</p>
<ul>
<li>作者的某个重要论点发展出来的一系列重要论述。</li>
</ul>
</li>
<li><p>5.空白处记下其他的页码</p>
<ul>
<li>标记作者在书中其他位置相同相似的论点甚至是相反的论点；这样可以让全书散落的想法统一起来。CF(参照或者比较)</li>
</ul>
</li>
<li><p>6.关键字或句子圈出来</p>
<ul>
<li>作用同1</li>
</ul>
</li>
<li><p>7.书页中的空白处做笔记</p>
<ul>
<li>1.记录读者的一些问题或者答案</li>
<li>2.将复杂的论点简化说明</li>
<li>3.记录全书主要论点的发展顺序</li>
<li>4.书中最后一页作为读者索引,依序记录作者主要观点</li>
</ul>
</li>
<li><p>8.在最后一页写下读者索引,在第一页写下本书大纲,写出本书整体架构,列出基本大纲和前后篇章次序</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三种笔记</p>
<ul>
<li><p>结构笔记</p>
<ul>
<li><p>检视阅读的三个问题</p>
<ul>
<li>这是一本什么样的书</li>
<li>整本书在谈什么</li>
<li>作者借着什么样的架构,来发展他的观点或者陈述他对这个主题的理解</li>
</ul>
</li>
<li><p>笔记的重点是全书的结构,而不是内容,至少不是细节</p>
</li>
</ul>
</li>
<li><p>概念笔记</p>
<ul>
<li><p>什么是概念笔记</p>
<ul>
<li>概念既是作者的观点,在我们进行检视阅读的时候,读者也许可以掌握作者所要表达的一些观点。但是对这些观点的准确性和意义，我们需要在分析阅读中去寻找答案。当读者阅读的深度和广度增加之后，自然也会出现自己的观点。</li>
</ul>
</li>
<li><p>另一种概念笔记</p>
<ul>
<li>在我们进行主题阅读的时候，我们会阅读主题相关的多本书籍，这个时候的笔记应该也是概念笔记。只是这个时候我们在书中空白页处记下 的页码不再是本书的，也有些是其他书中的。</li>
</ul>
</li>
</ul>
</li>
<li><p>辩证笔记</p>
</li>
</ul>
</li>
</ul>
<h3 id="辅助阅读"><a href="#辅助阅读" class="headerlink" title="辅助阅读"></a>辅助阅读</h3><ul>
<li><p>内在阅读</p>
<ul>
<li>指的是阅读书籍本身，与其他的书籍是无关的</li>
</ul>
</li>
<li><p>外在阅读</p>
<ul>
<li><p>借助其他书籍来阅读一本书</p>
</li>
<li><p>外在阅读的不利影响</p>
<ul>
<li>1.在我们理解和批评一本书的过程中，内在阅读和外在阅读容易混淆；在批评、诠释和做大纲的过程中，难免会受经验主义的影响；</li>
<li>2.有些读者过于依赖外在阅读；在我们拿到一本书的时候，我们的第一目标是培养我们的独立的阅读思考的习惯，而不是借助外在阅读的帮助。</li>
</ul>
</li>
<li><p>外在辅助的来源</p>
<ul>
<li><p>1.相关经验</p>
<ul>
<li>问：读者如何适当的使用自己的经验，来帮助自己读懂一本书？</li>
<li>答：读者应该问问自己，在读者自己自认为了解了的某个点上，能不能举出一个实例来。</li>
</ul>
</li>
<li><p>2.其他的书</p>
<ul>
<li>这一部分的工作在后面的主题阅读中运用的非常多</li>
<li>许多伟大的作品不只是互相之间有关联，而且写作时还有先后顺序；</li>
</ul>
</li>
<li><p>3.导论和摘要</p>
<ul>
<li><p>要求：要聪明的使用导论和摘要这种外在辅助阅读，也就是尽量少用。</p>
</li>
<li><p>原因：</p>
<ul>
<li>1.一本书的导读不一定都是对的</li>
<li>2.即使一本书的导读都是对的，也可能不全面；过于依赖导读和摘要，可能会限制读者对于书籍的理解。</li>
<li>3.过度使用导读和摘要会让读者养成不良的阅读习惯，这对于主动阅读者来说并不友好。</li>
</ul>
</li>
<li><p>导论和摘要的正确打开方式</p>
<ul>
<li>1.摘要和导论可以唤醒读者对于一本书的记忆；这样的摘要，读者在进行检视阅读的时候就应该完成。</li>
<li>2.摘要和导论在读者进行主题阅读的时候，能够帮助读者快速确认某些议题是否和读者的阅读主题紧密相关；摘要不可以代替真正的阅读，但是却可以告诉读者，想不想或者需不需要读这本书。</li>
</ul>
</li>
</ul>
</li>
<li><p>4.工具书</p>
<ul>
<li><p>使用工具书的四个基本知识</p>
<ul>
<li>1.读者想要知道什么？就是读者要清楚的知道自己的问题是什么。</li>
<li>2.读者要知道在哪里可以找自己想要的问题答案。读者要知道自己的问题是哪一类的问题，而又在哪一类的工具书中可以找到答案。</li>
<li>3.读者必须知道对应的工具书的内容是如何组织的。</li>
<li>4.读者必须知道自己想要找的是什么，在哪一种工具书中可以找到这些内容。</li>
</ul>
</li>
<li><p>工具书使用举例</p>
<ul>
<li><p>字典</p>
<ul>
<li><p>对于字典文字的四个认识</p>
<ul>
<li>1.文字是物质的——可以写成字，也可以发出声音</li>
<li>2.文字是语言的一部分——文字有多重用法，在不同的情境中有不同的意义</li>
<li>3.文字是符号的——这些符号有一种甚至多重意义</li>
<li>4.文字是约定俗成的——每个文字都有自己的演化历史，</li>
</ul>
</li>
<li><p>字典是关于文字的</p>
</li>
</ul>
</li>
<li><p>百科全书</p>
<ul>
<li><p>对于百科全书事实的四个认识</p>
<ul>
<li>事实是一种说法，说明一种事实的时候，会用一组文字来表达；</li>
<li>事实是一种真实的说法，而不是观点；</li>
<li>事实是真相的反应：1.事实可能是一个资讯；2.不受怀疑的推论</li>
<li>事实是某种程度上的约定俗成，但是这种约定俗成的事实也具有一定的时代局限性，即每个时代的事实可能存在差异</li>
</ul>
</li>
<li><p>百科全书是关于事实的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="阅读不同读物的通用方法"><a href="#阅读不同读物的通用方法" class="headerlink" title="阅读不同读物的通用方法"></a>阅读不同读物的通用方法</h2><h3 id="实用性书籍"><a href="#实用性书籍" class="headerlink" title="实用性书籍"></a>实用性书籍</h3><ul>
<li><p>是什么是实用性书籍</p>
<ul>
<li>包含了规则——原理和准则或者任何一种一般性指导的书籍</li>
</ul>
</li>
<li><p>实用性书籍分类</p>
<ul>
<li>说明规则，例如本书，或者一些驾驶指南和烹饪书籍</li>
<li>说明规则形成的原理，经济、政治和一些道德著作</li>
</ul>
</li>
<li><p>实用性书籍的正确打开方式：</p>
<ul>
<li>读出书中的言外之意，找出那些实用原理衍生出来的规则，并且找出这种衍生规则如何进行实用。<br>如果一本实用的书没有被“实用的阅读”，那么就是失败的阅读。<br>这也是评价一个实用性书籍的最高准则1</li>
</ul>
</li>
<li><p>现实的真理和理论的真理</p>
<ul>
<li>如果我们根据实用性书籍中的规则培养出的行为规则,他满足下面两个要求:1.真的有效;2.引导你到达正确的结果,满足你的期望.就可以称这个行为准则是真理,也就是现实的真理.</li>
</ul>
</li>
<li><p>实用性书籍阅读的两个问题线索</p>
<ul>
<li>作者的目的是什么?</li>
<li>他建议用什么办法达到这个目的?</li>
</ul>
</li>
<li><p>实用性书籍阅读的四大问题:</p>
<ul>
<li><p>这本书在谈什么?</p>
<ul>
<li><p>列出这本实用性(论说性书籍的一种)的大纲</p>
</li>
<li><p>作者的目的是什么?</p>
<ul>
<li>读者一定要搞清楚作者想要干什么,因为作者想干的就是作者想让读者去干的,所以这个非常重要!</li>
</ul>
</li>
</ul>
</li>
<li><p>作者想让读者做什么?作者想让读者这样做的目的是什么?</p>
<ul>
<li>为了做到这一点,读者也需要找出这本书的内容和含义,需要列出这本书中作者的共识、主旨和论述</li>
</ul>
</li>
<li><p>内容真实吗？</p>
<ul>
<li>读者能否接受作者的宗旨——作者的终极目标</li>
<li>读者能否接受作者介绍的达成终极目标的方法——这取决于读者理解到的终极目标的内容和合适的达到目标的方法</li>
</ul>
</li>
<li><p>这和读者有何关系?</p>
<ul>
<li>对比理论性的书籍，对读者产生的影响是可能改变读者对某些事物的看法，但是实用性的书籍对读者产生的影响是需要读者去采取行动的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="想象文学"><a href="#想象文学" class="headerlink" title="想象文学"></a>想象文学</h3><ul>
<li><p>想象文学阅读建议的讨论路线</p>
<ul>
<li>从否定的说法谈起，而不是建立一些规则</li>
<li>用类推的方法，简短的将阅读非小说的规则类推到阅读小说的规则</li>
<li>讨论阅读特殊形态的想象文学作品时发生的问题，比如小说、戏剧和抒情诗</li>
</ul>
</li>
<li><p>阅读想象文学的建议：</p>
<ul>
<li>不要抗拒想象文学带给读者们的影响力</li>
<li>在想象文学中，不要试图去寻找书中的共识、主旨或者论述</li>
<li>不要用适用于传递知识的、与真理一直的标准去批评小说</li>
</ul>
</li>
<li><p>阅读想象文学的一般规则：</p>
<ul>
<li><p>读者必须将想象文学进行分类</p>
<ul>
<li>比如抒情诗，主要是表达作者个人情绪的经验</li>
</ul>
</li>
<li><p>读者要能抓住一本书的大意</p>
<ul>
<li>主要是看读者能不能用几句简短的话来说明整本书的大意</li>
</ul>
</li>
<li><p>不仅要能将整本书简化成大意，还要能发现整本书中的各个部分是如何架构起来的</p>
</li>
</ul>
</li>
<li><p>想象文学的批评规则</p>
<ul>
<li>在读者由衷的感谢作者给自己创造出的全新体验之前，不要轻易批评一部想象作品</li>
</ul>
</li>
</ul>
<h3 id="故事、戏剧和诗"><a href="#故事、戏剧和诗" class="headerlink" title="故事、戏剧和诗"></a>故事、戏剧和诗</h3><ul>
<li><p>如何阅读故事书</p>
<ul>
<li><p>快速、并且全心全意的去读</p>
<ul>
<li><p>对于读者的要求：将阅读一本故事书的时间压缩到合理的长度</p>
<ul>
<li>原因：读者时间有限</li>
<li>原因：时间拖的太久，会忘记相关的情节和人物</li>
</ul>
</li>
</ul>
</li>
<li><p>相信作品中的事情，不要有任何的怀疑和疑惑</p>
</li>
<li><p>在完成阅读之后，对整本书进行一个回顾，厘清其中的事件的关联和活动的前后顺序</p>
</li>
</ul>
</li>
<li><p>如何阅读戏剧</p>
<ul>
<li><p>如何阅读史诗</p>
<ul>
<li>集中注意力，全心全力的参与并充分利用想象力</li>
</ul>
</li>
<li><p>如何阅读戏剧（剧本）</p>
<ul>
<li>1.将剧本搬上心灵的舞台进行演出</li>
<li>2.阅读戏剧和剧本时要一气呵成，才能掌握整体的感受</li>
</ul>
</li>
<li><p>关于如何阅读悲剧</p>
<ul>
<li>1.悲剧的精髓是在时间，或者说是缺乏时间</li>
</ul>
</li>
</ul>
</li>
<li><p>如何阅读抒情诗</p>
<ul>
<li>1.无论读者懂不懂，都要一口气读完，不要暂停</li>
<li>2.重读一遍，并且大声的朗读出来，用耳朵和声音重新去体会诗歌中的韵味</li>
<li>3.了解诗歌的作者和相对应的时代背景</li>
</ul>
</li>
</ul>
<h3 id="历史书籍"><a href="#历史书籍" class="headerlink" title="历史书籍"></a>历史书籍</h3><ul>
<li><p>阅读历史书籍的两个要点;</p>
<ul>
<li>1.对你感兴趣的历史或者时期，尽可能阅读一种以上的历史书籍</li>
<li>2.阅读历史时，不止要关心过去某个时间、地点真正发生了什么事情，还要读懂在任何时空之中，尤其是现在，人们为什么采取这种行动的原因</li>
</ul>
</li>
<li><p>阅读历史书籍要提出的问题：</p>
<ul>
<li><p>1.每本历史书都有一个特殊并且范围限定的主题</p>
<ul>
<li>读者需要弄清楚这本历史书籍谈到了什么，同样也需要知道作者没有谈到的是什么</li>
</ul>
</li>
<li><p>2.每本历史书都是在说特定时间内的一个故事</p>
<ul>
<li>1.作者是用什么方法来这个故事的？</li>
<li>2.作者依据什么将整本书划分为不同的章节？年代、时期还是世代？还是其他的规则来划分章节的</li>
<li>3.作者是不是在这一章节中谈那个时期的经济，然后在另外的章节中谈战争、宗教运动和文学作品的产生？这些内容哪个对作者来说最重要？</li>
</ul>
</li>
</ul>
</li>
<li><p>如何阅读传记和自传</p>
<ul>
<li><p>一种特别的历史书籍</p>
</li>
<li><p>如何阅读</p>
<ul>
<li>尽可能去阅读你能找到的资料，包括他对自己一生的描述（如果他写过）</li>
<li>对于任何自传都要有一点怀疑心，同时别忘了，在你还不了解一本书之前，不要妄下论断。至于“这本书与我何干？’’这个问题，我们只能说：传记，就跟历史一样，可能会导引出某个实际的、良心的行动。传记是有启发性的。那是生命的故事，通常是成功者一生的故事—也可以当作我们生活的指引</li>
</ul>
</li>
</ul>
</li>
<li><p>阅读当前事件</p>
<ul>
<li><p>阅读当前事件的几个问题</p>
<ul>
<li><p>(1)这个作者想要证明什么</p>
</li>
<li><p>(2）他想要说服谁</p>
</li>
<li><p>(3)他具有的特殊知识是什么？</p>
</li>
<li><p>(4）他使用的特殊语言是什么？</p>
</li>
<li><p>(5)他真的知道自己在说些什么吗？</p>
<ul>
<li>作者真的知道事实吗？是否知道被报导的人物私下的思想与决定？他有足够的知识以写出一篇公平客观的报导吗？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>阅读文摘的注意事项</p>
<ul>
<li>最好的文章，就像最好的书一样，是不可能经过浓缩而没有遗珠之憾的；在这样的情况下，浓缩的惟一功能就是激励我们去阅读原著</li>
<li>至于一般的作品，浓缩是可行的，而且通常要比原著还好。因为一般的文字主要都是与资讯有关的</li>
</ul>
</li>
</ul>
<h3 id="数学和科学"><a href="#数学和科学" class="headerlink" title="数学和科学"></a>数学和科学</h3><ul>
<li><p>两种形式的书</p>
<ul>
<li>伟大的科学和数学的经典之作</li>
<li>现在科普著作</li>
</ul>
</li>
<li><p>分析阅读的规则使用于科学与数学的作品的阅读</p>
</li>
<li><p>阅读科学经典著作的目的：了解科学的历史和哲学，而并不是成为这一领域的专家</p>
</li>
<li><p>阅读科学作品的两个主要问题：</p>
<ul>
<li><p>1.关于论述的问题：科学中的两种论述方式分别是归纳法和演绎法；关于这一点的问题来源是：为了了解归纳法中的某些论点，读者必须了解作者引用为理论基础的证据！</p>
</li>
<li><p>2.关于数学的问题：如何克服阅读科学著作是绵中的数学问题？</p>
<ul>
<li><p>1.把读者想象的基础程度的数学读的更明白</p>
<ul>
<li>1.欧几里得：《几何原理》；克服对数学的恐惧心理</li>
<li>2.阿基米德</li>
<li>3.阿波罗乌尼斯</li>
<li>4.尼科马科斯</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h3><ul>
<li><p>哲学的两个领域</p>
<ul>
<li><p>存在与变化的问题</p>
<ul>
<li>这个类型的问题是理论和思辨性的问题</li>
</ul>
</li>
<li><p>好与坏、善与恶的问题</p>
<ul>
<li>这个类型属于哲学中实用类型的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>哲学书籍的终极目标：过好生活、或者是组织号一个社会</p>
</li>
<li><p>哲学的五种论述风格：</p>
<ul>
<li>哲学对话：柏拉图《对话录》</li>
<li>哲学论文或者散文：《物理学》、《形上学》、《伦理学》等</li>
<li>面对异议：圣托马斯.阿奎那《神学大全》</li>
<li>哲学系统化：斯宾诺莎《伦理学》</li>
<li>格言形式：尼采《查拉图斯特拉如是说》</li>
</ul>
</li>
<li><p>阅读哲学书籍的注意事项：</p>
<ul>
<li><p>1、关注作者的词义和关键主旨</p>
</li>
<li><p>2、关注作者的归纳性总结</p>
</li>
<li><p>3、关注作者对于事物本质的解说，而不是关注那些对于事物本质的描写</p>
<ul>
<li>子主题 1</li>
</ul>
</li>
<li><p>4、厘清读者的思绪：</p>
<ul>
<li><p>这里要避免的两个问题：</p>
<ul>
<li>1、如何多个哲学家意见不合，那么这些问题不应该成为读者的困扰之处，他可能只是提出来了一个一直没有得到解决的重大问题；</li>
<li>2、哲学家的意见不合并不重要，关键是读者要厘清自己的思路，关注关键问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关于神学的重点：</p>
<ul>
<li>1：神学分为自然升学和教义神学，自然神学是哲学的一个分支，是形而上学的最后一部分；教义神学的关键是某个教派的所信奉的经文。</li>
<li>2、经书的阅读心态，读者不应该将它当做文学作品，而是当做神的话语。</li>
</ul>
</li>
</ul>
<h3 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h3><ul>
<li><p>什么是社会科学：</p>
<ul>
<li>社会科学的核心：人类学、经济学、政治学和社会学；周边学科包括法律、教育、公共行政和商业、社会服务的学科，最后加上大量的心理学作品</li>
</ul>
</li>
<li><p>阅读社会科学的容易之处：通常取材于读者熟悉的经验，论述的方式通常是叙述</p>
</li>
<li><p>阅读社会科学的难处：</p>
<ul>
<li>1、当读者投入时间去阅读社会科学作品的时候，一旦发现自己和作者观点不合，读者就会出现投入不忠的心理状态</li>
<li>2、社会科学中熟悉的术语和观点，也会成为阅读的障碍；某些特定术语有严格的使用限制，不知其所以然的情况下阅读相关作品会对读者造成困扰；</li>
<li>3、社会科学领域的作品混杂，而不是纯粹的论说性作品</li>
</ul>
</li>
<li><p>如何阅读社会科学：社会科学需要我们就某一个关键问题阅读相关的多本书籍，这就需要读者进行主题阅读，也就是我们要讨论的第四个阅读方式。</p>
</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/10/11/Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80---shell%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%AF%87/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/linux.png" alt="Linux 命令行学习篇一 shell基础和工具篇"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2021-10-11  <a class="commentCountImg" href="/2021/10/11/Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80---shell%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%AF%87/#comment-container"><span class="display-none-class">9e24e88c257de6f585bbc46effd1ab3d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="9e24e88c257de6f585bbc46effd1ab3d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>12 分钟  <i class="fas fa-pencil-alt"> </i>1.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/11/Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80---shell%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%AF%87/">Linux 命令行学习篇一 shell基础和工具篇</a></h1><div class="content"><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h4 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h4><p>一句话解释:shell是用户对Linux/Unix操作系统和内核进行操作和管理的工具</p>
<p>Linux/Unix操作系统的核心是内核,内核的主要任务是任务调度、内存管理和硬件控制，而shell是用户与Linux/Unix内核之间的一个沟通的桥梁。</p>
<h4 id="shell发展史"><a href="#shell发展史" class="headerlink" title="shell发展史"></a>shell发展史</h4><ol>
<li>世界上第一款shell叫做Thompson shell，诞生于1971年，1975年开始广泛传播使用。它的一个别名是V6 shell</li>
<li>Thompson shell的作者是Thompson,Tompson shell 诞生于他在贝尔实验室工作期间.Thomspon后期开发Unix操作系统.</li>
</ol>
<h4 id="shell种类"><a href="#shell种类" class="headerlink" title="shell种类"></a>shell种类</h4><table>
<thead>
<tr>
<th>名称</th>
<th>全称</th>
<th>诞生于</th>
<th>流行于</th>
</tr>
</thead>
<tbody><tr>
<td>sh</td>
<td>Bourne Shell</td>
<td>1977</td>
<td>Unix</td>
</tr>
<tr>
<td>(t)csh</td>
<td>C Shell</td>
<td>1978</td>
<td>Unix</td>
</tr>
<tr>
<td>ksh</td>
<td>Kron Shell</td>
<td>1983</td>
<td>Unix</td>
</tr>
<tr>
<td>bash</td>
<td>Bourne  Again shell</td>
<td>1989</td>
<td>Linux</td>
</tr>
<tr>
<td>zsh</td>
<td>Zhong Shao Shell</td>
<td>1990</td>
<td>Linux</td>
</tr>
<tr>
<td>dash</td>
<td>Debian Almquist Shell</td>
<td>2002</td>
<td>Linux</td>
</tr>
</tbody></table>
<p>也有其他的一些小众的shell,例如pdksh、psh和mksh等。</p>
<h4 id="如何查看当前系统安装的shell（以CentOS为例）"><a href="#如何查看当前系统安装的shell（以CentOS为例）" class="headerlink" title="如何查看当前系统安装的shell（以CentOS为例）"></a>如何查看当前系统安装的shell（以CentOS为例）</h4><h5 id="cat-etc-shells"><a href="#cat-etc-shells" class="headerlink" title="cat /etc/shells"></a>cat /etc/shells</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# cat /etc/shells </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<p>补充命令:如何查看系统版本信息(以CentOS为例)</p>
<ol>
<li><p>电脑及操作系统相关信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# uname -a</span><br><span class="line">Linux cnhzldvcmpl67 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure></li>
<li><p>正在运行的内核版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# cat /proc/version </span><br><span class="line">Linux version 3.10.0-957.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Thu Nov 8 23:39:32 UTC 2018</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure></li>
<li><p>发行版本信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# cat /etc/issue</span><br><span class="line">\S</span><br><span class="line">Kernel \r on an \m</span><br><span class="line"></span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<p>这里有个问题,输出和预期不一致!!!</p>
</li>
</ol>
<h4 id="查看、安装、切换其他类型shell"><a href="#查看、安装、切换其他类型shell" class="headerlink" title="查看、安装、切换其他类型shell"></a>查看、安装、切换其他类型shell</h4><h5 id="查看当前使用的shell"><a href="#查看当前使用的shell" class="headerlink" title="查看当前使用的shell"></a>查看当前使用的shell</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<h5 id="安装-以zsh为例"><a href="#安装-以zsh为例" class="headerlink" title="安装(以zsh为例)"></a>安装(以zsh为例)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# yum install zsh</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">ECI-base-CentOS-7.6                                                                                                                             | 3.6 kB  00:00:00     </span><br><span class="line">ECI-puppet6-rhel7                                                                                                                               | 2.9 kB  00:00:00     </span><br><span class="line">ECI-updates-CentOS-7.4                                                                                                                          | 2.9 kB  00:00:00     </span><br><span class="line">ECI-updates-CentOS-7.6                                                                                                                          | 3.4 kB  00:00:00     </span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package zsh.x86_64 0:5.0.2-31.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Finished Dependency Resolution</span></span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">=======================================================================================================================================================================</span><br><span class="line"> Package                          Arch                                Version                                   Repository                                        Size</span><br><span class="line">=======================================================================================================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> zsh                              x86_64                              5.0.2-31.el7                              ECI-base-CentOS-7.6                              2.4 M</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=======================================================================================================================================================================</span><br><span class="line">Install  1 Package</span><br><span class="line"></span><br><span class="line">Total download size: 2.4 M</span><br><span class="line">Installed size: 5.6 M</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">zsh-5.0.2-31.el7.x86_64.rpm                                                                                                                     | 2.4 MB  00:00:07     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : zsh-5.0.2-31.el7.x86_64                                                                                                                             1/1 </span><br><span class="line">  Verifying  : zsh-5.0.2-31.el7.x86_64                                                                                                                             1/1 </span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  zsh.x86_64 0:5.0.2-31.el7                                                                                                                                            </span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# which zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# chsh -s /bin/</span><br><span class="line">/bin/bash  /bin/csh   /bin/sh    /bin/tcsh  /bin/zsh   </span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# chsh -s /bin/</span><br><span class="line">/bin/bash  /bin/csh   /bin/sh    /bin/tcsh  /bin/zsh   </span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# chsh -s /bin/zsh </span><br><span class="line">Changing shell for root.</span><br><span class="line">Shell changed.</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ol>
<li>应用最广泛的shell是bash;</li>
<li>功能最强大的shell是zsh.</li>
</ol>
<h3 id="用chsh改变shell"><a href="#用chsh改变shell" class="headerlink" title="用chsh改变shell"></a>用chsh改变shell</h3><p>利用chsh修改当前使用的shell命令行,具体操作方法见前一章节</p>
<p>那么chsh到底修改了哪里呢?</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# chsh -s /bin/zsh </span><br><span class="line">Changing shell for root.</span><br><span class="line">Shell changed.</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# cat /etc/passwd |grep  &quot;zsh&quot;</span><br><span class="line">root:x:0:0:root:/root:/bin/zsh</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>



<h3 id="export环境变量"><a href="#export环境变量" class="headerlink" title="export环境变量"></a>export环境变量</h3><h4 id="export变量输出"><a href="#export变量输出" class="headerlink" title="export变量输出"></a>export变量输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# export</span><br><span class="line">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class="line">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class="line">declare -x HOME=&quot;/root&quot;</span><br><span class="line">declare -x HOSTNAME=&quot;cnhzldvcmpl67&quot;</span><br><span class="line">declare -x LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;</span><br><span class="line">declare -x LOGNAME=&quot;panxiyan&quot;</span><br><span class="line">declare -x LS_COLORS=&quot;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:&quot;</span><br><span class="line">declare -x MAIL=&quot;/var/spool/mail/panxiyan&quot;</span><br><span class="line">declare -x MANPATH=&quot;:/opt/puppetlabs/puppet/share/man&quot;</span><br><span class="line">declare -x OLDPWD</span><br><span class="line">declare -x PATH=&quot;/usr/lib64/ccache:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin:/root/bin&quot;</span><br><span class="line">declare -x PWD=&quot;/home/panxiyan/npti.src&quot;</span><br><span class="line">declare -x SHELL=&quot;/bin/bash&quot;</span><br><span class="line">declare -x SHLVL=&quot;2&quot;</span><br><span class="line">declare -x SSH_AUTH_SOCK=&quot;/tmp/ssh-Bogi4DVSt6/agent.437&quot;</span><br><span class="line">declare -x SSH_CLIENT=&quot;172.18.100.189 59362 22&quot;</span><br><span class="line">declare -x SSH_CONNECTION=&quot;172.18.100.189 59362 10.91.90.77 22&quot;</span><br><span class="line">declare -x SSH_TTY=&quot;/dev/pts/0&quot;</span><br><span class="line">declare -x TERM=&quot;vt100&quot;</span><br><span class="line">declare -x USER=&quot;panxiyan&quot;</span><br><span class="line">declare -x XDG_DATA_DIRS=&quot;/home/panxiyan/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share&quot;</span><br><span class="line">declare -x XDG_RUNTIME_DIR=&quot;/run/user/986&quot;</span><br><span class="line">declare -x XDG_SESSION_ID=&quot;44419&quot;</span><br><span class="line">declare -x http_proxy=&quot;http://147.234.159.146:3128&quot;</span><br><span class="line">declare -x no_proxy=&quot;127.0.0.1,147.234.154.159,alpina,147.234.159.138,globe,ibiza,.ecitele.com,147.234.150.92,.ecicloud.com,147.234.249.0/24,repo,147.234.245.15,ilptlpvdevgit02,ilptlpvdevgit01,cnhzlpvbktmirror01.ecitele.com,ilptltvbbp01.ecitele.com,bitbucketpocmirror1.ecitele.com&quot;</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>



<h4 id="export相关命令总结"><a href="#export相关命令总结" class="headerlink" title="export相关命令总结"></a>export相关命令总结</h4><p>在Linux系统中,除了export之外,还要env、set和declare等三个命令会显示shell中的变量</p>
<p>shell中变量分为环境变量和自定义变量。环境变量可以在当前线程的子线程中生效，而自定义变量的作用范围无法延伸到当前线程的子线程中。</p>
<p>总结：</p>
<p>​          </p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">显示范围</th>
<th align="center">特征</th>
</tr>
</thead>
<tbody><tr>
<td align="center">env</td>
<td align="center">环境变量</td>
<td align="center">不显示自定义变量</td>
</tr>
<tr>
<td align="center">export</td>
<td align="center">环境变量</td>
<td align="center">输出内容按照变量名称排序</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">环境变量+自定义变量</td>
<td align="center">显示shell中所有的变量</td>
</tr>
<tr>
<td align="center">declare</td>
<td align="center">环境变量+自定义变量</td>
<td align="center">输出内容按照变量名称排序</td>
</tr>
</tbody></table>
<p>tips：执行set前会执行clear命令,而执行declare前会执行set命令</p>
<h4 id="如何利用export设置shell环境变量"><a href="#如何利用export设置shell环境变量" class="headerlink" title="如何利用export设置shell环境变量"></a>如何利用export设置shell环境变量</h4><h5 id="PATH变量内容"><a href="#PATH变量内容" class="headerlink" title="$PATH变量内容"></a>$PATH变量内容</h5><p>​        $PATH是Linux中最常用的环境变量,这个变量中的内容如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $PATH</span><br><span class="line">/usr/lib64/ccache:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin:/root/bin</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<h5 id="PATH-的作用"><a href="#PATH-的作用" class="headerlink" title="$PATH 的作用"></a>$PATH 的作用</h5><p>​        当用户在shell命令行中输入一个指令的时候,Linux系统会去$PATH下的路径寻找这个指令,如果找到了,就执行该指令;如果没有找到,就直接退出并显示该指令不存在.</p>
<h5 id="如何使用-PATH变量"><a href="#如何使用-PATH变量" class="headerlink" title="如何使用$PATH变量"></a>如何使用$PATH变量</h5><p>​        例如在运维工作中,我们在/home/roc/operation_tools路径下存放了很多的运维小工具,如何在我们使用这些工具的时候避免每次都需要输入这些工具的绝对路径?</p>
<p>​        办法如下:            </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# export PATH=$PATH:/home/roc/operation_tools</span><br></pre></td></tr></table></figure>

<h4 id="export使用案例和日常避坑"><a href="#export使用案例和日常避坑" class="headerlink" title="export使用案例和日常避坑"></a>export使用案例和日常避坑</h4><p>​        当我们向$PATH环境变量中添加新的变量时,一定要注意语法格式,否则会出现什么命令都用不了的现象,如下:</p>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>​        定义自定义变量var1和var2,然后通过export发布自定义变量var1使之成为环境变量,最后通过bash子进程访问环境变量var1:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# var1=&quot;hello&quot;</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $var1</span><br><span class="line">hello</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# var2=&quot;world&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&quot;</span></span></span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $var2</span><br><span class="line">world&#x27;</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# export var1</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# bash</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# echo var1</span><br><span class="line">var1</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $var1</span><br><span class="line">hello</span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# echo $var2</span><br><span class="line"></span><br><span class="line">[root@cnhzldvcmpl67 npti.src]# </span><br></pre></td></tr></table></figure>

<h5 id="日常避坑"><a href="#日常避坑" class="headerlink" title="日常避坑"></a>日常避坑</h5><p>​        下面的写法存在语法错误,但是系统并不会检测出来,</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@cnhzldvcmpl67 npti.src]# export PATH=PATH/home/roc/operation_tools</span><br></pre></td></tr></table></figure>

<p>​        当我们发布上面这个环境变量的时候,由于存在语法错误,它会导致我们的$PATH变量中原来的内容被全部清空.</p>
<p>届时我们连cat命令都无法使用的!!!!</p>
<h3 id="read命令详解"><a href="#read命令详解" class="headerlink" title="read命令详解"></a>read命令详解</h3><h3 id="exper计算器"><a href="#exper计算器" class="headerlink" title="exper计算器"></a>exper计算器</h3><h3 id="tmux多窗口"><a href="#tmux多窗口" class="headerlink" title="tmux多窗口"></a>tmux多窗口</h3><h3 id="alias和昵称"><a href="#alias和昵称" class="headerlink" title="alias和昵称"></a>alias和昵称</h3><h3 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h3><h3 id="xargs命令"><a href="#xargs命令" class="headerlink" title="xargs命令"></a>xargs命令</h3><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/Linux/">Linux</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/Linux/">Linux</a></div><hr></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="西北看长安"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">西北看长安</p><p class="is-size-6 is-block">斯人若彩虹,遇上方知有</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/panxizi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/6334161054/profile?topnav=1&amp;wvr=6"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:pxytravel@hotmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第一节 基础）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:42:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第一节 基础）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="通信技术概论"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:33:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/">通信技术概论</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/%E6%88%91%E7%9A%84C++%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="我的C++学习之路"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:25:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/%E6%88%91%E7%9A%84C++%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">我的C++学习之路</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第三章 字符串、向量和数组 第六节 多维数组）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-11T12:38:00.000Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/">Primer C++ 第五版（第三章 字符串、向量和数组 第六节 多维数组）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%94%E8%8A%82-%E6%95%B0%E7%BB%84%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第三章 字符串、向量和数组 第五节 数组）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-11T07:38:00.000Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%94%E8%8A%82-%E6%95%B0%E7%BB%84%EF%BC%89/">Primer C++ 第五版（第三章 字符串、向量和数组 第五节 数组）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a><p class="size-small"><span>&copy; 2022 Xizi Pan</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/7/30 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>