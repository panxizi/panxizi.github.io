<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>西北看长安</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="西北看长安"><meta name="msapplication-TileImage" content="/img/zhonglou.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="西北看长安"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="西北看长安"><meta property="og:url" content="https://panxizi.github.io/"><meta property="og:site_name" content="西北看长安"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://panxizi.github.io/img/avatar.png"><meta property="article:author" content="XiZi"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"西北看长安","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Xizi Pan"},"description":""}</script><link rel="icon" href="/img/zhonglou.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/07/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第三章 字符串、向量和数组 第二节 标准库类型string）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-07  <a class="commentCountImg" href="/2022/07/07/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring%EF%BC%89/#comment-container"><span class="display-none-class">a38fee0f0906ac549e681bac291e63b3</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="a38fee0f0906ac549e681bac291e63b3">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>14 分钟  <i class="fas fa-pencil-alt"> </i>2.1 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/07/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring%EF%BC%89/">Primer C++ 第五版（第三章 字符串、向量和数组 第二节 标准库类型string）</a></h1><div class="content"><p> 标准库类型 string  </p>
<p>注意事项：需包含以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>

<p>关于string的更多内容请阅读<a href = "#">9.5 节（ 第 320 页）  </a></p>
<h4 id="定义和初始化-string-对象"><a href="#定义和初始化-string-对象" class="headerlink" title="定义和初始化 string 对象"></a>定义和初始化 string 对象</h4><ol>
<li><p>初始化string对象的方法</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706103253855.png" alt="image-20220706103253855.png"></p>
</li>
<li><p>样例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706103441609.png" alt="image-20220706103441609"></p>
</li>
</ol>
<h5 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h5><ol>
<li>直接初始化<br>不使用“=”</li>
<li>拷贝初始化<br>使用“=”初始化变量</li>
<li>样例<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706103720154.png" alt="image-20220706103720154"></li>
<li>特殊情况</li>
</ol>
<p>​        用多个值进行初始化时如果非要用拷贝初始化的方式来进行，</p>
<p>​        表面过程：<br>​                <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706104015256.png" alt="image-20220706104015256"></p>
<p>​        实际过程：</p>
<p>​                        <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706104038676.png" alt="image-20220706104038676"></p>
<h4 id="string-对象上的操作"><a href="#string-对象上的操作" class="headerlink" title="string 对象上的操作"></a>string 对象上的操作</h4><ol>
<li><p>string上操作：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706104144706.png" alt="image-20220706104144706"></p>
</li>
</ol>
<h5 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h5><p>​        使用IO操作符读写string对象：</p>
<p>​                <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706104338331.png" alt="image-20220706104338331"></p>
<ol>
<li><p>string对象读写规则</p>
<ul>
<li>读规则：<ul>
<li>忽略开头的空白（ 即空格符、 换行符、 制表符等）；  </li>
<li>从第一个真正的字符开始读起  ；</li>
<li>遇到下一个空白时结束读入</li>
</ul>
</li>
<li>写规则：<ul>
<li>返回运算符左侧的运算对象作为结果</li>
</ul>
</li>
<li>总结：<ul>
<li>多个输入和输出可以连写到一起</li>
</ul>
</li>
</ul>
</li>
<li><p>案例：</p>
<ol>
<li><p>如果程序输入“     Hello world!     ”;输出将会是”Hello”</p>
</li>
<li><p>代码案例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;<span class="comment">// 把第一个输入读到 s1 中， 第二个输入读到 s2 中</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;<span class="comment">// 输 出 两 个 string 对 象</span></span><br></pre></td></tr></table></figure>

<p>输入是“     Hello world!     ”;输出是”HelloWorld!”</p>
</li>
</ol>
</li>
</ol>
<h5 id="读取未知数量的string对象"><a href="#读取未知数量的string对象" class="headerlink" title="读取未知数量的string对象"></a>读取未知数量的string对象</h5><p>​        参照<a href = "#">1.4.3节 第13页</a>读入未知数量的整数</p>
<p>​        <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706105246331.png" alt="image-20220706105246331"></p>
<h5 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h5><p>​        若想保留输入时的空白符,则需要用getline函数代替”&gt;&gt;”;</p>
<ol>
<li>参数: 一个输入流+一个string对象</li>
<li>读入规则:<ol>
<li>从给定的流中读入内容</li>
<li>遇到换行符结束(换行符也读进来)</li>
<li>将读入的内容存入到string对象中(不存换行符)</li>
<li>如果输入一开始就是换行符则立马结束读入,所得的结果是空string</li>
</ol>
</li>
<li>案例:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706110103911.png" alt="image-20220706110103911"></li>
<li>备注:出发getline函数返回(结束读入)的换行符其实被丢掉了,得到的string对象并不包含改换行符</li>
</ol>
<h5 id="string的empty和size操作"><a href="#string的empty和size操作" class="headerlink" title="string的empty和size操作"></a>string的empty和size操作</h5><ol>
<li><p>empty函数</p>
<ol>
<li>结合点操作符使用:    string对象.empty()</li>
<li>根据string对象是否为空返回一个bool值,参照<a href = "#">2.1 第30页</a></li>
<li>案例:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706110609499.png" alt="image-20220706110609499.png"></li>
</ol>
</li>
<li><p>size函数</p>
<ol>
<li>返回string对象的长度(字符的个数)</li>
<li>案例:输出长度超过80个字符的行:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706110843156.png" alt="image-20220706110843156"></li>
</ol>
</li>
</ol>
<h5 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h5><ol>
<li><p>string类的几种配套类型之一;其他大多数标准库类型也有这种配套类型</p>
</li>
<li><p>体现了标准库类型和机器无关的特性</p>
</li>
<li><p>足以放下任何string对象的大小</p>
</li>
<li><p>是一个unsigned值</p>
</li>
<li><p>通过auto或者decltype来推测变量类型<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706111449123.png" alt="image-20220706111449123"></p>
<p>size函数返回的是一个无符号整型数</p>
</li>
<li><p>避坑:</p>
<p>禁止表达式中混用无符号数和有符号数<br>假设 n是一个有符号数,则 s.size()&lt;n则几乎肯定为true,因为负值n会自动的转换成一个比较大的无符号数</p>
</li>
</ol>
<h5 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h5><ol>
<li><p>比较字符串的运算符会逐一比较string对象中的字符,且大小写敏感</p>
</li>
<li><p>相等性运算符(== 和!=)</p>
<ol>
<li>检验两个string对象是否相等<ol>
<li>相等:长度和包含的字符完全相同</li>
</ol>
</li>
</ol>
</li>
<li><p>关系性运算符(&lt;,&lt;=,&gt;,&gt;=),这些运算符依照大小写敏感的字典顺序:</p>
<ol>
<li>两个string对象长度不同:且较短的对象的字符和较长的一样,则较短string对象&lt;较长string对象</li>
<li>两个string对象在某些对应位置上不一致,则比较结果是string对象中第一对相异字符的比较结果</li>
</ol>
</li>
<li><p>案例:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706112516445.png" alt="image-20220706112516445"></p>
<p>比较结果:<br>str &lt; phrase<br>slang&gt; str<br>slang&gt; phrase</p>
</li>
</ol>
<h5 id="为string对象赋值"><a href="#为string对象赋值" class="headerlink" title="为string对象赋值"></a>为string对象赋值</h5><p>对于 string 类而言， 允许把一个对象的值赋给另外一个对象:<br>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706133722623.png" alt="image-20220706133722623"></p>
<h5 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a>两个string对象相加</h5><p>两个string对象相加得到新的string对象</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706133937420.png" alt="image-20220706133937420"></p>
<h5 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h5><ul>
<li>字面值和string对象相加会转换拼接成新的string对象</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706134125004.png" alt="image-20220706134125004"></p>
<ul>
<li>当string对象和字符字面值以及字符串字面值混在一条语句中使用时,至少确保每个”+”两侧的运算对象有一个是string:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706134459163.png" alt="image-20220706134459163"><ul>
<li>因为某些历史原因,字符串字面值并不是标准库类型中的string对象.</li>
<li>切记:字符串字面值和string对象是不同的类型</li>
</ul>
</li>
</ul>
<h4 id="处理-string-对象中的字符"><a href="#处理-string-对象中的字符" class="headerlink" title="处理 string 对象中的字符"></a>处理 string 对象中的字符</h4><p>问题场景:</p>
<ol>
<li>string 对象是否包含空白  </li>
<li>把 string 对象中的字母改成小写  </li>
<li>査看某个特定的字符是否出现</li>
</ol>
<p>工具:cctype 头文件  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706135317934.png" alt="image-20220706135317934"></p>
<p>建议:使用C++版的c标准库头文件</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706141357796.png" alt="image-20220706141357796"></p>
<h5 id="处理每个字符-使用基于范围的for语句"><a href="#处理每个字符-使用基于范围的for语句" class="headerlink" title="处理每个字符?使用基于范围的for语句"></a>处理每个字符?使用基于范围的for语句</h5><p>C++11新标准提供的一种语句: 范围 for (range for) 语句  </p>
<p>语法:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706141608386.png" alt="image-20220706141608386"></p>
<ol>
<li>案例1: 使用范围 for 语句把 string 对象中的字符每行一个输出出来：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706141711992.png"></li>
<li>案例2:使用范围 for 语句和 ispunct 函数来统计 string 对象中标点符号的个数<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706141913613.png" alt="image-20220706141913613"><ul>
<li>解析:<ul>
<li>1,关于punct_cnt的类型(string::size_type  ),参考 <a href = "#">2.5.3节 第62页</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="使用范围for语句改变字符串中的字符"><a href="#使用范围for语句改变字符串中的字符" class="headerlink" title="使用范围for语句改变字符串中的字符"></a>使用范围for语句改变字符串中的字符</h5><ul>
<li>关键点:<ul>
<li>要改变 string 对象中字符的值， 必须把循环变量定义成引用类型(<a href ="#">参考2.3.1节 第45页</a>)  </li>
<li>使用标准库函数 toupper ()</li>
</ul>
</li>
<li>案例:<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706142530059.png" alt="image-20220706142530059"><br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706142614039.png" alt="image-20220706142614039"></li>
</ul>
<h5 id="只处理一部分字符"><a href="#只处理一部分字符" class="headerlink" title="只处理一部分字符?"></a>只处理一部分字符?</h5><ul>
<li>问题情景:只访问修改string对象中的部分字符</li>
<li>解决办法<ul>
<li>使用下标</li>
<li>使用迭代器(参考<a href = "#">3.4节 第95页</a>)</li>
</ul>
</li>
<li>使用下标访问string对象部分字符<ul>
<li>下标运算符（ [ ] )   </li>
<li>输入参数是 string::size_type 类型的值(<a href="#string::size_type类型">第3.2.2节 第79页</a>)，</li>
<li>参数表示要访问的字符的位置  </li>
<li>返回值I该位置上字符的引用</li>
<li>string 对象的下标从 0 计起;s [ 0 ] 是第1个字符,s[1]是第2个字符,s [ s.size () -1] 是最后一个字符  </li>
<li>string 对象的下标必须大于等于 0 而小于 s.size ( );</li>
<li>使用下标访问空 string 也会引发不可预知的结果。</li>
<li>案例1:<br>下标运算符输出 string 对象中的第一个字符<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706143619369.png" alt="image-20220706143619369"></li>
<li>案例2:<pre><code>将字符串的首字符改成了大写形式 
</code></pre>
<img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706143705052.png" alt="image-20220706143705052"></li>
<li>总结:    只要string对象不是常量,就可以通过下标访问string对象中的字符方式来对其进行修改</li>
</ul>
</li>
</ul>
<h5 id="使用下标进行迭代"><a href="#使用下标进行迭代" class="headerlink" title="使用下标进行迭代"></a>使用下标进行迭代</h5><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706143942648.png" alt="image-20220706143942648"></p>
<p>输出结果是: SOME string</p>
<p>知识拓展:</p>
<ul>
<li>逻辑与运算符 &amp;&amp;</li>
<li>注意检查下标的合法性<ul>
<li>下标必须是大于等于 0 而小于字符串的 size()的 值  </li>
<li>解决办法:<ul>
<li>设 下 标 的 类 型 为string::size_type, 因为此类型是无符号数， 可以确保下标不会小于 0  </li>
<li>代码作者还需自行保证下标小于size();</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="使用下表执行随机访问"><a href="#使用下表执行随机访问" class="headerlink" title="使用下表执行随机访问"></a>使用下表执行随机访问</h5><p>案例:把 0 到 15 之间的十进制数转换成对应的十六进制形式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string hexdigits = <span class="string">&quot;0123456789ABCDEF&quot;</span>; <span class="comment">// 可能的十六进制数字</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a series of numbers between 0 and 15&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;separated by spaces. Hit ENTER when finished: &quot;</span></span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line">string result;			<span class="comment">//用于保存十六进制数</span></span><br><span class="line">string::size_type n;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;hexdigits.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        result += hexdigits[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Your Hex number is :&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>加入输入如下:</p>
<p>​        12 0 5 15 8 15</p>
<p>程序的输出结果将是:</p>
<p>​          Your hex number is: C05F8F</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第三章 字符串、向量和数组 第一节 命名空间的using声明）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E%EF%BC%89/#comment-container"><span class="display-none-class">9fc49ba619cc6cb870d96dd85f6b3baa</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="9fc49ba619cc6cb870d96dd85f6b3baa">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 分钟  <i class="fas fa-pencil-alt"> </i>0.3 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E%EF%BC%89/">Primer C++ 第五版（第三章 字符串、向量和数组 第一节 命名空间的using声明）</a></h1><div class="content"><h3 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h3><ol>
<li><p>域操作符（<a href="#">参见 1.2 节， 第 7 页  </a>）含义：<br>例如std::cin    译器应从操作符左侧名字所示的作用域中寻找右侧那个名字</p>
</li>
<li><p>更简单的方法：  using 声明（ using declaration)  ，详参<a href ="#">18.2.2 节（ 第 702 页）</a></p>
<ol>
<li><p>using声明形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure></li>
<li><p>样例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220706093217168-1657121175072.png" alt="image-20220706093217168"></p>
</li>
</ol>
</li>
</ol>
<h4 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h4><ul>
<li><p>按照规定， 每个 using 声明引入命名空间中的一个成员  </p>
<ul>
<li><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 通过下列 using 声明， 我们可以使用标准库中的名字</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> vl, v2;</span><br><span class="line">    cin &gt;&gt; vl &gt;&gt; v2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; vl &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot;is&quot;</span> &lt;&lt; vl + v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="头文件不应该包含using声明"><a href="#头文件不应该包含using声明" class="headerlink" title="头文件不应该包含using声明"></a>头文件不应该包含using声明</h4><p>​        如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明 ，可能产生始料未及的名字冲突  </p>
<h4 id="一点注意事项"><a href="#一点注意事项" class="headerlink" title="一点注意事项"></a>一点注意事项</h4><p>​        本书后面的程序中不再包含using声明和#include指令，运行本书中后面章节的代码请读者自行补全</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第六节 自定义数据结构）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/#comment-container"><span class="display-none-class">6cea5448b048d303b86a5dbfe9978021</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="6cea5448b048d303b86a5dbfe9978021">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>7 分钟  <i class="fas fa-pencil-alt"> </i>1.1 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第六节 自定义数据结构）</a></h1><div class="content"><h3 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h3><ul>
<li>数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法  </li>
</ul>
<h4 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h4><ol>
<li><p>初步想法是定义一个用户可以直接访问类中数据元素但是不带任何运算功能<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705232241242.png" alt="image-20220705232241242"></p>
</li>
<li><p>类以关键字 struct 开始， 紧跟着类名和类体（ 其中类体部分可以为空)  </p>
</li>
<li><p>内部定义的名字必须唯一， 但是可以与类外部定义的名字重复。  </p>
</li>
<li><p>类体右侧的表示结束的花括号后必须写一个分号， 这是因为类体后面可以紧跟变量名以示对该类型对象的定义， 所以分号必不可少  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span> <span class="comment">/* ... */</span> &#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">// 与上一条语句等价， 但可能更好一些</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span> <span class="comment">/* • • • */</span> &#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure></li>
<li><p>类体定义类的成员， 我们的类只有数据成员（ data member)  </p>
</li>
<li><p>C++11 新标准规定， 可以为数据成员提供一个类内初始值（in-class initializer)。  </p>
</li>
<li><p>创建对象时， 类内初始值将用于初始化数据成员。 没有初始值的成员将被默认初始化  </p>
</li>
</ol>
<h4 id="使用-Sales-data-类"><a href="#使用-Sales-data-类" class="headerlink" title="使用 Sales_data 类"></a>使用 Sales_data 类</h4><ol>
<li>计算两次交易结果相加的记录，输入数据如下<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705232903375.png" alt="image-20220705232903375"></li>
</ol>
<h5 id="添加两个-Sales-data-对象"><a href="#添加两个-Sales-data-对象" class="headerlink" title="添加两个 Sales_data 对象"></a>添加两个 Sales_data 对象</h5><p>假设己知 Sales_data 类定义于 Sales_data.h 文件内 ；头文件定义参见（<a href = "#2.6.3    编写自己的头文件">2.6.3 节  </a>）</p>
<p>程序较长，分成几份介绍，总体结构如下：</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705232951483.png" alt="image-20220705232951483"></h5><h5 id="Sales-data-对象读入数据"><a href="#Sales-data-对象读入数据" class="headerlink" title="Sales_data 对象读入数据"></a>Sales_data 对象读入数据</h5><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705233313102.png" alt="image-20220705233313102"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705233436748.png" alt="image-20220705233436748"></p>
<h5 id="输出两个-Sales-data-对象的和"><a href="#输出两个-Sales-data-对象的和" class="headerlink" title="输出两个 Sales_data 对象的和"></a>输出两个 Sales_data 对象的和</h5><p>剩下的工作就是检查两笔交易涉及的 ISBN 编号是否相同了。 如果相M输出它们的和,否则输出一条报错信息：  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705233527072.png" alt="image-20220705233527072"></p>
<h4 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h4><ul>
<li>为了确保各个文件中类的定义一致， 类通常被定义在头文件中， 而且类所在头文件的名字应与类的名字一样   </li>
<li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明</li>
</ul>
<h5 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h5><ol>
<li>预处理器是在编译之前执行的一段程序， 可以部分地改变我们所写的程序。<ol>
<li>预处理功能#include, 当预处理器看到#include标记时就会用指定的头文件的内容代替#include  </li>
</ol>
</li>
<li>C++程序还会用到的一项预处理功能是头文件保护符 （ header guard), 头文件保护符依赖于预处理变量 （<a href="#空指针">2.3.2 节， 第 48 页  </a>）<br>预处理变量有两种状态：  己定义和未定义。  <ol>
<li> #define 指令把一个名字设定为预处理变量， 另外两个指令则分别检查某个指定的预处理变量是否己经定义</li>
<li>  #ifdef 当且仅当变量已定义时为真， #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真， 则执行后续操作直至遇到#endif 指令为止。</li>
<li>目的：有效地防止重复包含的发生<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705234430034.png" alt="image-20220705234430034"></li>
<li>预处理变量无视 C++语言中关于作用域的规则。</li>
<li>头文件即使（ 目前还 ） 没有被包含在任何其他头文件中， 也应该设置保护符头文件保护符很简单， 程序员只要习惯性地加上就可以了 ， 没必要太在乎你的程序到底需不需要。</li>
<li>整个程序中的预处理变量包括头文件保护符必须唯一， 通常的做法是基于头文件中类的名字来构建保护符的名字， 以确保其唯一性。 为了避免与程序中的其他实体发生名字冲突， 一般把预处理变量的名字全部大写。    </li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">21a4771bbf4007e96ea64a2275e8316e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="21a4771bbf4007e96ea64a2275e8316e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>11 分钟  <i class="fas fa-pencil-alt"> </i>1.7 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）</a></h1><div class="content"><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><ul>
<li>问题情景：程序越来越复杂， 程序中用到的类型也越来越复杂  <ul>
<li>一是一些类型难于“ 拼写”， 它们的名字既难记又容易写错， 还无法明确体现其真实目的和含义  </li>
<li>二是有时候根本搞不清到底需要的类型是什么， 程序员不得不回过头去从程序的上下文中寻求帮助。  </li>
</ul>
</li>
</ul>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ol>
<li><p>类型别名（ type alias)  定义：<br>是一个名字， 它是某种类型的同义词。   </p>
</li>
<li><p>好处：让复杂的类型名字变得简单明了、 易于理解和使用， 还有助于程序员清楚地知道使用该类型的真实目的。  </p>
</li>
<li><p>定义类型别名  </p>
<ol>
<li><p>关键字 typedef  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223950076.png" alt="image-20220705223950076"></p>
</li>
<li><p>别名声明（ aliasdeclaration)   </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705224051565.png" alt="image-20220705224051565"></p>
</li>
</ol>
</li>
<li><p>使用场景：类型别名和类型的名字等价， 只要是类型的名字能出现的地方， 就能使用类型别名：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base 是 double 的同义词， p 是 double *的同义词</span></span><br><span class="line"></span><br><span class="line">wages hourly, weekly;<span class="comment">// 等价于 double hourly、 weekly;</span></span><br><span class="line">SI item; <span class="comment">// 等价于 Sales_item item</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="指针、-常量和类型别名"><a href="#指针、-常量和类型别名" class="headerlink" title="指针、 常量和类型别名"></a>指针、 常量和类型别名</h5><ul>
<li><p>如果某个类型别名指代的是复合类型或常量， 那么把它用到声明语句里就会产生意想不到的后果  </p>
</li>
<li><p>下面的声明语句用到了类型pstring,它实际上是类型 char *的别名：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225345870.png" alt="image-20220705225345870"></p>
<ul>
<li>pstring 实际上是指向 char 的指针， 因此， const pstring 就是指向char 的常量指针， 而非指向常量字符的指针。  </li>
<li>人们往往会错误地尝试把类型别名替换成它本来的样子， 以理解该语句的含义：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225640419.png" alt="image-20220705225640419"></li>
<li>这样改写的结果是， const char 成了基本数据类型。 前后两种声明含义截然不同， 前者声明了一个指向 char 的常量指针， 改写后的形式则声明了一个指向 const char 的指针。  </li>
</ul>
</li>
</ul>
<h4 id="auto-类型说明符"><a href="#auto-类型说明符" class="headerlink" title="auto 类型说明符"></a>auto 类型说明符</h4><ol>
<li>C++11 新标准引入了 auto 类型说明符</li>
<li>让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符（ 比如 double) 不同， auto 让编译器通过初始值来推算变量的类型。 显然， auto 定义的变量必须有初始值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230127843.png" alt="image-20220705230127843"></li>
<li>使用 auto 也能在一条语句中声明多个变量。 因为一条声明语句只能有一个基本数据类型， 所以该语句中所有变量的初始基本数据类型都必须一样：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230215573.png" alt="image-20220705230215573"></li>
</ol>
<h5 id="复合类型、-常量和-auto"><a href="#复合类型、-常量和-auto" class="headerlink" title="复合类型、 常量和 auto"></a>复合类型、 常量和 auto</h5><ol>
<li> 编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样， 编译器会适当地改变结果类型使其更符合初始化规则。</li>
<li>当引用被用作初始值时， 真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为 auto的类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230412863.png" alt="image-20220705230412863"></li>
<li>auto —般会忽略掉顶层 const (参见<a href ="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>）， 同时底层 const 则会 保留下来， 比如当初始值是一个指向常量的指针时：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230626358.png" alt="image-20220705230626358"></li>
<li>如果希望推断出的 auto 类型是一个顶层 const, 需要明确指出：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230709586.png" alt="image-20220705230709586"></li>
<li>将引用的类型设为 auto, 此时原来的初始化规则仍然适用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230754003.png" alt="image-20220705230754003"></li>
<li>要在一条语句中定义多个变量， 切记， 符号&amp;和*只从属于某个声明符， 而非基本数据类型的一部分， 因此初始值必须是同一种类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230843490.png" alt="image-20220705230843490"></li>
</ol>
<h4 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h4><ol>
<li>问题情景：希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量。   </li>
<li>decltype 类型指示符 ：C++11 新标准引入了第二种类型说明符decltype. 它的作用是选择并返回操作数的数据类型。 在此过程中， 编译器分析表达式<br>并得到它的类型， 却不实际计算表达式的值：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231052903.png" alt="image-20220705231052903"></li>
<li>decltype 处理顶层 const 和引用的方式与 auto 有些许不同。 如果 decltype 使用的表达式是一个变量， 则 decltype 返回该变量的类型( 包括顶层 const 和引用在内）：<br>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231159269.png" alt="image-20220705231159269"></li>
</ol>
<h5 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h5><p>如果 decltype 使用的表达式不是一个变量， 则 decltype 返回表达式结果对应的类型。  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231423081.png" alt="image-20220705231423081"></p>
<ol>
<li><p>r 是一个引用， 因此 decltype (r ) 的结果是引用类型  </p>
</li>
<li><p>如果想让结果类型是 r 所指的类型， 可以把 r 作为表达式的一部分， 如 r+0, 显然这个表达式的结果将是一个具体值而非一个引用。  </p>
</li>
<li><p>如果表达式的内容是解引用操作， 则 decltype 将得到引用类型。  </p>
<ol>
<li>解引用指针可以得到指针所指的对象， 而且还能给这个对象赋值  </li>
<li>因此， decltype ( *p) 的结果类艰就是 int &amp;， 而非 int。  </li>
</ol>
</li>
<li><p>decltype 和 auto 的另一处重要区別是， decltype 的结果类型与表达式形式密切相关。<br> 特别注意  ：</p>
<ol>
<li><p>对于 decltype 所用的表达式来说， 如果变量名加上了一对括号， 则得到的类型与不加括号时会有不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype 的表达式如果是加上了括号的变量， 结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span> ( (i) ) d;		<span class="comment">// 错误： d是 int&amp;， 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span> (i) e;			<span class="comment">// 正确： e 是一个（ 未初始化的 ） int</span></span><br></pre></td></tr></table></figure></li>
<li><p>decltype( ( variable ) ) ( 注意是双层括号 ） 的结果永远是引用， 而decltype( variable) 结果只有当 variable 本身就是一个引用时才是引用。  </p>
</li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/#comment-container"><span class="display-none-class">1fb5fb78276704826e2511f75be4a35c</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="1fb5fb78276704826e2511f75be4a35c">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 分钟  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）</a></h1><div class="content"><h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><ol>
<li><p>const 对象一旦创建后其值就不能再改变， 所以 const 对象必须初始化。  </p>
</li>
<li><p>初始值可以是任意复杂的表达式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="built_in">get_size</span>()； <span class="comment">// 正确：运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>；<span class="comment">// 正确：编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k；<span class="comment">//错误，k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="初始化和-const"><a href="#初始化和-const" class="headerlink" title="初始化和 const"></a>初始化和 const</h5><ul>
<li><p>非 const 类型所能参与的操作相比， const 类型的对象能完成其中大部分  </p>
</li>
<li><p>只能在 const 类型的对象上执行不改变其内容的操作  </p>
</li>
<li><p>const对象可以用于初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci  = i；	<span class="comment">// 正确： i的值被拷贝给了 ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci；			<span class="comment">// 正确： ci的值被拷贝给了 j</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="默认状态下，-const-对象仅在文件内有效"><a href="#默认状态下，-const-对象仅在文件内有效" class="headerlink" title="默认状态下， const 对象仅在文件内有效"></a>默认状态下， const 对象仅在文件内有效</h5><ol>
<li><p>const对象的生效过程：</p>
<ul>
<li>当以编译时初始化的方式定义一个const对象时：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>; / / 输入缓冲区大小</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器将在编译过程中把用到该变量的地方都替换成对应的值。 </li>
<li>为了执行上述替换， 编译器必须知道变量的初始值  </li>
<li>如果程序包含多个文件， 则每个用了 const 对象的文件都必须得能访问到它的初始值才行。   </li>
<li>要做到这一点， 就必须在每一个用到变量的文件中都有对它的定义（ <a href = "# 2.2.2    变量声明和定义的关系 ">参见 2.2.2 节， 第 41 页  </a>）。</li>
<li>为了支持这一用法，同时避免对同一变量的重复定义， 默认情况下， const 对象被设定为仅在文件内有效  </li>
<li>当多个文件中出现了同名的 const 变量时， 其实等同于在不同文件中分别定义了独立的变量。  </li>
</ul>
</li>
<li><p>问题场景：</p>
<ul>
<li><p>某些时候有这样一种 const 变量， 它的初始值不是一个常量表达式， 但又确实有必要在文件间共享。 这种情况下， 我们不希望编译器为每个文件分别生成独立的变量。 相反，我们想让这类 const 对象像其他（ 非常量） 对象一样工作， 也就是说， 只在一个文件中定义 const， 而在其他多个文件中声明并使用它  </p>
</li>
<li><p>解决办法：</p>
<ul>
<li><p>如果想在多个文件之间共享 const 对象， 必须在变量的定义之前添加 extern关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_l.cc 定义并初始化了一个常量， 该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span> ( );</span><br><span class="line"><span class="comment">// file_l.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">/// / 与 file_1.cc 中定义的 bufSize 是同一个</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a>const 的引用</h4><ol>
<li><p>对常量 的引用（ reference to const)</p>
<p>把引用绑定到 const 对象上， 就像绑定到其他对象上一样，</p>
</li>
<li><p>对常量的引用不能被用作修改它所绑定的对象：</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// 正确： 引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;	<span class="comment">// 错误： r1 是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">// 错误： 试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>术语：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705153505715.png" alt="image-20220705153505715"></p>
<h5 id="初始化和对-const-的引用"><a href="#初始化和对-const-的引用" class="headerlink" title="初始化和对 const 的引用"></a>初始化和对 const 的引用</h5><ol>
<li><p>引用的类型必须与其所引用对象的类型一致（<a href =  "#2.3.1    引用">2.3.1 第46页</a>）， 但是有两个例外  </p>
<ol>
<li><p>在初始化常量引用时允许用任意表达式作为初始值， 只要该表达式的结果能转换成（<a href = "#2.1.2    类型转换">参见 2.1.2 节， 第 32 页</a> ） 引用的类型即可。  尤其， 允许为一个常量引用绑定非常量的对象、 字面值， 甚至是个一般表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// 允许将 const int &amp;绑定到一个普通 int 对象上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">// 正确： r1 是一个常量引用	</span></span><br><span class="line"><span class="comment">//读者疑问：这里和r1有什么关系？笔误吗？正确的写法是const int &amp;r2 = r1；？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// 正确： r3 是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">// 错误： r4 是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>细节探究1：当一个常量引用被绑定到另外一种类型上时到底发生了什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处 ri 引用了一个 int 型的数。 对 ri 的操作应该是整数运算， 但 dval 却是一个双精<br>度浮点数而非整数。 因此为了确保让 ri 绑定一个整数， 编译器把上述代码变成了如下<br>形式:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval；<span class="comment">// 由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;	<span class="comment">// // 让ri 绑定这个临时量</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下， ri 绑定了一个临时量 ( temporary ) 对象。</p>
<p>所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 </p>
<p>C++程序员们常常把临时量对象简称为临时量。</p>
<p>接下来探讨当ri 不是常量时， 如果执行了类似于上面的初始化过程将带来什么样的<br>后果。</p>
<p> 如果ri 不是常量， 就允许对ri 赋值， 这样就会改变ri 所引用对象的值。</p>
<p> 注意，此时绑定的对象是一个临时量而非 dval。 </p>
<p>程序员既然让 ri 引用 dval, 就肯定想通过ri改变dval的值， 否则干什么要给ri赋值呢？ </p>
<p>如此看来， 既然大家基本上不会想着把引用绑定到临时量上， C++语言也就把这种行为归为非法。  </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="对-const-的引用可能引用一个并非-const-的对象"><a href="#对-const-的引用可能引用一个并非-const-的对象" class="headerlink" title="对 const 的引用可能引用一个并非 const 的对象"></a>对 const 的引用可能引用一个并非 const 的对象</h5><ol>
<li><p>常量引用仅对引用可参与的操作做出了限定， 对于引用的对象本身是不是一个常量未作限定</p>
</li>
<li><p>因为对象也可能是个非常量， 所以允许通过其他途径改变它的值 :</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;<span class="comment">// 引 用 ri绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">// r2 也绑定对象i, 但是不允许通过 r2 修改i的值</span></span><br><span class="line">r1 =  <span class="number">0</span>;<span class="comment">// r1 并非常量 ， i的值修改为 0</span></span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">// 错误： r2 是一个常量引用</span></span><br></pre></td></tr></table></figure>

<p>读者疑问：那么在上面这个例子里面，常量引用r2的值也被改成了0吗？常量引用为什么可以改变？</p>
</li>
</ol>
<h4 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h4><ol>
<li><p>与引用一样， 也可以令指针指向常量或非常量  </p>
</li>
<li><p>类似于常量引用（  <a href ="#2.4.1    const 的引用">参见 2.4.1 节， 第54 页</a>）， 指向常量的指针（pointer to const) 不能用于改变其所指对象的值。  </p>
</li>
<li><p>要想存放常量对象的地址， 只能使用指向常量的指针：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;		<span class="comment">// pi 是个常量， 它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;			<span class="comment">// 错误： ptr 是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;	<span class="comment">// 正确： cptr 可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;					<span class="comment">// 错误： 不能给*cptr 賦值</span></span><br></pre></td></tr></table></figure></li>
<li><p>指针的类型必须与其所指对象的类型一致( <a href ="#2.3.2    指针">2.3.2 节（ 第 47 页）</a>)<br>例外情况：</p>
<ol>
<li><p>允许令一个指向常量的指针指向一个非常量对象  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;<span class="comment">// dval 是一个双精度浮点数， 它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;<span class="comment">//正确： 但是不能通过 cptr 改变 dval 的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>和常量引用一样， 指向常量的指针也没有规定其所指的对象必须是一个常量  </p>
<ol>
<li>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值， 而没有规定那个对象的值不能通过<br>其他途径改变。</li>
</ol>
</li>
<li><p>关于指向常量的指针或者引用的总结：</p>
<p>试试这样想吧： 所谓指向常量的指针或引用， 不过是指针或引用 “ 自以为是’罢了， 它们觉得自己指向了常量， 所以自觉地不去改变所指对象的值。  </p>
</li>
</ol>
</li>
</ol>
<h5 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h5><ol>
<li><p>指针是对象而引用不是， 因此就像其他对象类型一样， 允许把指针本身定为常量  </p>
</li>
<li><p>常量指针 (const pointer) 必须初始化， 而且一旦初始化完成， 则它的值（ 也就是存放在指针中的那个地址） 就不能再改变了。   </p>
</li>
<li><p>不变的是指针本身的值而非指向的那个值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215121742.png" alt="image-20220705215121742"></p>
</li>
<li><p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值， 能否这样做完全依赖于所指对象的类型</p>
<ol>
<li><p>所指向的对象是常量，则不能修改</p>
</li>
<li><p>所指向的对象是非常量，则完全可以通过这个对象或者这个常量指针 去修改这个被指向对象的值</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215732072.png" alt="image-20220705215732072"></p>
</li>
</ol>
</li>
</ol>
<h4 id="顶层-const-读者注：这一小节读者表示看不明白"><a href="#顶层-const-读者注：这一小节读者表示看不明白" class="headerlink" title="顶层 const(读者注：这一小节读者表示看不明白~~~)"></a>顶层 const(读者注：这一小节读者表示看不明白~~~)</h4><ol>
<li><p>问题情景：</p>
<ol>
<li>指针本身是个对象，他又可以指向另外的对象；指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。 </li>
</ol>
</li>
<li><p>顶层const(top-level const)  </p>
<ol>
<li>指针本身是个常量  </li>
</ol>
</li>
<li><p>底层 const (low-level const)  </p>
<ol>
<li>指针所指的对象是一个常量  </li>
</ol>
</li>
<li><p>顶层const和底层 const的区分()</p>
<ol>
<li><p>顶层 const 可以表示任意的对象是常量， 这一点对任何数据类型都适用，如算术类型、 类、 指针等  </p>
</li>
<li><p>底层 const 则与指针和引用等复合类型的基本类型部分有关。  </p>
</li>
<li><p>指针类型既可以是顶层 const 也可以是底层 const  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> pi = &amp;i;<span class="comment">// 不能改变 pi 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">// 不能改变 ci 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">// 允许改变 p2 的值， 这是一个底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的 const 是顶层 const, 靠左的是底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;<span class="comment">// 用于声明引用的 const 都是底层 const</span></span><br></pre></td></tr></table></figure></li>
<li><p>当执行对象的拷贝操作时， 常量是顶层 const 还是底层 const 区别明显。 其中， 顶层 const 不受什么影响：</p>
</li>
<li><p>另一方面， 底层 const 的限制却不能忽视。 当执行对象的拷贝操作时， 拷入和拷出的对象必须具有相同的底层 const 资格， 或者两个对象的数据类型必须能够转换。 一般来说， 非常量可以转换成常量， 反之则不行： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i= ci;<span class="comment">// 正确： 拷贝 ci 的值， ci 是一个顶层 const， 对此操作无影响</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 指向的对象类型相同， p3 顶层 const 的部分不影响</span></span><br><span class="line"><span class="keyword">int</span> *p = p3;<span class="comment">// 错误： p3 包含底层 const 的定义， 而 p 没有</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 都是底层 const</span></span><br><span class="line">p2 = &amp;i;<span class="comment">// 正确： int 能转换成 const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r ci;<span class="comment">// 错误： 普通的 int &amp;不能绑定到 int 常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 =i;<span class="comment">//正确：const int &amp;可以绑定到一个普通 int 上</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h4><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><ol>
<li><p>指值不会改变并且在编译过程就能得到计算结果的表达式 ；字面值属于常量表达式  </p>
</li>
<li><p>常量表达式初始化的 const 对象也是常量表达式  </p>
</li>
<li><p>一个对象（ 或表达式） 是不是常量表达式由它的数据类型和初始值共同决定  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221351129.png" alt="image-20220705221351129"></p>
<p>![image-20220705221413365](D:\书本和读书笔记\Primer C++ 第五版（第一部分 C++基础  第二章 变量和基本类型）.assets\image-20220705221413365.png)</p>
</li>
</ol>
<h5 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h5><ol>
<li>C++11 新标准规定， 允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式 </li>
<li>声明为 constexpr 的变量一定是一个常量， 而且必须用常量表达式初始化：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221643749.png" alt="image-20220705221643749"></li>
<li>注意事项：<ol>
<li>函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量。  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） </li>
<li>相反的， 定义于所有函数体之外的对象其地址固定不变， 能用来初始化 constexpr 指针  </li>
<li>允许函数定义一类有效范围超出函数本身的变量  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） ， 这类变量和定义在函数体之外的变量一样也有固定地址。 因此， constexpr 引用能绑定到这样的变量上， constexpr 指针也能指向这样的变量。  </li>
</ol>
</li>
</ol>
<h5 id="字面值类型-（-literal-type"><a href="#字面值类型-（-literal-type" class="headerlink" title="字面值类型  （ literal type)"></a>字面值类型  （ literal type)</h5><ul>
<li>问题情景：常量表达式的值需要在编译时就得到计算， 因此对声明 constexpr 时用到的类型必须有所限制  </li>
<li>这些类型一般比较简单， 值也显而易见、 容易得到， 就把它们称为“ 字面值类型”（ literal type)。</li>
<li>有哪些？<ul>
<li> 算术类型、 引用和指针都属于字面值类型  </li>
<li> 自定义类 Sales_item、 10 库、 string 类型则不属于字面值类型， 也就不能被定义成constexpr  </li>
<li> 其他字面值类型<a href = "#">7.5.6 节（ 第 267 页） 和 19.3 节（ 第 736 页）  </a></li>
</ul>
</li>
<li>指针和引用都能定义成 constexpr, 但它们的初始值却受到严格限制  </li>
<li>一个constexpr 指针的初始值必须是nullptr 或者 0,或者是存储于某个固定地址中的对象  </li>
</ul>
<h5 id="指针和-constexpr"><a href="#指针和-constexpr" class="headerlink" title="指针和 constexpr"></a>指针和 constexpr</h5><ul>
<li><p>在 constexpr 声明中如果定义了一个指针， 限定符 constexpr 仅  对指针有效， 与指针所指的对象无关</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223219365.png" alt="image-20220705223219365"></p>
</li>
</ul>
<p>​        p 是一个指向常量的指针， 而 q 是一个常量指针， 其中的关键在于 constexpr 把它所定义的对象置为了顶层 const <a href="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>.</p>
<ul>
<li><p>constexpr 指针既可以指向常量也可以指向一个非常量：  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223703473.png" alt="image-20220705223703473"></p>
</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">83ddaccf0684812d1829b07735b89f52</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="83ddaccf0684812d1829b07735b89f52">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>20 分钟  <i class="fas fa-pencil-alt"> </i>3.0 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）</a></h1><div class="content"><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>基于其他类型定义的类型 </li>
<li>本章将介绍其中的两种： 引用和指针  </li>
<li>声明语句 :基本数据类型（ base type)  +  声明符( declarator) 列表  </li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol>
<li><p>概念：对象起了另外一个名字  </p>
<pre><code>引用类型引用（ refers to) 另外一种类型  ？（这话什么意思?）
</code></pre>
</li>
<li><p>如何定义：将声明符写成 &amp;d 的形式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival； 	<span class="comment">// refVal 指向 ival ( 是 ival 的另一个名字 ）</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal；	<span class="comment">// 报错： 引用必须被初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用的实质：</p>
<ol>
<li><p>定义引用时， 程序把引用和它的初始值绑定（ bind) 在一起， 而不是将初始值拷贝给引用。   </p>
<ol>
<li>定义初始化引用和定义变量的区别：在初始化变量时， 初始值会被拷贝到新建的对象中；  </li>
</ol>
</li>
<li><p>一旦初始化完成， 引用将和它的初始值对象一直绑定在一起。 因为无法令引用重新绑定到另外一个对象， 因此引用必须初始化。 </p>
</li>
<li><p>引用并非对象， 相反的， 它只是为一个已经存在的对象所起的另外一个名字 </p>
</li>
<li><p>定义了一个引用之后， 对其进行的所有操作都是在与之绑定的对象上进行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把 2 賦给 refVal 指向的对象 ， 此处即是賦给了 ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal; <span class="comment">// 与ii = ival 执行结果一样</span></span><br><span class="line"><span class="comment">//正确： refVal3 绑定到了那个与 refVal 绑定的对象上， 这里就是绑定到 ival 上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">// 利 用 与 refVal 绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="keyword">int</span> i = refVal; <span class="comment">// 正确： i被初始化为 ival 的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h5><ul>
<li><p>允许在一条语句中定义多个引用， 其中每个引用标识符都必须以符号 &amp;开头 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>,i2 = <span class="number">2048</span>; <span class="comment">//i和i2 都是 int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r =i, r2 =i2;<span class="comment">// r 是一个引用， 与i绑定在一起， r2 是 int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri =i3; <span class="comment">//i3 是 int, ri是一个引用， 与i3 绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 =i2; <span class="comment">// r3 和 r4 都是引用</span></span><br></pre></td></tr></table></figure></li>
<li><p>所有引用的类型都要和与之绑定的对象严格匹配 ；（<a> </a><a href = "#2.4.1    const 的引用 ">2.4.1节</a>  、 <a href="#15.2.3    ">15.2.3节</a>将会介绍两种特殊情况） </p>
</li>
<li><p>引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起 （<a href= "#2.4.1    const 的引用">2.4.1 节详述 </a>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>; <span class="comment">// 错误： 引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval; <span class="comment">// 错误： 此处引用类型的初始值必须是 int 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol>
<li><p>定义：“ 指向（ point to)” 另外一种类型的复合类型  </p>
</li>
<li><p>作用：实现了对其他对象的间接访问  </p>
</li>
<li><p>指针和引用的区别：</p>
<ol>
<li>指针本身就是一个对象， 允许对指针赋值和拷贝</li>
<li>在指针的生命周期内它可以先后指向几个不同的对象  </li>
<li>指针无须在定义时赋初值</li>
<li>块作用域内定义的指针如果没有被初始化， 也将拥有一个不确定的值，这和和其他内置类型一样</li>
</ol>
</li>
<li><p>定义指针类型的方法 </p>
<ul>
<li><p>将声明符写成*d 的形式 </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ipl，*ip2； <span class="comment">// ipl 和ip2 都是指向 int 型对象的指针</span></span><br><span class="line"><span class="keyword">double</span> dp，*dp2; <span class="comment">// dp2 是指向 double 型对象的指针， dp 是 double 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h5><ol>
<li><p>方法：取地址符（ 操作符 &amp; ):  </p>
</li>
<li><p>作用：指针存放某个对象的地址， &amp;获取该地址， </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p 存放变量 ival 的地址， 或者说p 是指向变量 ival 的指针</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项：</p>
<ol>
<li><p>引用不是对象， 没有实际地址， 所以不能定义指向引用的指针  </p>
</li>
<li><p>所有指针的类型都要和它所指向的对象严格匹配（<a href = "#2.4.2    指针和 const  ">2.4.2节</a>，<a href="#">15.2.3 节  </a>将介绍两种例外情况）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval；<span class="comment">// 正确： 初始值是 double 型对象的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd；<span class="comment">// 正确： 初始值是指向 double 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *pi = pd；<span class="comment">// 错误： 指针 pi 的类型和 pd 的类型不匹配</span></span><br><span class="line">pi = &amp;dval；<span class="comment">// 错误： 试图把 double 型对象的地址赋给 int 型指针</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>指针的值（ 即地址） 应属下列 4 种状态之一:  </p>
<ol>
<li>指向一个对象。  </li>
<li>指向紧邻对象所占空间的下一个位置。  </li>
<li>空指针， 意味着指针没有指向任何对象  </li>
<li>无效指针， 也就是上述情况之外的其他值  </li>
</ol>
<p>注意事项：</p>
<ol>
<li>试图拷贝或以其他方式访问无效指针的值都将引发错误（编译器不检查此类错误）</li>
<li>第 2 种和第 3 种形式的指针是有效的， 但其使用同样受到限制  ；这些指针没有指向任何具体对象， 所以试图访问此类指针（ 假定的） 对象的行为不被允许。</li>
</ol>
<h5 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h5><ol>
<li><p>如果指针指向了一个对象， 则允许使用解引用符（ 操作符* ) 来访问该对象:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">// p 存放着变量ival的地址， 或者说p 是指向变量ival的指针</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">// 由符号*得到指针 p 所指的对象， 输出 42</span></span><br></pre></td></tr></table></figure></li>
<li><p>对指针解引用会得出所指的对象  ;因此如果给解引用的结果赋值， 实际上也就是给指针所<br>指的对象赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;<span class="comment">// 由符号 *得到指针 p 所指的对象， 即可经由 p 为变量 ival 賦值</span></span><br><span class="line">cout &lt;&lt; *p； <span class="comment">//输出0</span></span><br><span class="line">cout &lt;&lt; ival； <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure></li>
<li><p>解引用操作仅适用于那些确实指向了某个对象的有效指针  </p>
</li>
<li><p>重点符号解析 <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705134829386.png" alt="image-20220705134829386"></p>
</li>
</ol>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><ol>
<li><p>空指针  （null pointer )   ：<br>不指向任何对象  </p>
</li>
<li><p>生成空指针的样例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705135446493.png" alt="image-20220705135446493"></p>
</li>
<li><p>注意事项：</p>
<p>在试图使用一个指针之前代码可以首先检查它是否为空  </p>
</li>
<li><p>拓展知识</p>
<ol>
<li>预处理变量（preprocessor variable)  ：NULL  给指针赋值， 这个变量在头文件 cstdlib 中定义， 它的值就是 0  </li>
<li>预处理器 （<a href = "# 2.6.3    编写自己的头文件 ">2.6.3 节</a>） ：是运行于编译过程之前的一段程序  <ol>
<li>预处理变量不属于命名空间 std  </li>
<li>由预处理器负责管理  </li>
</ol>
</li>
<li>关于给指针变量赋空指针的建议：<ol>
<li>最好使用 nullptr,同时尽量避免使用 NULL.  </li>
<li>把 int 变量直接陚给指针是错误的操作， 即使 int 变量的值恰好等于 0 也不行。<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140303477.png" alt="image-20220705140303477"></li>
<li>建议： 初始化所有指针<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140417164.png" alt="image-20220705140417164"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h5><ol>
<li><p>指针和引用的区别：</p>
<ol>
<li><p>指针，指针和他指向的对象之间的对应关系可以修改，也就是说，指针可以修改</p>
</li>
<li><p>引用，并不是一个对象，引用一旦确定是无法修改的</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705142026882.png" alt="image-20220705142026882"></p>
</li>
</ol>
</li>
<li><p>一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值  </p>
<ol>
<li><p>赋值永远改变的是等号左侧的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;ival;<span class="comment">// pi 的值被改变， 现在 pi 指向了 ival</span></span><br><span class="line"></span><br><span class="line">*pi = <span class="number">0</span>;<span class="comment">// ival 的值被改变， 指针pi 并没有改变,</span></span><br><span class="line">		<span class="comment">//*Pi( 也就是指针pi 指向的那个对象） 发生改变。</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h5><p>更过内容参见 <a href = "#3.5.3     指针和数组 ">3.5.3节</a> </p>
<p>只要指针拥有一个合法值， 就能将它用在条件表达式中。 和采用算术值作为条件（ <a href = " # 2.1.2    类型转换">2.1.2 节， 第 32 页</a> ） 遵循的规则类似， 如果指针的值是 0, 条件取 false:  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143008646.png" alt="image-20220705143008646"></p>
<p>指针比较的注意事项：</p>
<ol>
<li>两个类型相同的合法指针， 可以用相等操作符（=) 或不相等操作符（!=) 来比较它们， 比较的结果是布尔类型</li>
<li>两个指针存放的地址值相同， 则它们相等： 反之它们不相等。  </li>
<li>必须使用合法指针， 使用非法指针作为条件或进行比较都会引发不可预计的后果。</li>
</ol>
<h5 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h5><p>特殊的指针类型， 可用于存放任意对象的地址</p>
<p>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143502627.png" alt="image-20220705143502627"></p>
<ol>
<li>void* 指针 的作用<ol>
<li>和别的指针比较  </li>
<li>作为函数的输入或输出  </li>
<li>赋给另外一个 void*指针  </li>
</ol>
</li>
<li>void*不能做的事情<ol>
<li>不能直接操作 void*指针所指的对象， 因为我们并不知道这个对象到底是什么类型， 也就无法确定能在这个对象上做哪些操作  </li>
<li>详情参见<a href = "# ">19.1.1 节（ 第 726 页）  </a></li>
</ol>
</li>
<li>获取 void*指针所存地址的方法<br><a href = "# 4.11.3     显式转换 ">4.11.3 节（ 第 144<br>页）</a></li>
</ol>
<h4 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h4><ul>
<li>变量的定义包括 ：一个基本数据类型 （ base type) 和一组声明符  <ul>
<li>基本数据类型只有一个， 但是声明符的形式却可以不冋  <ul>
<li>一条定义语句可能定义出不同类型的变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144116016.png" alt="image-20220705144116016"></li>
</ul>
</li>
<li>很多程序员容易迷惑于基本数据类型和类型修饰符的关系， 其实后者（类修饰符）不过是声明符的一部分罢了。（读者问：为什么这么说？）  </li>
</ul>
</li>
</ul>
<h5 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h5><ol>
<li>场景误区1：<ol>
<li>在定义语句中， 类型修饰符（ <em>或 &amp; ) 作用于本次定义的全部变量  。样例如下：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144855828.png" alt="image-20220705144855828"></em></li>
<li>基本数据类型是 int 而非 int* ;   *仅仅是修饰了 p 而已， 对该声明语句中的其他变量， 它并不产生任何作用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145027723.png" alt="image-20220705145027723"> </li>
</ol>
</li>
<li>涉及指针（*）和引用（&amp;）的两种良好书写方式：<ol>
<li>把修饰符和变量标识符写在一起<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145121668.png" alt="image-20220705145121668"><br>着重强调变量具有的复合类型  </li>
<li>把修饰符和类型名写在一起， 并且每条语句只定义一个变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145234491.png" alt="image-20220705145234491"><br>着重强调本次声明定义了一种复合类型</li>
</ol>
</li>
</ol>
<h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><ul>
<li> 声明符中修饰符的个数并没有限制  </li>
<li> 多个修饰符连写在一起时， 按照 其逻辑关系详加解释即可  </li>
<li>样例：<ul>
<li>指针是内存中的对象， 像其他对象一样也有自己的地址， 因此允许把指针的地址再存放到另一个指针当中。这就是指向指针的指针  .</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145705407.png" alt="image-20220705145705407"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145719372.png" alt="image-20220705145719372"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145812143.png" alt="image-20220705145812143"></p>
<h5 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h5><ul>
<li><p>引用本身不是一个对象， 因此不能定义指向引用的指针。</p>
</li>
<li><p>但指针是对象， 所以存在对指针的引用  。</p>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145915375.png" alt="image-20220705145915375"></p>
<pre><code>解读方式：int *&amp;r = p;
1.最简单的办法是从右向左阅读 r 的定义
2.离变量名最近的符号（ 此例中是&amp;r 的符号&amp; ) 对变量的类型有最直接的影响， 因此 r 是一个引用。
3.声明符的其余部分用以确定 r 引用的类型是什么， 此例中的符号* 说明 r 引用的是一个指针。
4.最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。
</code></pre>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/#comment-container"><span class="display-none-class">ab6347e30ef93c668d39bdf0bae27331</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="ab6347e30ef93c668d39bdf0bae27331">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>15 分钟  <i class="fas fa-pencil-alt"> </i>2.2 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）</a></h1><div class="content"><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>具名的、 可供程序操作的存储空间；  </p>
</li>
<li><p>每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、 该空间能存储的值的范围， 以及变量能参与的运算。  </p>
</li>
</ul>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><h5 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h5><ol>
<li><p>首先是类型说明符 （ type specifier), 随后紧跟由一个或多个变量名组成的列表， 其中变量名以逗号分隔， 最后以分号结束；  </p>
</li>
<li><p>列表中每个变量名的类型都由类型说明符指定， 定义时还可以为一个或多个变量赋初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, value, units_sold = <span class="number">0</span>； 	<span class="comment">// sum、 value 和 units_sold 都是 int</span></span><br><span class="line">										<span class="comment">//units_sold 初值为 0</span></span><br><span class="line"></span><br><span class="line">Sales_item item；			<span class="comment">// item的类型是Sales_item(参见1.5.1节，第17页 ）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string是一种库类型,表示一个可变长的字符序列</span></span><br><span class="line">std::string <span class="built_in">book</span>(<span class="string">&quot;0-201-78345-X&quot;</span> )；<span class="comment">//book通过一个string字面值初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象初识：<br>一块能存储数据并具有某种类型的内存空间 。</p>
</li>
</ol>
<h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><p>当对象在创建时获得了一个特定的值， 我们说这个对象被初始化 （ initialized) 了。  </p>
<ol>
<li><p>于初始化变量的值可以是任意复杂的表达式 ；</p>
</li>
<li><p>当一次定义了两个或多个变量时， 对象的名字随着定义也就马上可以使用了  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ / 正确： price 先被定义并賦值， 随后被用于初始化 discount</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">109.99</span>, discount = price * <span class="number">0.16</span>;</span><br><span class="line">/ /正确： 调用函数 applyDiscount， 然后用函数的返回值初始化 <span class="function">salePrice</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> salePrice <span class="title">applyDiscount</span> <span class="params">(price, discount )</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化是一个异常复杂的问题 ；很多程序序员对于用等号=来初始化变量的方式倍感闲惑， 这种方式容易让人认为初始化足赋值的一种 </p>
<ul>
<li>初始化和赋值是两个完全不同的操作  </li>
<li>在很多编程语言中，二者的区别几乎可以忽略不计  </li>
<li>初始化不是賦值， 初始化的含义是创建变量时賦予其一个初始值， 而赋值的含义是把对象的当前值擦除， 而以一个新值来替代 </li>
</ul>
</li>
</ol>
<h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><ul>
<li><p>C++11 新标准的一部分  </p>
</li>
<li><p>```c++<br>int units_sold = 0；<br>int units_sold = {0}；//列表初始化<br>int units_sold{0}；//列表初始化<br>int units_sold(0)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 无论是初始化对象还是某些时候为对象赋新值， 都可以使用这样一组由花括号括起来的初始值了。</span><br><span class="line"></span><br><span class="line">- 当用于内置类型的变量时， 这种初始化形式有一个重要特点： </span><br><span class="line">      如果我们使用列表初始化初始值存在丢失信息的风险， 则编译器将报错：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  long double Id = 3.1415926536；</span><br><span class="line">  int a&#123;ld&#125;, b = &#123;Id&#125;；	//错误： 转换未执行， 因为存在去失信息的危险</span><br><span class="line">  int c(Id), d = Id；		//正确 ： 转换执行， 且确实丢失了部分值</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><ul>
<li>定义变量时没有指定初值， 则变量被默认初始化 （ default initialized )  </li>
<li>变量类型和定义变量的位置也会对此有影响。</li>
<li>内置类型的变量未被显式初始化， 它的值由定义的位置决定  </li>
<li>定义于任何函数体之外的变量被初始化为 0  </li>
<li>定义在函数体内部的内置类型变量将不被初始化（ uninitialized)。<ul>
<li> 未被初始化的内置类型变量的值是未定义的  </li>
<li> 试图拷贝或以其他形式访问此类值将引发错误。  </li>
</ul>
</li>
</ul>
<h4 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h4><h5 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h5><ol>
<li>目的：为了允许把程序拆分成多个逻辑部分来编写  </li>
<li>形式：允许将程序分割为若干个文件， 每个文件可被独立编译  </li>
<li>要求：需要有在文件间共享代码的方法  </li>
<li>例如：一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是 std::cout 和 std::cin,<br>它们定义于标准库， 却能被我们写的程序使用。</li>
<li>C++的支持模式：声明和定义分开<ol>
<li> 声明（ declaration) 使得名字为程序所知， 一个文件如果想使用别处定义的名字则必须包含对那个名字的声明  </li>
<li> 定义(definition) 负责创建与名字关联的实体。</li>
</ol>
</li>
</ol>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同  </p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同；定义还申请存储空间， 也可能会为变量赋一个初始值 </p>
<h5 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h5><ol>
<li><p>如果想声明一个变量而非定义它， 就在变量名前添加关键字 extern, 而且不要显式地初始化变量  </p>
</li>
<li><p>任何包含了显式初始化的声明即成为定义  </p>
</li>
<li><p>在函数体内部， 如果试图初始化一个由 extern 关键字标记的变量， 将引发错误</p>
</li>
<li><p>变量能且只能被定义一次， 但是可以被多次声明。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i； <span class="comment">// 声 明i而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j； <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>；<span class="comment">//声明并且定义了k，还为k申请了内存空间并且进行了显示初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span><span class="number">.16</span>; <span class="comment">// 定义    </span></span><br></pre></td></tr></table></figure></li>
<li><p>使用情景：</p>
<ol>
<li>如果要在多个文件中使用同一个变量， 就必须将声明和定义分离  </li>
<li>变量的定义必须出现在且只能出现在一个文件中， 而其他用到该变量的文件必须对其进行声明， 却绝对不能重复定义。 </li>
</ol>
</li>
</ol>
<h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110037691.png" alt="image-20220705110037691"></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li><p>由字母、 数字和下画线组成  </p>
</li>
<li><p>必须以字母或下画线开头  </p>
</li>
<li><p>长度没有限制 ；对大小写字母敏感  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ / 定义 <span class="number">4</span> 个不同的 <span class="keyword">int</span> 变量</span><br><span class="line"><span class="keyword">int</span> somename, someName, SomeName, SOMENAME;</span><br></pre></td></tr></table></figure></li>
<li><p>C++语言保留了一些名字供语言本身使用， 这些名字不能被用作标识符  ；如表 2.3 和表 2.4 所示<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110334152.png" alt="image-20220705110334152"><br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110356276.png" alt="image-20220705110356276"></p>
</li>
<li><p>用户自定义的标识符中不能连续出现两个下画线， 也不能以下画线紧连大写字母开头  </p>
</li>
<li><p>定义在函数体外的标识符不能以下画线开头。</p>
</li>
</ul>
<h5 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h5><ul>
<li> 标识符要能体现实际含义。</li>
<li> 变量名一般用小写字母， 如 index, 不要使用 Index 或 INDEX。</li>
<li> 用户自定义的类名一般以大写字母开头， 如 SaleS_item。</li>
<li> 如果标识符由多个单词组成， 则单词间应有明显区分，如student_loan或student_Loan；不要使用 studentloan.</li>
</ul>
<h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><ol>
<li><p>每个名字都会指向一个特定的实体： 变量、 函数、 类型等  </p>
</li>
<li><p>同—个名字如果出现在程序的不同位置， 也可能指向的是不同实体  </p>
</li>
<li><p>作用域  </p>
<ol>
<li>C++语言中大多数作用域都以花括号分隔。</li>
</ol>
</li>
<li><p>实例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705111857075.png" alt="image-20220705111857075"></p>
</li>
</ol>
<h5 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h5><ol>
<li><p>作用域能彼此包含  </p>
</li>
<li><p>内层作用域 ( innerscope )  ：被包含（ 或者说被嵌套） 的作用域  </p>
</li>
<li><p>外层作用域 ( outer scope)  ：包含着别的作用域的作用域  </p>
</li>
<li><p>作用域中一旦声明了某个名字， 它所嵌套着的所有作用域中都能访问该名字  </p>
</li>
<li><p>允许在内层作用域中重新定义外层作用域已有的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 该程序仅用于说明 ： 函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; / / reused 拥有全局作用域</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique <span class="number">0</span>; / / unique 拥有块作用域</span><br><span class="line">    <span class="comment">// 输出 #1: 使用全局变量 reused;输出 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量 reused， 覆盖了全局变量 reused</span></span><br><span class="line">    <span class="comment">// 输出 #2: 使用局部变量 reused; 输出 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出#3: 显式地访问全局变量 reused; 输出 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//全局作用域本身并没有名字， 所以当作用域操作符的左侧为空时， </span></span><br><span class="line">    <span class="comment">//向全局作用域发出请求获取作用域操作符右侧名字对应的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数有可能用到某全局变量， 则不宜再定义一个同名的局部变量 </p>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">4f414a57dff37f6a58bd2f6e4d685fc6</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="4f414a57dff37f6a58bd2f6e4d685fc6">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>12 分钟  <i class="fas fa-pencil-alt"> </i>1.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）</a></h1><div class="content"><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><ul>
<li>包括算术类型（ arithmetic type ) 和空类型（ void)   </li>
</ul>
<h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><ol>
<li><p>整型（ integral type， 包括字符和布尔类型在内）   </p>
</li>
<li><p>浮点型 </p>
<p>算术类型的取值范围 </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630182629855.png" alt="image-20220630182629855"></p>
<ul>
<li>扩展字符集<ul>
<li>wchar_t, char16_t、 char32_t  </li>
<li>用于确保可以存放机器最大扩展字符集士的任意一个字符  </li>
<li>char16_t 和char32_t 则为 Unicode 字符集服务 (Unicode 是用于表示所有自然语言中字符的标准)  </li>
<li>大小关系：short &lt;=  int &lt;= long &lt;= long long;</li>
</ul>
</li>
<li>计算机内存单位转换<ul>
<li>寻址的最小内存块称为“ 字节（ byte )  ，一般一个字节由8比特组成</li>
<li>存储的基本单元称为 ‘‘ 字（ word )”， 它通常由几个字节组成  </li>
<li>字则由 32 或 64 比特构成， 也就是 4 或 8 字节  </li>
</ul>
</li>
<li>带符号类型和无符号类型  <ul>
<li>除去布尔型和扩展的字符型之外， 其他整型可以划分为带符号的（ signed) 和无符号<br>的（ unsigned) 两种  </li>
<li>带符号类型可以表示正数、 负数或 0  </li>
<li>无符号类型则仅能表示大于等于 0 的值。 </li>
</ul>
</li>
<li>字符型   <ul>
<li>char、 signed char 和 unsigned char  </li>
<li>类型 char 和类型 signed char 并不一样 </li>
<li>尽管字符型有三种， 但是字符的表现形式却只有两种： 带符号的和无符号的。 类型 char 实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定  </li>
</ul>
</li>
<li>数据类型选择准则<ul>
<li> 数值不可能为负时， 选用无符号类型</li>
<li> int 执行整数运算（short 常常显得太小  ）  </li>
<li> 整数运算的数值超过了int 的表示范围， 选用 long long（long 一般和 int有一样的尺寸）</li>
<li>算术表达式中不要使用 char 或 bool <ul>
<li> 类型 char 在一些机器上是有符号， 而在另一些机器上又是无符号，行运算特别容易出问题  ；</li>
<li> 如果你需要使用一个不大的整数，明确指定它的类型是 signed char 或者 unsigned char</li>
</ul>
</li>
<li> 执行浮点数运算选用 double, 这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几</li>
<li> long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视 。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>​                将对象从一种给定的类型转换 ( convert) 为另一种相关类型 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>; <span class="comment">// b 为真</span></span><br><span class="line"><span class="keyword">int</span> i = b;	<span class="comment">// i的值为 1</span></span><br><span class="line">i = <span class="number">3.14</span>;	<span class="comment">// i的值为 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;	<span class="comment">// pi 的值为 3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;	<span class="comment">// 假设 char 占 8 比特， c 的值为 255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;	<span class="comment">// 假设 char 占 8 比特， c2 的值是未定义的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非布尔类型  &gt; 布尔类型  :    初始值为 0 则结果为 false,否则结果为 true  </li>
<li>布尔值  &gt; 非布尔类型  :    初始值为 false 则结果为 0, 初始值为true 则结果为 1</li>
<li>浮点数  &gt;整数类型  :      值仅保留浮点数中小数点之前的部分。</li>
<li>整数 &gt;     浮点类型  :   整数部分不变，小数部分记为0；如果该整数所占的空间超过了浮点类型的容量， 精度可能有损失  </li>
<li>值  &gt; 无符号类型  :    初始值对无符号类型表示数值总数取模后的余数  ;</li>
<li>值  &gt;  带符号类型： 结果未定义；程序可能继续工作、可能崩溃，也可能生成垃圾数据</li>
</ul>
<h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><h5 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h5><ol>
<li><p>整型:</p>
<ul>
<li><p>以 0 开头的整数代表八进制数， </p>
</li>
<li><p>以 0x 或 0X 开头的代表十六进制数  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220703112008479.png" alt="image-20220703112008479"></p>
</li>
</ul>
</li>
<li><p>整型字面值具体的数据类型由它的值和符号决定  </p>
<ol>
<li>默认情况下， 十进制字面值是带符号数,八进制和十六进制字面值既可能是带符号的也可能是无符号的  ;</li>
<li>十进制字面值的类型是int、 long 和 long long 中尺寸最小的那个（例如， 三者当中最小是int), 当然前提<br>是这种类型要能容纳下当前的值  </li>
<li>八进制和十六进制字面值的类型是能容纳其数值的int、 unsignedint、 long、 unsigned long、 longlong 和 unsigned long long<br>中的尺寸最小者  </li>
<li>如果一个字面值连与之关联的最大的数据类型都放不下， 将产生错误  ;</li>
</ol>
</li>
</ol>
<h5 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h5><ol>
<li><p>字符字面值：单引号，单个字符</p>
</li>
<li><p>字符串字面值：双引号，零个或者多个字符</p>
<ol>
<li><p>常量字符构成的数组 ( array )  </p>
</li>
<li><p>编译器在每个字符串的结尾处添加一个空字符（ ‘\0’)  ;</p>
</li>
<li><p>字面值’ A’ 表示的就是单独的字符 A, 而字符串”A”则代表了一个字符的数组， 该数组包含两个字符： 一个是字母 A、 另一个是空字符;</p>
</li>
<li><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705093933509.png" alt="image-20220705093933509"></p>
</li>
<li><p>分行书写字符串：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094045581.png" alt="image-20220705094045581"></p>
</li>
</ol>
</li>
</ol>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><ol>
<li>程序员不可使用的两类字符：<ol>
<li>不可打印字符：退格或其他控制字符，因为他们没有可视的图符</li>
<li>转义序列：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094438754.png" alt="image-20220705094438754"></li>
</ol>
</li>
</ol>
<h5 id="泛化的转义序列"><a href="#泛化的转义序列" class="headerlink" title="泛化的转义序列"></a>泛化的转义序列</h5><ol>
<li><p>\x 后紧跟 1 个或多个十六进制数字 </p>
</li>
<li><p>\后紧跟 1 个、 2 个或 3 个八进制数字  </p>
</li>
<li><p>数字部分表示的是字符对应的数值  </p>
</li>
<li><p>以Latin-1 字符集  实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094653556.png" alt="image-20220705094653556"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>;		<span class="comment">// 输出 Hi MOM!, 转到新一行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;			<span class="comment">//输出 M, 转到新一行</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ol>
<li><p>反斜线\后面跟着的八进制数字超过 3 个， 只有前 3 个数字与\构成转义序列<br>例如， “\1234”表示 2 个字符， 即八进制数 123 对应的字符以及字符 4。  </p>
</li>
<li><p>\x要用到后面跟着的所有数字， 例如， “\x1234” 表示一个 16 位的字符， 该字符由这 4 个十六进制数所对应的比特唯一确定。  </p>
<p>读者不理解的地方：    </p>
<ul>
<li>因为大多数机器的 char 型数据占 8 位， 所以上面这个例子可能会报错。 一般来说， 超过 8 位的十六进制字符都是与表 2.2 中某个前缀作为开头的扩展字符集一起使用的。  </li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h5><p>​    通过添加如表 2.2 中所列的前缀和后缀， 可以改变整型、 浮点型和字符型字面值的默认类型。<br> <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095748545.png" alt="image-20220705095748545"></p>
<p>实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095835204.png" alt="image-20220705095835204"></p>
<h5 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h5><ol>
<li>布尔字面值<ol>
<li>true 和 false 是布尔类型的字面值  </li>
</ol>
</li>
<li>指针字面值<ol>
<li>nullptr 是指针字面值， 2.3.2 节（ 第 47 页） 将有更多关丁•指针和指针字面值的介绍  </li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="C++Primer 第五版 第一章"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-03  <a class="commentCountImg" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/#comment-container"><span class="display-none-class">b6ac0b7125778ed92f89b6ee5b71136d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b6ac0b7125778ed92f89b6ee5b71136d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 分钟  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/">C++Primer 第五版 第一章</a></h1><div class="content"><h1 id="C-Primer-第五版-第一章"><a href="#C-Primer-第五版-第一章" class="headerlink" title="C++Primer 第五版 第一章"></a>C++Primer 第五版 第一章</h1><h2 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章    开始"></a>第1章    开始</h2><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1    编写一个简单的C++程序"></a>1.1    编写一个简单的C++程序</h3><ol>
<li><p>函数组成=返回类型+函数名+形参列表+函数体</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/2022-06-30_124642.png"></p>
</li>
<li><p>注意事项</p>
<ul>
<li><p>main 函数的返回类型必须为 int  ；</p>
</li>
<li><p>int 类型是一种内置类型  ；</p>
</li>
<li><p>内置类型 （ built-in type ), 即语言自身定义的类型；</p>
</li>
<li><p>类型 ：不仅定义了数据元素的内容， 还定义了这类数据上可以进行的运算。  </p>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-1-编译、运行程序"><a href="#1-1-1-编译、运行程序" class="headerlink" title="1.1.1    编译、运行程序"></a>1.1.1    编译、运行程序</h4><ol>
<li><p>如何编译程序  ？</p>
<ul>
<li>依赖于操作系统和编译器  </li>
</ul>
</li>
<li><p>IDE  ：集成开发环境（ Integrated Developed Environment, IDE)  </p>
</li>
<li><p>特定编译器的相关使用细节， 请査阅参考手册或询问经验丰富的同事  </p>
</li>
<li><p>程序源文件命名约定  </p>
<ol>
<li>程序文件通常被称为源文件（ source file)  </li>
<li>源文件的名字以一个后缀为结尾  ，后缀是由一个句点后接一个或多个字符组成的  ；最常见的包括.CC、.cxx,.cPP、.cP 及.C </li>
</ol>
</li>
<li><p> 从命令行运行编译器  </p>
</li>
<li><p>源文件 progl.cc  </p>
</li>
<li><p>如下命令来编译  </p>
<ol>
<li><p>$ CC progl.cc  </p>
</li>
<li><p>CC 是编译器程序的名字， $是系统提示符。 编译器生成一个可执行文件。  </p>
</li>
<li><p>Windows  ：progl.exe</p>
<ol>
<li>progl.exe</li>
<li>$ progl  </li>
</ol>
</li>
<li><p>UNIX  :a.out</p>
<ol>
<li>a.out</li>
<li>$ a.out</li>
</ol>
</li>
<li><p>echo 命令获得其返回值  </p>
<ol>
<li>UNIX  : $ echo $?  </li>
<li>Windows  : $ echo %ERRORLKVEL%  </li>
</ol>
</li>
<li><p>特殊情况：须显式指出文件的位置  </p>
<ol>
<li>Windows  ：$ .\progl</li>
<li>Unix: $ ./a.out</li>
</ol>
</li>
<li><p>运行 GNU或微软编译器  </p>
<ol>
<li>Page 30</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2    初识输入输出"></a>1.2    初识输入输出</h3><ol>
<li>C++语言并未定义任何输入输出 (10 ) 语句  ;包含了一个全面的标准库( standard library) 来提供 10 机制（ 以及很多其他设施)</li>
<li>iostream 库  <ol>
<li>istream  输入流  </li>
<li>ostream  输出流  </li>
<li>流  <ol>
<li>一个流就是一个字符序列  </li>
<li>术语“ 流”（ stream)   :随着时间的推移， 字符是顺序生成或消耗的  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h4><ol>
<li><p>定义了 4 个 IO 对象 </p>
<ol>
<li> cin  </li>
<li>istream 类型的对象  </li>
<li>标准输入（ standard input)  </li>
<li>cout    <ol>
<li>ostream 类型的对象  </li>
<li>标准输出（ standard output)  </li>
</ol>
</li>
<li>cerr  <ol>
<li>输出警告和错误消息  </li>
<li>标准错误 （ standard error)  </li>
</ol>
</li>
<li>clog  <ol>
<li>输出程序运行时的一般性信息  </li>
</ol>
</li>
</ol>
</li>
<li><p>一个使用 IO 库的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:</span></span><br><span class="line"><span class="string">	int vl = 0, v2 = 0;</span></span><br><span class="line"><span class="string">	std::cin » vl » v2;</span></span><br><span class="line"><span class="string">	std::cout &lt;&lt; &quot;</span>The sum of <span class="string">&quot; &lt;&lt; vl &lt;&lt; &quot;</span> <span class="keyword">and</span> <span class="string">&quot; &lt;&lt; v2&lt;&lt; &quot;</span> is <span class="string">&quot; &lt;&lt; vl + v2 &lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">	« std::endl;</span></span><br><span class="line"><span class="string">	return 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>头文件（ header)  <ol>
<li>指令和头文件的名字必须写在同一行中  </li>
<li>放在源文件的开始位置  </li>
<li>必须出现在所有函数之外 </li>
</ol>
</li>
</ol>
</li>
<li><p> 向流写入数据  </p>
</li>
<li><p>表达式（ expression)  : 一个或多个运算对象和（ 通常是） 一个运算符组成  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout « <span class="string">&quot;Enter two numbers: &lt;&lt; std::endl;  </span></span><br></pre></td></tr></table></figure></li>
<li><p>输出运算符（&lt;&lt;)  </p>
<ol>
<li><p>&lt;&lt;运算符接受两个运算对象： 左侧的运算对象必须是一个 ostream 对象， 右侧的运算对<br>象是要打印的值  </p>
</li>
<li><p>此运算符返回其左侧的运算对象  </p>
</li>
<li><p>将给定的值写到给定的 ostream 对象中  </p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(std::cout « <span class="string">&quot;Enter two numbers:&quot;</span> ) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span>；</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串字面值常量  “Enter two numbers:”</p>
<ol>
<li>双引号包围的字符序列  ，双引号之间的文本被打印到标准输出  </li>
</ol>
</li>
<li><p>endl  </p>
<ol>
<li>操纵符（ manipulator);  特殊值  </li>
<li>效果是结束当前行， 并将与设备关联的缓冲区 （ buffer) 中的内容刷到设备中  </li>
</ol>
</li>
</ol>
</li>
<li><p>使用标准库中的名字  </p>
<ol>
<li>std::cout 和 std::endl  </li>
<li>std 的命名空间(namespace)   </li>
<li>避免不经意的名字定义冲突  ,以及使用库中相同名字导致的冲突  </li>
<li>作用域运算符 (::)   </li>
</ol>
</li>
<li><p>从流读取数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl &gt;&gt; v2;  </span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入运算符（ &gt;&gt;)</p>
<ol>
<li><p>从给定的 istream 读入数据， 并存入给定对象中  </p>
</li>
<li><p>返回其左侧运算对象作为其计算结果</p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( std::cin &gt;&gt; vl ) &gt;&gt; v2;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl;</span><br><span class="line">std::cin &gt;&gt; v2;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3    注释简介"></a>1.3    注释简介</h3><p>C++中注释的种类  </p>
<ul>
<li>C++中有两种注释： <ul>
<li>单行注释:以双斜线 ( / / ) 开始， 以换行符结束  ;当前行双斜线右侧的所有内容都会被编译器忽略  </li>
</ul>
</li>
<li>界定符对注释  <ul>
<li>继承自 C 语言的两个界定符（ /*<em>和</em> */ )  </li>
<li>落在/<strong>和</strong> <em>/之间的所有内容都当作注释 ; 可以包含除</em> /外的任意内容， 包括换行符  </li>
<li>注释界定符不能嵌套  </li>
</ul>
</li>
</ul>
<h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4    控制流"></a>1.4    控制流</h3><h4 id="1-4-1-while语句"><a href="#1-4-1-while语句" class="headerlink" title="1.4.1    while语句"></a>1.4.1    while语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630141324624.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &#123;condition)</span><br><span class="line">statement  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行过程是交替地检测 condition 条件和执行关联的语句statement  ，直到condition为假时停止  </p>
</li>
<li><p>小于等于运算符（&lt;=)</p>
</li>
<li><p>复合赋值运算符 （ +=)  </p>
</li>
<li><p>前缀递增运算符 （ ++ )  </p>
</li>
</ul>
<h4 id="1-4-2-for语句"><a href="#1-4-2-for语句" class="headerlink" title="1.4.2    for语句"></a>1.4.2    for语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> sum</span><br><span class="line">    / / 从 <span class="number">1</span>加到 <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">      sum += val; <span class="comment">// 等 价 于 + val  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	sum += sum = sum</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3     读取数量不定的输入数据"></a>1.4.3     读取数量不定的输入数据</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630142805148.png"></p>
<ul>
<li>使用一个 istream 对象作为条件时 ,其效果是检测流的状态;</li>
<li>流是有效的， 即流未遇到错误， 那么检测成功    </li>
<li>遇到文件结束符 ( end-of-file), 或遇到一个无效输入时（ 例如读入的值不是一个整数）， istream 对象的状态会变为无效  </li>
<li>如何指出文件结束  <ul>
<li>Windows 系统  <ul>
<li>敲 Ctrl+Z ( 按住 Ctrl 键的同时按 Z 键 ），然后按 Enter 或 Return 键  </li>
</ul>
</li>
<li>UNIX 系统  /MacOSX 系统  <ul>
<li>Ctrl+D  </li>
</ul>
</li>
</ul>
</li>
<li>再 探 编 译  <ul>
<li>语法错误（ syntax error )  </li>
<li>类型错误（ type error )  </li>
<li>声明错误（ declaration error )  </li>
<li>按照错误信息报告的顺序来逐个修正错误， 是一种好习惯  。因为单个错误常常会具有传递效应 ， 导致编译器在其后报告比实际数量多得多的错误信息。 另一个好习惯是在每修正一个错误后就立即重新编译代码， 或者最多是修正了一小部分明显的错误后就重新编译 ： 这就是所谓的 “编辑-编译-调试 ”（ edit-compile-debug ) 周期。  </li>
</ul>
</li>
</ul>
<h4 id="1-4-4-if语句"><a href="#1-4-4-if语句" class="headerlink" title="1.4.4    if语句"></a>1.4.4    if语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630143559254.png"></p>
<ul>
<li><p>相等运算符（ ==) </p>
<ul>
<li>C++用=进行赋值， 用==作为相等运算符；两个运算符都可以出现在条件中 。一个常见的错误是想在条件中使用== ( 相等判断 ）， 却误用了= 。</li>
</ul>
</li>
</ul>
<h3 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5    类简介"></a>1.5    类简介</h3><ul>
<li>类机制是 C++最重要的特性之一  </li>
<li>一个类定义了一个类型， 以及与其关联的一组操作  </li>
<li>通过定义一个类 (class) 来定义自己的数据结构 </li>
<li>使用头文件来访问为自己的应用程序所定义的类  <ul>
<li> 通常使用.h 作为头文件的后缀  </li>
<li>一些程序员习惯.H、 .hpp 或.hxx  </li>
<li>标准库头文件通常不带后缀  </li>
</ul>
</li>
<li>类的作者决定了类类型对象上可以使用的所有操作  </li>
</ul>
<h4 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1    Sales_item类"></a>1.5.1    Sales_item类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item item;</span><br></pre></td></tr></table></figure>

<p>表达 item 是一个 Sales_item 类型的对象。 我们通常将“ 一个 Sales_item 类型的对象” 简单说成“ 一个 Sales_item 对象”， 或更简单的“ 一个 Sales_item”。</p>
<h4 id="读写Sales-item"><a href="#读写Sales-item" class="headerlink" title="读写Sales_item"></a>读写Sales_item</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630150431130.png"></p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li><p>来自标准库的头文件 ：应该用尖括号（&lt; &gt;) 包围头文件名  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>不属于标准库的头文件  ：用双引号（ “ “） 包围  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_item.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Sales-item-对象的加法"><a href="#Sales-item-对象的加法" class="headerlink" title="Sales_item 对象的加法"></a>Sales_item 对象的加法</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630151614240.png"></p>
<p>对于 Sales_item 对象， 我们用了一个全新的“ 和” 的概念 : 两个 Sales_item 对象的成员对应相加的结果。</p>
<h4 id="使用文件取定向"><a href="#使用文件取定向" class="headerlink" title="使用文件取定向"></a>使用文件取定向</h4><p>​        当你测试程序时， 反复从键盘敲入这些销售记录作为程序的输入， 是非常乏味的 。大多数操作系统支持文件重定向， 这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addlterns &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>假定$是操作系统提示符， 我们的加法程序已经编译为名为 addltems.exe 的可执行文件（ 在 UNIX 中addltems ). 则上述命令会从一个名为 infile 的文件读取销售记录， 并将输出结果写入到一个名为 outfile 的文件中， 两个文件都位于当前目录中。  </p>
<h4 id="1-5-2-初识成员函数"><a href="#1-5-2-初识成员函数" class="headerlink" title="1.5.2    初识成员函数"></a>1.5.2    初识成员函数</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152050811.png"></p>
<ol>
<li>什么是成员函数？  <ol>
<li>成员函数是定义为类的一部分的函数， 有时也被称为方法（ method)。</li>
<li>通常以一个类对象的名义来调用成员函数：iteml.isbn ( )      </li>
<li>点运算符（.）  <ol>
<li>只能用于类类型的对象。   </li>
<li>左侧运算对象必须是一个类类型的对象， 右侧运算对象必须是该类型<br>的一个成员名， 运算结果为右侧运算对象指定的成员  </li>
</ol>
</li>
<li>调用运算符（（ ） ）  <ol>
<li>调用运算符是一对圆括号， 里面放置实参( argument) 列表（ 可能为空）  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-6-书店程序"><a href="#1-6-书店程序" class="headerlink" title="1.6    书店程序"></a>1.6    书店程序</h3><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152712392.png"></p>
<h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><ol>
<li>参数（ 实参， argument ) 向函数传递的值。  </li>
<li>赋值 ( assignment) 抹去一个对象的当前值， 用一个新值取代之。</li>
<li>程序块（ block ) 零条或多条语句的序列，用花括号包围。</li>
<li>缓冲区（ buffer ) —个存储区域， 用于保存数据。 IO 设施通常将输入 （ 或输出） 数据保存在一个缓冲区中， 读写缓冲区的动作与程序中的动作是无关的。 我们可以显式地刷新输出缓冲， 以便强制将缓冲区中的<br>数据写入输出设备。 默认情况下， 读 cin会刷新 cout； 程序非正常终止时也会刷新couto  </li>
<li>内置类型（ built-in type ) 由语言定义的类型， 如 int.</li>
<li>Cerr 一 个 ostream 对象， 关联到标准错误， 通常写入到与标准输出相同的设备。 默认情况下， 写到<br>Cerr的数据是不缓冲的，Cerr通常用于输出错误倍息或其他不屑于程序正常逻辑的输出内容  </li>
<li>字 符 串 字 面 值 常 量 （ character string literal) 术语 string literal 的另一种叫法  </li>
<li>cin —个 istream 对象， 用来从标准输入读取数据。  </li>
<li>类 (class) 一种用于定义自己的数据结构及其相关操作的机制。 类是 C++中最基木的特性之 一。 标准库类型中， 如 istream和ostream  都是类  </li>
<li>类 类 型 （ class type ) 类定义的类型。 类名即为类型名  </li>
<li>clog 一 个 ostream 对象， 关联到标准错误。 默认情况下， 写到 clog 的数据是被缓冲的。 clog 通常用于报告程序的执行信息. 存入一个日志文件中  </li>
<li>注 释（ comment) 被编译器忽略的程序文本。 C++有两种类羽的注释： 单行注释和界定符对注释。 单行注释以/ / 开始， 从 / /到行尾的所有内容都是注释。 界定符对注释以/ * 汗始， 其后的所有内容都萣注释,直至遇到* / 为止。    </li>
<li>条 件 ( condition) 求值结果为真或假的表达式。 通常用值 0 表示假， 用非零表示真。  </li>
<li>cout  一个 ostream 对象， 用于将数据写入标准输出。 通常用于程序的正常输出内容。  </li>
<li>花括号 ( curly brace ) 花括号用于划定程序块边界。 左花括号 ( { ) 为程序块开始，右花括号（ } ) 为结朿。  </li>
<li>数据结构 (data structure) 数据及其上所允许的操作的 一种逻辑组合。  </li>
<li>编辑-编译-调试 （ edit-compile-debug ) 使程序能正确执行的开发过程  </li>
<li>文件结束符 （ end-of-file) 系统特定的标识， 指出文件中无更多数据了。</li>
<li>表达式 （ expression ) 最小的计算单元。 一个表达式包含 一 个或多个运算对象， 通常还含 一个或多个运算符。 表达式求值会产生一个结果。 例如， 假设i和 j 是 int对象， 则i+j 是一个表达式, 它产生两个  int 值的和。  </li>
<li>……  </li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/read.jpg" alt="《社会性动物》第一部分：检视阅读笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-05-03  <a class="commentCountImg" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/#comment-container"><span class="display-none-class">230e6212d8810ed62f9830005d23aeaa</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="230e6212d8810ed62f9830005d23aeaa">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>10.9 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/">《社会性动物》第一部分：检视阅读笔记</a></h1><div class="content"><h1 id="社会性动物"><a href="#社会性动物" class="headerlink" title="社会性动物"></a>社会性动物</h1><h2 id="阅读Tips"><a href="#阅读Tips" class="headerlink" title="阅读Tips"></a>阅读Tips</h2><h3 id="阅读步骤"><a href="#阅读步骤" class="headerlink" title="阅读步骤"></a>阅读步骤</h3><ul>
<li><p>检视阅读</p>
<ul>
<li><p>检视阅读第一层</p>
<ul>
<li>子主题 1</li>
</ul>
</li>
<li><p>检视阅读第二层</p>
</li>
<li><p>检视阅读的问题</p>
<ul>
<li>这本书在谈什么</li>
<li>这本书的架构如何</li>
<li>这本书分为哪些部分</li>
<li>这是什么类型的书籍</li>
</ul>
</li>
<li><p>检视阅读的目的</p>
<ul>
<li>有限的时间内，最好最完整的阅读（就是系统的略读）</li>
</ul>
</li>
</ul>
</li>
<li><p>分析阅读</p>
<ul>
<li><p>阅读原则：无限时间内最完整最好的全盘系统化的阅读</p>
</li>
<li><p>分析阅读步骤</p>
<ul>
<li>1、书籍分类</li>
<li>2、简要概括书本内容</li>
<li>3、列出重要篇章，看他们</li>
<li>4、找出作者想问的问题或者想要解决的问题</li>
<li>5、找出共通的词义</li>
<li>6、从重要句子中解析作者想要表达的主旨</li>
<li>7、找出作者的 论述以及前因后果，以明白作者的主张；</li>
<li>8、明确作者解决了哪些问题；哪些是未解决的；在未解决的问题中，哪些是作者认为无法解决的。</li>
<li>10、对一本书进行整体评价；但是要注意评价的智慧礼节和批评观点的特别标准。</li>
</ul>
</li>
</ul>
</li>
<li><p>主题阅读</p>
</li>
</ul>
<h3 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h3><ul>
<li><p>书本笔记</p>
<ul>
<li><p>笔记时间</p>
<ul>
<li>检视阅读第一层</li>
</ul>
</li>
<li><p>笔记规则</p>
<ul>
<li><p>在书上做笔记</p>
<ul>
<li><p>好处</p>
<ul>
<li>1.保持十分清醒，集中注意力</li>
<li>2.主动阅读也是一种思考，既然是思考，我们就应该可以表达出来，不管是用写的还是说的。</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>1.画底线</p>
<ul>
<li>主要的重点、重要切有力的句子</li>
</ul>
</li>
<li><p>2.底线栏外再画一条线</p>
<ul>
<li>着重强调1的重要性，并且避免底线过长。</li>
</ul>
</li>
<li><p>3.空白处画星号或其他符号</p>
<ul>
<li>标记书中少数十分重要的声明或者段落；还可以折角加以标记。慎用！</li>
</ul>
</li>
<li><p>4.空白处编号</p>
<ul>
<li>作者的某个重要论点发展出来的一系列重要论述。</li>
</ul>
</li>
<li><p>5.空白处记下其他的页码</p>
<ul>
<li>标记作者在书中其他位置相同相似的论点甚至是相反的论点；这样可以让全书散落的想法统一起来。CF(参照或者比较)</li>
</ul>
</li>
<li><p>6.关键字或句子圈出来</p>
<ul>
<li>作用同1</li>
</ul>
</li>
<li><p>7.书页中的空白处做笔记</p>
<ul>
<li>1.记录读者的一些问题或者答案</li>
<li>2.将复杂的论点简化说明</li>
<li>3.记录全书主要论点的发展顺序</li>
<li>4.书中最后一页作为读者索引,依序记录作者主要观点</li>
</ul>
</li>
<li><p>8.在最后一页写下读者索引,在第一页写下本书大纲,写出本书整体架构,列出基本大纲和前后篇章次序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结构笔记</p>
<ul>
<li><p>检视阅读的三个问题</p>
<ul>
<li>这是一本什么样的书</li>
<li>整本书在谈什么</li>
<li>作者借着什么样的架构,来发展他的观点或者陈述他对这个主题的理解</li>
</ul>
</li>
<li><p>笔记的重点是全书的结构,而不是内容,至少不是细节</p>
</li>
</ul>
</li>
<li><p>概念笔记</p>
<ul>
<li><p>什么是概念笔记</p>
<ul>
<li>概念既是作者的观点,在我们进行检视阅读的时候,读者也许可以掌握作者所要表达的一些观点。但是对这些观点的准确性和意义，我们需要在分析阅读中去寻找答案。当读者阅读的深度和广度增加之后，自然也会出现自己的观点。</li>
</ul>
</li>
<li><p>另一种概念笔记</p>
<ul>
<li>在我们进行主题阅读的时候，我们会阅读主题相关的多本书籍，这个时候的笔记应该也是概念笔记。只是这个时候我们在书中空白页处记下 的页码不再是本书的，也有些是其他书中的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="阅读反思"><a href="#阅读反思" class="headerlink" title="阅读反思"></a>阅读反思</h3><p>（主动阅读者该做的一些工作）</p>
<ul>
<li>1、整体来说，这本书在谈什么？</li>
<li>2、作者细说了什么？又是怎么说的？</li>
<li>3、作者说的有道理吗？</li>
<li>4、这本书和我有什么关系</li>
</ul>
<h2 id="阅读笔记-1"><a href="#阅读笔记-1" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h3><ul>
<li><p>结构笔记</p>
<ul>
<li><p>包含内容：读者大纲、名词解释、好句摘录</p>
</li>
<li><p>书本大纲</p>
<ul>
<li><p>第一章：什么是社会心理学</p>
<ul>
<li><p>第一部分：定义</p>
<ul>
<li>社会心理学定义</li>
</ul>
</li>
<li><p>关于社会影响的几个问题</p>
<ul>
<li>影响的定义</li>
<li>如何影响人们</li>
<li>影响的隐含意义</li>
<li>影响的持续性和变量因素</li>
<li>影响的强弱和变量因素</li>
</ul>
</li>
<li><p>特定环境影响人类行为的论述</p>
</li>
</ul>
</li>
<li><p>第二章：从众</p>
<ul>
<li><p>第一部分;定义</p>
<ul>
<li>从众的定义</li>
<li>群体压力的定义</li>
<li>群体压力的几个问题</li>
</ul>
</li>
<li><p>第二部分：增强和减弱从众的因素</p>
<ul>
<li>一致性</li>
<li>表态</li>
<li>责任</li>
<li>个体和文化</li>
<li>施加压力的群体</li>
</ul>
</li>
<li><p>第三部分：从众的原因：奖惩和信息</p>
<ul>
<li>浪费水资源和乱丢垃圾</li>
<li>社会影响和情绪</li>
<li>社会影响：生和死</li>
</ul>
</li>
<li><p>第四部分:对社会影响的态度</p>
<ul>
<li><p>依从</p>
<ul>
<li>服从和依从的关系</li>
<li>米尔格拉姆实验中的不服从</li>
</ul>
</li>
<li><p>认同</p>
</li>
<li><p>内化</p>
</li>
</ul>
</li>
<li><p>第四部分：不介入的旁观者是从众者</p>
</li>
<li><p>第五部分：从众实验中的伦理问题</p>
</li>
</ul>
</li>
<li><p>第三章：大众传播、宣传和说服</p>
<ul>
<li><p>第一部分：</p>
<ul>
<li>说服的努力</li>
<li>媒体感染</li>
<li>政治家就是演员</li>
<li>借助感染力的效果</li>
<li>教育还是宣传？</li>
</ul>
</li>
<li><p>第二部分：说服的两种路径</p>
<ul>
<li>中心路径说服</li>
<li>边缘路径说服</li>
</ul>
</li>
<li><p>第三部分：宣传的来源</p>
<ul>
<li>可信性</li>
<li>可信性的增加</li>
<li>吸引力</li>
</ul>
</li>
<li><p>第四部分：宣传的性质</p>
<ul>
<li>借助理性</li>
<li>借助情感</li>
<li>恐怖和恐怖主义的威胁</li>
<li>一致性的统计证据和个别例证</li>
<li>单方面例证和两方面例证</li>
<li>观点呈现的次序</li>
<li>差异的大小</li>
</ul>
</li>
<li><p>第五部分:接受者的特征</p>
<ul>
<li>自尊</li>
<li>接受者的前期经验</li>
</ul>
</li>
<li><p>第六部分：这些原则的作用方式</p>
</li>
</ul>
</li>
<li><p>第四章：社会认知</p>
<ul>
<li><p>第一部分:我们如何理解世界</p>
</li>
<li><p>第二部分：背景对社会判断的影响</p>
<ul>
<li>参照点和对比效应</li>
<li>启动和易接受性的形成</li>
<li>为决策设置框架</li>
<li>信息的先后次序</li>
<li>首因效应和印象形成</li>
<li>信息量</li>
</ul>
</li>
<li><p>第三部分：便捷式判断</p>
<ul>
<li>代表性便捷式判断</li>
<li>易得性便捷式判断</li>
<li>态度便捷式判断</li>
<li>人们何时会使用便捷式判断？</li>
</ul>
</li>
<li><p>第四部分：分类和社会定型</p>
<ul>
<li>定型化认识和预期</li>
<li>发现不存在的关系：虚假关联</li>
<li>内群体-外群体效应</li>
</ul>
</li>
<li><p>第四部分：重构性记忆</p>
</li>
<li><p>第五部分：自传性记忆</p>
<ul>
<li>记忆恢复现象</li>
</ul>
</li>
<li><p>第六部分：人类认知的保守性</p>
</li>
<li><p>第七部分：态度和信念如何指导行动</p>
<ul>
<li>人们心目中的态度和行为关系</li>
<li>什么时候态度可以预测行为</li>
<li>依据感知觉行动</li>
</ul>
</li>
<li><p>第八部分：社会解释中可能出现的三种偏差</p>
<ul>
<li><p>基本归因错误</p>
</li>
<li><p>行动者-观察者偏差</p>
</li>
<li><p>自我偏差</p>
<ul>
<li>自我偏差的价值</li>
</ul>
</li>
<li><p>自我对社会认知产生的影响</p>
<ul>
<li>自我中心思维</li>
<li>自利偏差</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第五章：自我辩护</p>
<ul>
<li><p>第一部分：自我辩护的定义和适用范围</p>
</li>
<li><p>第二部分：减少失调和理性行为</p>
</li>
<li><p>第三部分：决策造成的失调</p>
<ul>
<li>决策后果的一些历史例证</li>
</ul>
</li>
<li><p>第四部分：不可改变的重要性</p>
<ul>
<li>有关不道德行为的决策</li>
</ul>
</li>
<li><p>第五部分：不充分理由心理</p>
<ul>
<li>外部理由的构成</li>
<li>不充分理由</li>
<li>失调和自我概念</li>
<li>不充分奖赏在教育中的运用</li>
<li>不充分惩罚</li>
</ul>
</li>
<li><p>第六部分：为努力进行辩护</p>
</li>
<li><p>第七部分：为残忍进行辩护</p>
</li>
<li><p>第八部分：对待不可避免事件的心理</p>
</li>
<li><p>第九部分：自尊的重要作用</p>
</li>
<li><p>第十部分：是不安？还是自我知觉</p>
</li>
<li><p>第十一部分：失调对生理和动机的影响</p>
</li>
<li><p>第十二部分：失调理论的实际运用</p>
<ul>
<li>理解对灾难的反应</li>
<li>通过减少失调来减肥</li>
<li>失调与艾滋病预防</li>
<li>失调和水资源保护</li>
<li>对宗教领袖权威的解释</li>
<li>本拉登是在利用失调理论吗？</li>
</ul>
</li>
<li><p>第十三部分：减少失调和文化</p>
</li>
<li><p>第十四部分：“人”不能只靠和谐生活</p>
</li>
</ul>
</li>
<li><p>第六章：人类的攻击性</p>
<ul>
<li><p>第一部分：对攻击性的定义</p>
</li>
<li><p>第二部分：攻击性是本能的吗？</p>
</li>
<li><p>第三部分：攻击性是否有益</p>
<ul>
<li>适者生存</li>
<li>宣泄能发挥作用吗？</li>
<li>报复是过激行为</li>
</ul>
</li>
<li><p>第三部分：攻击的原因</p>
<ul>
<li>神经学和化学方面的原因</li>
<li>睾丸素</li>
<li>酒精类饮料</li>
<li>痛苦与不适</li>
<li>挫折与攻击</li>
<li>拒绝、排斥和奚落</li>
<li>社会学习和攻击性</li>
<li>社会学习、暴力和大众传媒</li>
<li>电视暴力的麻木效应</li>
<li>媒体暴力为什么会影响观众的攻击性</li>
<li>媒体、色情描写以及针对女性的暴力</li>
<li>暴力有助于推销吗？</li>
<li>用攻击性去吸引公众的注意</li>
</ul>
</li>
<li><p>第四部分：如何减少暴力</p>
<ul>
<li>纯粹的励志</li>
<li>惩罚</li>
<li>对攻击性榜样的惩罚</li>
<li>对替代性行为的奖赏</li>
<li>非攻击性榜样的作用</li>
<li>建立对他人的移情</li>
</ul>
</li>
</ul>
</li>
<li><p>第七章：偏见</p>
<ul>
<li><p>第一部分：定型和偏见</p>
<ul>
<li>定型威胁</li>
</ul>
</li>
<li><p>第二部分：定型和归因</p>
<ul>
<li>性别定型</li>
</ul>
</li>
<li><p>第三部分：归咎于受害者</p>
</li>
<li><p>第四部分：偏见和科学</p>
</li>
<li><p>第五部分：偏见的一些微妙影响</p>
<ul>
<li>不易察觉的性别歧视和性别角色社会化</li>
</ul>
</li>
<li><p>第六部分：偏见和媒体</p>
</li>
<li><p>第七部分：偏见的原因</p>
<ul>
<li>经济和政治竞争</li>
<li>替代性攻击：替罪羊理论</li>
<li>自我形象和地位的维持</li>
<li>带有偏见的人格</li>
<li>从众引起的偏见</li>
</ul>
</li>
<li><p>第八部分：国家干预可以改变民间偏见</p>
<ul>
<li>地位平等的接触的影响</li>
<li>取消种族隔离的其他影响</li>
<li>其他条件不同的情况</li>
</ul>
</li>
<li><p>第九部分：相互依赖：一种可能的解决办法</p>
<ul>
<li>潜在机制</li>
<li>来自差异的挑战</li>
</ul>
</li>
</ul>
</li>
<li><p>第八章：喜欢、爱和人际敏感性</p>
<ul>
<li><p>第一部分：赞扬和帮助他人的效果</p>
</li>
<li><p>第二部分：个人特征</p>
<ul>
<li>能力</li>
<li>外表吸引力</li>
</ul>
</li>
<li><p>第三部分：相似和吸引</p>
</li>
<li><p>第四部分：喜欢、被人喜欢和自尊</p>
</li>
<li><p>第五部分：尊重的获得和丧失</p>
<ul>
<li>对共有关系的需求</li>
</ul>
</li>
<li><p>第六部分：爱和亲密</p>
<ul>
<li>人们对爱的认识</li>
<li>对爱的界定</li>
<li>得失理论：亲密关系的含义</li>
</ul>
</li>
<li><p>第七部分：亲密、真实性和交流</p>
</li>
<li><p>第八部分：有效交流的特征</p>
<ul>
<li>开门见山 的重要性</li>
<li>情感与看法</li>
<li>交流与完美之爱</li>
</ul>
</li>
</ul>
</li>
<li><p>第九章：作为一门科学的社会心理学</p>
<ul>
<li><p>第一部分：什么是科学的方法</p>
<ul>
<li>科学和艺术的关系</li>
</ul>
</li>
<li><p>第二部分:从推测到实验</p>
<ul>
<li>实验设计</li>
</ul>
</li>
<li><p>第三部分:随机分配的重要性</p>
</li>
<li><p>第四部分：社会心理学实验的挑战性</p>
<ul>
<li>控制和影响</li>
<li>现实性</li>
<li>隐瞒</li>
</ul>
</li>
<li><p>第五部分：伦理问题</p>
<ul>
<li>实验人员对被实验者的责任</li>
</ul>
</li>
<li><p>第六部分：假如作者的发现被误用怎么办？</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>名词解释</p>
<ul>
<li><p>行动者-观察者偏差</p>
<ul>
<li>将他人的行为归因于行动者稳定的人格素质，而自己的行为解释为情境性因素的倾向</li>
</ul>
</li>
<li><p>攻击行为</p>
<ul>
<li>旨在引起身体痛苦或者心理痛苦的有意行为</li>
</ul>
</li>
<li><p>攻击性刺激</p>
<ul>
<li>与攻击反应相关的刺激物品（例如：手枪），仅仅因为他们的出现便增加了攻击的可能性</li>
</ul>
</li>
<li><p>利他行为</p>
<ul>
<li>对他人有益而不会给施助者带来利益的行为，这种行为往往需要帮助者付出一定的代价</li>
</ul>
</li>
<li><p>杏仁核</p>
<ul>
<li>大脑中央区一个和攻击性行为有关的区域</li>
</ul>
</li>
<li><p>态度</p>
<ul>
<li>对人、事务和观点持有的持久的（正面或者负面）的评价；态度包含情感评价和认知评价</li>
</ul>
</li>
<li><p>态度的可通达性</p>
<ul>
<li>某个事物同我们对它的评价之间的联系强度；可通达性可以通过人们报告他们对特定事物、问题感受如何的速度来加以测量</li>
</ul>
</li>
<li><p>态度便捷式判断</p>
<ul>
<li>决策时采取的一种捷径；将认知对象归为有利的一类或者不利的一类。</li>
</ul>
</li>
<li><p>归因理论</p>
<ul>
<li>对人们解释自己或者他人行为原因的方式所做的描述</li>
</ul>
</li>
<li><p>真实性</p>
<ul>
<li>一个人的行为和交往与他自己的感受相一致</li>
</ul>
</li>
<li><p>易得性便捷式判断</p>
<ul>
<li>人们在进行判断时所借助的心里规则依据是轻易想到的事物</li>
</ul>
</li>
<li><p>善意的性别歧视</p>
<ul>
<li>看起来对女性持一种正向的（甚至正直的）态度，但从本质上看却有定型化特征；例如，认为女性必须受到保护。</li>
</ul>
</li>
<li><p>归咎于受害者</p>
<ul>
<li><p>将所受到的伤害归咎于受害者本人（进行素质归因）的倾向，导致这种倾向的动机一般是希望看到世界是公平的</p>
<ul>
<li>这个名词解释我觉得很不理解：这种倾向和动机之间的逻辑关系是如何成立的？</li>
</ul>
</li>
</ul>
</li>
<li><p>旁观者效应</p>
<ul>
<li><p>目睹某个紧急性事件的旁观者人数越多，他们中间某个人出手救助的可能性越小</p>
<ul>
<li>这是否可以理解为从众行为？个体是如何受到旁观者群体影响的？如果不从众，需要承担什么责任？</li>
</ul>
</li>
</ul>
</li>
<li><p>宣泄</p>
<ul>
<li>指的是这样一种看法：“排放系统”（通过实施攻击行为、目睹他人实施攻击行为或者幻想性的攻击行为）释放聚集起来的攻击性能量，并因此减少出现进一步攻击行为的可能性。</li>
</ul>
</li>
<li><p>说服的中心路径</p>
<ul>
<li>在这种情况下，人们会对说服信息进行详细的思考，仔细聆听其中的观点并进行深入地思考；只有在人们既具备一定的信息接受能力又具有相应动机的时候，这种情况出现</li>
</ul>
</li>
<li><p>认知失调</p>
<ul>
<li><p>一种紧张冲突的状态。无论何时只要某个人同时拥有心理上不一致的两种认知（态度、想法、信念、意见），就会出现这种状态</p>
<ul>
<li>当认知失调出现后，言行会受到什么影响？</li>
<li>什么是认知?认知包括态度、想法、信念和意见</li>
</ul>
</li>
</ul>
</li>
<li><p>认知吝啬者</p>
<ul>
<li><p>人们在进行决策的时候，为了尽力保存认知能量，总是想法采用心理捷径</p>
<ul>
<li>什么是认知能量？人为什么想要保存认知能量？</li>
</ul>
</li>
</ul>
</li>
<li><p>共有关系</p>
<ul>
<li>在这种人际关系中，人们首先关系的是对他人的需要进行响应。</li>
</ul>
</li>
<li><p>伴侣之爱</p>
<ul>
<li>人们在深深地关心着另外一个人时所体验到的亲密和情感，但不一定在这个人出现的时候体验到激情</li>
</ul>
</li>
<li><p>依从</p>
<ul>
<li>个体因希望获得奖励或者害怕受到惩罚而对社会影响做出的反应</li>
</ul>
</li>
<li><p>证实偏差</p>
<ul>
<li><p>指的是这样一种倾向：人们一旦持有了某种看法，只要有可能，他们便会待有偏见的看待随后出现的事件，以证实自己的看法</p>
<ul>
<li>这个概念是不是逆向证明了第一印象的重要性？</li>
</ul>
</li>
</ul>
</li>
<li><p>从众</p>
<ul>
<li>由于受到来自他人的真实的或者想象的影响，导致一个人的行为发生了变化。</li>
</ul>
</li>
<li><p>完美之爱</p>
<ul>
<li><p>根据滕伯格的观点，这是激情、亲密和承诺三种成分的混合。</p>
<ul>
<li>滕伯格的什么观点？</li>
</ul>
</li>
</ul>
</li>
<li><p>对比效应</p>
<ul>
<li>某一认知对象看起来比它自身好或者差，取决于同它进行比较的认知对象的质量</li>
</ul>
</li>
<li><p>一致性判断</p>
<ul>
<li>将某个人的行为归因于此人类似的属性或者特质的倾向</li>
</ul>
</li>
<li><p>态度相反的倡议</p>
<ul>
<li>当某个人陈述某种与自己的个人信念或态度 相反的意见或态度时出现的认知失调过程。</li>
</ul>
</li>
<li><p>掩饰性情节</p>
<ul>
<li>设计情境或实验来增加实验的现实性，在这种情境中被试可以自然地行动，他们的行动不会因为知道自己的哪些行为正在被研究而受到妨碍。</li>
</ul>
</li>
<li><p>来源的可信性</p>
<ul>
<li>如果信息来源具有专家身份而且值得相信，她（他）很可能对接收者的信念产生影响</li>
</ul>
</li>
<li><p>心理纾解</p>
<ul>
<li>在一项实验结束时，研究者就研究目的以及所发生的事情对被试者进行解释的程序</li>
</ul>
</li>
<li><p>诱饵</p>
<ul>
<li>消费者在决策的过程中，会遇到的一种明显差于其他可能选择的选择，它出现旨在通过对比让其他可能选择中的一种看上去更好</li>
</ul>
</li>
<li><p>非人化</p>
<ul>
<li>将受害者视为非人的过程，通过这一过程来降低自身攻击行为的限制，从而更容易更有可能进行进一步的攻击行为。</li>
</ul>
</li>
<li><p>去个性化</p>
<ul>
<li>一种自我意识弱化的状态（往往是因为匿名引起的），其结果会导致人们对社会评价的关注度的降低，以及对那些被禁止行为的抑制降低。</li>
</ul>
</li>
<li><p>因变量</p>
<ul>
<li>在一项实验中，研究者用以考察是否会受到自变量影响的变量；研究者假定，因变量依存于自变量的水平</li>
</ul>
</li>
<li><p>稀释效应</p>
<ul>
<li><p>有关某个问题的额外的无关信息会弱化人们对该问题的判断或印象的趋势。</p>
<ul>
<li>这是转移话题、转移视线的理论依据吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>素质归因</p>
<ul>
<li>指的是这样一种假定：一个人的行为取决于他（她）的人格（素质），而不是情境压力</li>
</ul>
</li>
<li><p>自我中心思维</p>
<ul>
<li>倾向于更多地讲自己视为事件的中心，而实际上却并非如此</li>
</ul>
</li>
<li><p>自我防卫</p>
<ul>
<li><p>行为的目的是为了维持对自己的正向看法，但却丧失了对世界的正确认识。</p>
<ul>
<li>谁对自己的看法？是自己还是他人？自我防卫和丧失对世界的正确认识之间的逻辑关系？</li>
</ul>
</li>
</ul>
</li>
<li><p>情绪感染</p>
<ul>
<li>情绪或者行为在人群中迅速传播</li>
</ul>
</li>
<li><p>移情</p>
<ul>
<li>将自己置于他人位置上的能力，即采用此人的体验方式来对事件和情感（例如，喜悦、悲伤）进行体验</li>
</ul>
</li>
<li><p>爱</p>
<ul>
<li><p>弗洛伊德所假定的人类所具有的生的本能</p>
<ul>
<li>这句话就很空泛！！！人类需要哪些生的本能？爱为什么是人类的生的本能？它在人类的生的过程中扮演了什么角色？起到了什么作用？</li>
</ul>
</li>
</ul>
</li>
<li><p>交换关系</p>
<ul>
<li>人们之间受公平需要（例如，收益和成本之间的某种平等的比率）主宰的人际关系</li>
</ul>
</li>
<li><p>实验的现实性</p>
<ul>
<li>一项实验对被试具有影响，促使他们认真对待并参与到实验中来，这一点即使在缺乏世俗的现实性时仍然有效。</li>
</ul>
</li>
<li><p>外部理由</p>
<ul>
<li>一个人对自己不协调行为的理由或解释，不是基于个人，而是基于情境（例如，某种奖励或惩罚）。</li>
</ul>
</li>
<li><p>错误一致效应</p>
<ul>
<li><p>过高估计人们在所有问题上赞同自己的比例的趋势</p>
<ul>
<li>有避免以己度人的认识，那么什么时候更容易出现错误一致效应？</li>
</ul>
</li>
</ul>
</li>
<li><p>虚假记忆综合征</p>
<ul>
<li><p>对以往的某种创伤性经历的记忆，尽管这种经历实际上是虚假的，但人们仍然认为它发生过。</p>
<ul>
<li>为什么会出现这种心理？对人们的有什么影响？</li>
</ul>
</li>
</ul>
</li>
<li><p>登门槛技术</p>
<ul>
<li>通过先提出人们容易接受的小要求，然后提出较大的要求，来促使人们按照更大的要求办事的策略</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li><p>在决策的过程中，是否呈现命题（或者是否为其设置框架）决定着是得还是失。</p>
<ul>
<li>决策得失意味着决策成功还是失败？<br>命题或者框架指的是什么？预先设置的目标吗？<br>这句话指的是在决策之前要先制定好目标吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>挫折-攻击</p>
<ul>
<li><p>因感到自己达到某个目标受阻而产生的挫折，会增加人们做出某种攻击性反应的可能性。</p>
<ul>
<li>这叫恼羞成怒吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>基本归因错误</p>
<ul>
<li>在对人们行为原因进行分析时所存在的、过高的估计人格和气质因素而过低估计情境和环境因素的趋势</li>
</ul>
</li>
<li><p>得失效应</p>
<ul>
<li><p>指的是这样一种理论：假如我们能够从他人的预期中获得（例如，这些人最初不喜欢我们，而现在喜欢我们），那我们便会最喜欢这些人；假如我们从他人那里丧失（例如，这些人最初喜欢我们，而现在不喜欢我们），那么我们会最不喜欢这些人。</p>
<ul>
<li>分手了不能做朋友？可以这样解释吗？失去后最讨厌的人？</li>
</ul>
</li>
</ul>
</li>
<li><p>群体思维</p>
<ul>
<li><p>指的是这样的一种思维：为维持群体的一致而无视那些对事实所做的深思熟虑、事实求实的评价</p>
<ul>
<li>***的小圈子为了维持一致性也会做些考虑不周全的事情，那么是不是群体思维作祟？如何避免被群体思维裹挟？</li>
</ul>
</li>
</ul>
</li>
<li><p>光环效应</p>
<ul>
<li>指的是这样的一种偏见：对某个人良好的或者不好的总体印象，会影响到我们对这个人的推测和期望。</li>
</ul>
</li>
<li><p>事后聪明偏差</p>
<ul>
<li>一旦人们知道了某个事件的结果，他们便会强烈地倾向于（往往是错误地）认为，自己事先能预测到这一结果</li>
</ul>
</li>
<li><p>同质性效应</p>
<ul>
<li>与看待自己所在群体的成员相比，人们在看待某个外群体时会发现其成员之间存在更多相似性的趋势。</li>
</ul>
</li>
<li><p>敌对性攻击</p>
<ul>
<li><p>因愤怒感而起的一种攻击性行为，旨在施加痛苦和伤害。</p>
<ul>
<li>还有哪些性质的攻击行为？</li>
</ul>
</li>
</ul>
</li>
<li><p>敌意的性别歧视</p>
<ul>
<li><p>对女性持有负向的定型化看法——例如，女性不如男性聪明</p>
<ul>
<li>什么是定型化看法？</li>
</ul>
</li>
</ul>
</li>
<li><p>液压理论</p>
<ul>
<li><p>根据这一理论，没有表达出来的情绪会累积起来形成压力，必须采取某种形式将这种压力释放出来</p>
<ul>
<li>如何正确、聪明的释放这些压力？</li>
</ul>
</li>
</ul>
</li>
<li><p>虚伪</p>
<ul>
<li><p>个体实际所做的与口头所说的之间存在差异而认知失调</p>
<ul>
<li>认知失调，是在讲自己的状态还是对别人的一种评价措辞？虚伪是自己的一种状态，还是他人对自己的一种评价？</li>
</ul>
</li>
</ul>
</li>
<li><p>认同</p>
<ul>
<li><p>个体因希望与影响施加者相像而对社会影响做出的反应</p>
<ul>
<li>认同等价于采取相同的行为模式。口头认同只是从众，避免来自影响施加者的压力。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚假关联</p>
<ul>
<li>在两个实际上不存在关联的事件之间发现关联或者相关的趋势</li>
</ul>
</li>
<li><p>内群体</p>
<ul>
<li>个体所认同或者感到自己所从属的群体</li>
</ul>
</li>
<li><p>内群体偏爱</p>
<ul>
<li>人们对自己所确定的内群体成员会持有正向的情感并给以特别的对待，而对其他人则持有负向的情感并给予不公平的对待，这样做仅仅是因为将这些人界定为外群体成员。</li>
</ul>
</li>
<li><p>自变量</p>
<ul>
<li>实验者用以考察其自身的改变或者变化是否会对另外一些变量产生影响的变量；研究者预测这种变量会导致其他一些变量的变化。</li>
</ul>
</li>
<li><p>信息；由信息导致的社会影响</p>
<ul>
<li><p>由于我们将他人作为指导自己行为的信息源，因而来自他人的信息会导致我们从众；研究者这种变量会导致其他一些变量的变化</p>
<ul>
<li>这个名词解释有点莫名其妙！！！<br>我怀疑它和上一条串了，从书本上确认了一下，电子版书籍和纸质书籍一致，具体解答有待更新！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>预防接种效应</p>
<ul>
<li>通过先让人们接触少量与他们的态度不一致的观点，而使人们对改变他们的态度的企图产生免疫。</li>
</ul>
</li>
<li><p>工具性攻击</p>
<ul>
<li>将攻击作为实现某种目标的手段，而不仅仅是为了对他人造成痛苦。</li>
</ul>
</li>
<li><p>不充分惩罚</p>
<ul>
<li><p>当个体对拒绝自己期望的目标或者活动缺乏外部辩护理由而引起失调的时候，他们往往会贬低这个活动或者目标</p>
<ul>
<li>这不就是吃不到葡萄说葡萄酸吗？</li>
</ul>
</li>
</ul>
</li>
<li><p>内部理由</p>
<ul>
<li>通过改变自身的某些方面（例如，一个人的态度或者行为）来减少失调。</li>
</ul>
</li>
<li><p>内化</p>
<ul>
<li>个体因希望自己正确而对社会影响作出反应</li>
</ul>
</li>
<li><p>拼图技术</p>
<ul>
<li>为减少孩子们的偏见和增强他们的自尊而设计的一种课堂结构，这种课堂将孩子们安排在规模很小、种族混杂的合作群体之中。</li>
</ul>
</li>
<li><p>便捷式判断</p>
<ul>
<li><p>为使自己的判断迅速而有效，人们所采取的的心理捷径。</p>
<ul>
<li>这种心理捷径是什么？它是如何帮助人们人们做出快速有效的判断的？</li>
</ul>
</li>
</ul>
</li>
<li><p>为努力进行辩护</p>
<ul>
<li>个体会更喜爱他们经过努力而达到的某个目标的倾向</li>
</ul>
</li>
<li><p>虚报低价</p>
<ul>
<li>一些营销人员所采用的一种不择手段的策略，他们首先诱导消费者在一个很低的价位上购买商品，然后声称出错并提高价格；最终消费者往往会同意按提高了的价格购买商品。</li>
</ul>
</li>
<li><p>最小群体范式</p>
<ul>
<li>完全陌生的人通过微不足道的标准组成一个无意义的群体；最小群体成员之间仍然表现出内群体偏见。</li>
</ul>
</li>
<li><p>世俗的现实性</p>
<ul>
<li>实验室实验在多大的程度上与外部世界经常发生的事情类似</li>
</ul>
</li>
<li><p>看法</p>
<ul>
<li><p>坚持认为是正确的（无需评价和情感表露）</p>
<ul>
<li>例如：请某人谈一下对某事情的看法？那如此来看的话，对这种问题是不是只需要说对错，无需说明缘由或者表达爱憎？</li>
</ul>
</li>
</ul>
</li>
<li><p>外群体</p>
<ul>
<li>不为个体所认同的群体</li>
</ul>
</li>
<li><p>激情之爱</p>
<ul>
<li>对另外一个人所感受到的强烈的渴望并伴有生理唤起的情感；假如这种爱得到回报，人们便会体验到巨大的实现感并欣喜若狂；假如没有得到回报，人们便会感到伤心失望。</li>
</ul>
</li>
<li><p>说服的边缘路径</p>
<ul>
<li><p>在这种情况下，人们不会对说服信息中的观点进行详细考虑，而是受到边缘线索的影响。</p>
<ul>
<li>什么是说服过程中的边缘线索？</li>
</ul>
</li>
</ul>
</li>
<li><p>出丑效应</p>
<ul>
<li>指的是这样一种现象：一些失误现象会增加某个近乎完美的人的吸引力</li>
</ul>
</li>
<li><p>偏见</p>
<ul>
<li>仅仅依据特定群体中部分成员的特征而形成的、对整个群体的敌对的或者负向的态度。</li>
</ul>
</li>
<li><p>首因效应</p>
<ul>
<li>在某种特定的条件下，人们最先听到的论证会对他们产生特别的影响。</li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li>启动过程基于这样一种观点：最近出现的或者被频繁激活的想法更可能出现在脑海里，因而被用于解释社会事件。</li>
</ul>
</li>
<li><p>接近性</p>
<ul>
<li>决定人们是否喜欢或者爱上一个人的重要因素之一是物理上的接近；人们更可能与居住在自己所在的城镇或者城镇附近的人、或者是居住地虽然远但是却在同一所大学的人坠入爱河。</li>
</ul>
</li>
<li><p>随机分配</p>
<ul>
<li>将被试机会均等的分配到任何一种实验条件的过程；通过随机分配，研究者可以比较有把握保证被试的人格或背景均匀地分布在各种条件之下。</li>
</ul>
</li>
<li><p>近因效应</p>
<ul>
<li>在某种特定的条件下，人们最后听到的论证会对他们产生特别的影响。</li>
</ul>
</li>
<li><p>重构性记忆</p>
<ul>
<li><p>人们对某个事件的记忆会受到他们在该事件发生后所接触信息歪曲的过程</p>
<ul>
<li>又是一句看不懂的解释！！！<br>请注意查证！！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>记忆恢复现象</p>
<ul>
<li>对以往已经忘记的或者被压抑的事件（例如，性虐待）的回忆；这类记忆的准确性往往存在着大量的争议。</li>
</ul>
</li>
<li><p>关系性攻击</p>
<ul>
<li>一种非身体形式的攻击，诸如搬弄是非、散布虚假的谣言和排挤</li>
</ul>
</li>
<li><p>相对剥夺</p>
<ul>
<li>感觉自己（或者自己所属的群体）所得到的的，少于自己所应该得到的，少于自己所期望得到的，或者少于与自己相同的人所得到的。</li>
</ul>
</li>
<li><p>代表性便捷式判断</p>
<ul>
<li>人们对某一事物进行归类时所借助的心理捷径是该事物与某一典型事物之间的相似程度</li>
</ul>
</li>
<li><p>浪漫之爱</p>
<ul>
<li>根据斯滕伯格的观点，这是一种激情与亲密相结合的状态</li>
</ul>
</li>
<li><p>替罪羊</p>
<ul>
<li>个体倾向于将攻击矛头转向他们所不喜欢的、明显的而又相对弱小的群体。</li>
</ul>
</li>
<li><p>脚本</p>
<ul>
<li>人们从文化中潜移默化地习得的社会行为方式</li>
</ul>
</li>
<li><p>次级收益</p>
<ul>
<li>在作出依从行为之后，某种未曾预料的、有利的事态使得从众行为更具吸引力</li>
</ul>
</li>
<li><p>自我概念</p>
<ul>
<li>自我的内容，即人们对自身的想法、信念以及人格特征的感知</li>
</ul>
</li>
<li><p>自尊</p>
<ul>
<li>人们对自我价值的评价，即人们对自己的美德、能力和正派方面达到何种程度的看法</li>
</ul>
</li>
<li><p>自证预言</p>
<ul>
<li>人们对另外的一个人是什么样的人所抱有的期望，这种期望会影响到人们对待此人的行为方式，并会促使此人按照人们最初对他预判相一致的方式去行为。</li>
</ul>
</li>
<li><p>自我辩护</p>
<ul>
<li>为了维护自己的自尊二区证明自己的行为合理的倾向</li>
</ul>
</li>
<li><p>自我知觉理论</p>
<ul>
<li><p>指的是这样的一种理论：当我们的归因不确定或者模糊不清的时候，我们会根据自身行为的观测来对其加以推测。</p>
<ul>
<li>这种推测有什么倾向？是素质归因还是情境归因？这种推测是否合理、正确？有没有其他的方法来帮助我们在这种情境下进行归因？</li>
</ul>
</li>
</ul>
</li>
<li><p>自我图式</p>
<ul>
<li>根据我们以往的经历，对我们自身的知识加以组织，以帮助我们理解、解释和预测我们自身的行为。</li>
</ul>
</li>
<li><p>自利偏差</p>
<ul>
<li>个体将自己的成功归因于素质，而将自己的失败归因于情境的情境。</li>
</ul>
</li>
<li><p>相似性</p>
<ul>
<li>人们往往会喜欢或者爱上与自己的看法、态度、价值和长相类似的人</li>
</ul>
</li>
<li><p>社会认知</p>
<ul>
<li>人们如何思考自身以及社会生活；具体而言，人们如何选择、解释、记忆和运用社会信息进行判断和决策。</li>
</ul>
</li>
<li><p>社会影响</p>
<ul>
<li>人们对他人的看法和行为所施加的影响</li>
</ul>
</li>
<li><p>社会学习理论</p>
<ul>
<li>这种理论认为：人们通过观察和模仿他人来习得社会行为（例如，攻击行为）</li>
</ul>
</li>
<li><p>社会心理学</p>
<ul>
<li>对受到真实的或想象的他人在场影响下的人们的思想、情感和行为方式的科学研究</li>
</ul>
</li>
<li><p>定型</p>
<ul>
<li>对某个群体的简单的概括，从个人所持偏见出发，赋予他们完全相同的特征。</li>
</ul>
</li>
<li><p>定型威胁</p>
<ul>
<li>少数族裔的成员对他们自身的行为方式与已有的文化定型相符合的担忧。这种担忧往往会降低他们取得成绩的能力。</li>
</ul>
</li>
<li><p>坦率地谈话</p>
<ul>
<li><p>一个人明确地说出自己的情感和心事，而且不对对方加以指责、挖苦或者嘲笑</p>
<ul>
<li>那么在坦率的谈话情境下，如何才能让谈话的另外一方不产生其他的附带情绪？比如说出自己的情绪后，对方会不会觉得自己是在指责ta，然后继而道歉？然后坦率的谈话该如何把握谈话的方向？从而避免发展成为激烈的互相指责和争吵？</li>
</ul>
</li>
</ul>
</li>
<li><p>睾丸素</p>
<ul>
<li>与攻击性有关的一种激素</li>
</ul>
</li>
<li><p>桑纳托斯</p>
<ul>
<li><p>根据弗洛伊德的观点，这是一种促使人类走向死亡的本能的驱动力，会导致攻击行为。</p>
<ul>
<li>弗洛伊德关于此观点的详细描述请加以查证！！！</li>
<li>桑纳托斯是如何导致攻击性行为的？</li>
</ul>
</li>
</ul>
</li>
<li><p>爱情三角</p>
<ul>
<li>根据斯滕伯格的观点，爱情的三种成分是：激情、亲密和承诺</li>
</ul>
</li>
<li><p>基本归隐偏差</p>
<ul>
<li>在对特定人群进行整体归因时所出现的、与人们对该群体的偏见相一致的素质归因倾向。</li>
</ul>
</li>
</ul>
</li>
<li><p>读者大纲</p>
<ul>
<li><p>第一章：社会心理学概念及分析</p>
<ul>
<li><p>第一部分：什么是社会心理学？</p>
<ul>
<li>读者答：作者并没有直接给社会心理学直接下定义；而是通过通过一系列社会群体和个体对人们施加影响的案例来引导出“社会影响”这个关键论题。社会影响指的是人们对他人的想法产生的影响。</li>
</ul>
</li>
<li><p>第二部分：社会心理学的几个问题</p>
<ul>
<li>第一问：人们是怎么受到影响的？</li>
<li>第二问：对人们而言这些影响的隐含意义是什么？或者说人们为什么会受到影响？<br>读者注释：这个问题问的有点不明白！！！</li>
<li>第三问：哪些因素会增强或者削弱社会影响</li>
<li>第四问：社会影响是长久的还是短暂的?这里讨论的是社会影响的持续性。</li>
<li>第五问：哪些因素会影响社会影响的持续性？</li>
</ul>
</li>
<li><p>第三部分：社会心理学实验</p>
<ul>
<li><p>第一重点：强调社会心理学实验的重要性；不要有“显而易见”的心理；</p>
</li>
<li><p>第二重点：强调社会心理学实验的一些问题</p>
<ul>
<li>重点一：社会心理学实验的组成要素</li>
<li>重点二：社会性理学实验的有利因素、不利因素、伦理难题、激动人心之处、棘手之处和令人痛心之处</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第二章;从众</p>
<ul>
<li><p>第一部分：什么是从众效应？群体压力和从众的关系</p>
<ul>
<li>读者答：群体压力是从众效应的关键性因素之一</li>
</ul>
</li>
<li><p>第二部分：什么导致了群体压力</p>
</li>
<li><p>第三部分：群体压力的本质是什么？（读者注解：第二部分和第三部分的问题解答应该是相似度很高的）</p>
</li>
<li><p>第四部分：群体压力带来的个体行为和意见的改变是真是假？</p>
</li>
<li><p>第五部分：从众效应带来的改变是短暂还是长久的？</p>
</li>
<li><p>第六部分：哪些因素会增强从众效应？</p>
</li>
<li><p>第七部分：如何理解没有群体压力下的从众效应？</p>
</li>
<li><p>第八部分：对社会影响的几个不同的反应</p>
</li>
<li><p>第九部分：从众者和旁观者的关系</p>
</li>
<li><p>第十部分:从众效应实验中应该注意的伦理问题</p>
</li>
</ul>
</li>
<li><p>第三章：大众传播、宣传和说服</p>
<ul>
<li>第一部分：人们生活中的常见的几种宣传、说服的例子</li>
<li>第二部分：说服的两种路径</li>
<li>第三部分;宣传的可信性和宣传的性质以及如何加强宣传的影响？</li>
<li>第四部分；说服接受者的一些特征</li>
<li>第五部分：如何发挥传播、宣传和说服原则的作用？换言之，我们如何利用这些原则来扩大社会影响</li>
</ul>
</li>
<li><p>第四章：社会认知</p>
<ul>
<li>第一部分：社会认知和人们进行行为决策的关系</li>
<li>第二部分:我们应该如何理解世界？换言之，我们应该如何建立我们的社会认知？哪些因素会影响我们的社会认知进而影响我们的行为决策和意见？</li>
<li>第三部分：在社会认知下的几种判断方式和运用这些判断方式的时机</li>
<li>第四部分：社会认知下人们如何对事物和人物进行分类以及分类之后所产生的结果？分类和社会定型的关系？</li>
<li>第五部分:记忆作为社会交往重要部分，重构性记忆和自传性记忆的缺陷。</li>
<li>第六部分：什么是人类认知？人类认知存在哪些保守性？</li>
<li>第七部；人们的态度和信念是如何影响决策并且指导行动的？</li>
<li>第八部分：哪些因素导致了人们在解释和归因社会生活时出现了偏差（证实偏差、自我偏差、行动者-观察者偏差）？</li>
<li>第九部分:影响人们社会认知的自我中心思维和自利偏差</li>
</ul>
</li>
<li><p>第五章：自我辩护</p>
<ul>
<li>第一部分：人们都会对自己的行为、信念和感受加以辩护，以便让自己或者他人相信自己所做事情的合理性，证明自己的正确性</li>
<li>第二部分：认知失调的理论的详解</li>
<li>第三部分：认知失调理论的实际应用</li>
</ul>
</li>
<li><p>第六章：人类的攻击性</p>
<ul>
<li>第一部分：人类的攻击性的定义个攻击性的分类</li>
<li>第二部分：攻击性行为的利弊</li>
<li>第三部分：攻击性行为的动机理论、人类的攻击性行为受哪些因素的影响</li>
<li>第四部分：任何降低人类的攻击性</li>
</ul>
</li>
<li><p>第七章：偏见</p>
<ul>
<li>第一部分：什么是偏见</li>
<li>第二部分：偏见是如何产生的？定型对偏见的产生有何影响？它的人类的言行有哪些威胁？</li>
<li>第三部分：如何消除偏见</li>
</ul>
</li>
<li><p>第八章：喜欢、爱和人际敏感性</p>
<ul>
<li>第一部分：喜欢和不喜欢的定义？它是如何产生的？</li>
<li>第二部分：从喜欢到爱的转变过程？这一过程是如何发生的？哪些因素会对这个过程产生影响</li>
<li>第三部分：爱随着时间的变化趋势？增强或者削弱爱的因素。</li>
</ul>
</li>
<li><p>第八章：作为一门科学的社会性理学</p>
<ul>
<li>第一部分:社会心理学的一些基本实验原理</li>
<li>第二部分：社会心理学实验中存在的一些问题挑战、</li>
</ul>
</li>
</ul>
</li>
<li><p>问题解答</p>
<ul>
<li><p>这本书在谈什么？</p>
<ul>
<li>读者答：这本书在讨论的是社会心理学中的社会影响这个话题。讨论的问题包括什么是社会影响、社会影响有什么含义、增强或者减弱社会影响的因素有哪些、这些影响是短暂的还是持续性的、增强或者削弱影响持续性的一些因素</li>
</ul>
</li>
<li><p>这本书架构如何？</p>
<ul>
<li><p>这本书主要包含一下几个部分</p>
<ul>
<li>第一部分：主要是该书的第一章节内容；主要议题就是提出社会影响这个话题已经关于社会影响的几个问题；并且说明关于社会心理学实验的组成因素和社会心理学实验所面临的的问题。</li>
<li>第二部分:主要包含该书的第二章节~第八章节内容；主要讨论了</li>
</ul>
</li>
</ul>
</li>
<li><p>这本书分为哪些部分？</p>
</li>
<li><p>这是什么类型的书籍？</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h3><ul>
<li><p>分析阅读概念笔记</p>
<ul>
<li>包含内容：作者观点、论据、读者观点</li>
<li>作者论点、论据</li>
<li>好句摘录</li>
<li>读者观点</li>
</ul>
</li>
</ul>
<h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><ul>
<li><p>主题阅读概念笔记</p>
<ul>
<li>包含内容：主题相关书籍中的作者观点、论据</li>
<li>主题观点、论据</li>
</ul>
</li>
</ul>
<h3 id="读者反馈"><a href="#读者反馈" class="headerlink" title="读者反馈"></a>读者反馈</h3><ul>
<li>这本书在谈什么</li>
<li>作者说明了哪些问题？又是怎么说明的？</li>
<li>作者说的内容是否有道理？</li>
<li>这本书和读者之间的关系？</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><hr></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="西北看长安"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">西北看长安</p><p class="is-size-6 is-block">斯人若彩虹,遇上方知有</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/panxizi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/6334161054/profile?topnav=1&amp;wvr=6"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:pxytravel@hotmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/07/16/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第三节 逻辑和关系运算符）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-16T12:06:00.000Z">2022-07-16</time></p><p class="title"><a href="/2022/07/16/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第三节 逻辑和关系运算符）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/15/Git-untracked-files/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/target_pic/git_image.png" alt="Git untracked files"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-15T12:53:00.000Z">2022-07-15</time></p><p class="title"><a href="/2022/07/15/Git-untracked-files/">Git untracked files</a></p><p class="categories"><a href="/categories/Git/">Git</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/13/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第二节 算术运算符）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-13T14:25:00.000Z">2022-07-13</time></p><p class="title"><a href="/2022/07/13/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第二节 算术运算符）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第一节 基础）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:42:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第一节 基础）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="通信技术概论"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:33:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/">通信技术概论</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a><p class="size-small"><span>&copy; 2022 Xizi Pan</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/7/30 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>