<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: C++ - 西北看长安</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="西北看长安"><meta name="msapplication-TileImage" content="/img/zhonglou.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="西北看长安"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="西北看长安"><meta property="og:url" content="https://panxizi.github.io/"><meta property="og:site_name" content="西北看长安"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://panxizi.github.io/img/avatar.png"><meta property="article:author" content="XiZi"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"西北看长安","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Xizi Pan"},"description":""}</script><link rel="icon" href="/img/zhonglou.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">C++</a></li></ul></nav></div></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">21a4771bbf4007e96ea64a2275e8316e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="21a4771bbf4007e96ea64a2275e8316e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>11 分钟  <i class="fas fa-pencil-alt"> </i>1.7 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）</a></h1><div class="content"><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><ul>
<li>问题情景：程序越来越复杂， 程序中用到的类型也越来越复杂  <ul>
<li>一是一些类型难于“ 拼写”， 它们的名字既难记又容易写错， 还无法明确体现其真实目的和含义  </li>
<li>二是有时候根本搞不清到底需要的类型是什么， 程序员不得不回过头去从程序的上下文中寻求帮助。  </li>
</ul>
</li>
</ul>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ol>
<li><p>类型别名（ type alias)  定义：<br>是一个名字， 它是某种类型的同义词。   </p>
</li>
<li><p>好处：让复杂的类型名字变得简单明了、 易于理解和使用， 还有助于程序员清楚地知道使用该类型的真实目的。  </p>
</li>
<li><p>定义类型别名  </p>
<ol>
<li><p>关键字 typedef  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223950076.png" alt="image-20220705223950076"></p>
</li>
<li><p>别名声明（ aliasdeclaration)   </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705224051565.png" alt="image-20220705224051565"></p>
</li>
</ol>
</li>
<li><p>使用场景：类型别名和类型的名字等价， 只要是类型的名字能出现的地方， 就能使用类型别名：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base 是 double 的同义词， p 是 double *的同义词</span></span><br><span class="line"></span><br><span class="line">wages hourly, weekly;<span class="comment">// 等价于 double hourly、 weekly;</span></span><br><span class="line">SI item; <span class="comment">// 等价于 Sales_item item</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="指针、-常量和类型别名"><a href="#指针、-常量和类型别名" class="headerlink" title="指针、 常量和类型别名"></a>指针、 常量和类型别名</h5><ul>
<li><p>如果某个类型别名指代的是复合类型或常量， 那么把它用到声明语句里就会产生意想不到的后果  </p>
</li>
<li><p>下面的声明语句用到了类型pstring,它实际上是类型 char *的别名：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225345870.png" alt="image-20220705225345870"></p>
<ul>
<li>pstring 实际上是指向 char 的指针， 因此， const pstring 就是指向char 的常量指针， 而非指向常量字符的指针。  </li>
<li>人们往往会错误地尝试把类型别名替换成它本来的样子， 以理解该语句的含义：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705225640419.png" alt="image-20220705225640419"></li>
<li>这样改写的结果是， const char 成了基本数据类型。 前后两种声明含义截然不同， 前者声明了一个指向 char 的常量指针， 改写后的形式则声明了一个指向 const char 的指针。  </li>
</ul>
</li>
</ul>
<h4 id="auto-类型说明符"><a href="#auto-类型说明符" class="headerlink" title="auto 类型说明符"></a>auto 类型说明符</h4><ol>
<li>C++11 新标准引入了 auto 类型说明符</li>
<li>让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符（ 比如 double) 不同， auto 让编译器通过初始值来推算变量的类型。 显然， auto 定义的变量必须有初始值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230127843.png" alt="image-20220705230127843"></li>
<li>使用 auto 也能在一条语句中声明多个变量。 因为一条声明语句只能有一个基本数据类型， 所以该语句中所有变量的初始基本数据类型都必须一样：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230215573.png" alt="image-20220705230215573"></li>
</ol>
<h5 id="复合类型、-常量和-auto"><a href="#复合类型、-常量和-auto" class="headerlink" title="复合类型、 常量和 auto"></a>复合类型、 常量和 auto</h5><ol>
<li> 编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样， 编译器会适当地改变结果类型使其更符合初始化规则。</li>
<li>当引用被用作初始值时， 真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为 auto的类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230412863.png" alt="image-20220705230412863"></li>
<li>auto —般会忽略掉顶层 const (参见<a href ="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>）， 同时底层 const 则会 保留下来， 比如当初始值是一个指向常量的指针时：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230626358.png" alt="image-20220705230626358"></li>
<li>如果希望推断出的 auto 类型是一个顶层 const, 需要明确指出：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230709586.png" alt="image-20220705230709586"></li>
<li>将引用的类型设为 auto, 此时原来的初始化规则仍然适用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230754003.png" alt="image-20220705230754003"></li>
<li>要在一条语句中定义多个变量， 切记， 符号&amp;和*只从属于某个声明符， 而非基本数据类型的一部分， 因此初始值必须是同一种类型：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705230843490.png" alt="image-20220705230843490"></li>
</ol>
<h4 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h4><ol>
<li>问题情景：希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量。   </li>
<li>decltype 类型指示符 ：C++11 新标准引入了第二种类型说明符decltype. 它的作用是选择并返回操作数的数据类型。 在此过程中， 编译器分析表达式<br>并得到它的类型， 却不实际计算表达式的值：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231052903.png" alt="image-20220705231052903"></li>
<li>decltype 处理顶层 const 和引用的方式与 auto 有些许不同。 如果 decltype 使用的表达式是一个变量， 则 decltype 返回该变量的类型( 包括顶层 const 和引用在内）：<br>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231159269.png" alt="image-20220705231159269"></li>
</ol>
<h5 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h5><p>如果 decltype 使用的表达式不是一个变量， 则 decltype 返回表达式结果对应的类型。  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705231423081.png" alt="image-20220705231423081"></p>
<ol>
<li><p>r 是一个引用， 因此 decltype (r ) 的结果是引用类型  </p>
</li>
<li><p>如果想让结果类型是 r 所指的类型， 可以把 r 作为表达式的一部分， 如 r+0, 显然这个表达式的结果将是一个具体值而非一个引用。  </p>
</li>
<li><p>如果表达式的内容是解引用操作， 则 decltype 将得到引用类型。  </p>
<ol>
<li>解引用指针可以得到指针所指的对象， 而且还能给这个对象赋值  </li>
<li>因此， decltype ( *p) 的结果类艰就是 int &amp;， 而非 int。  </li>
</ol>
</li>
<li><p>decltype 和 auto 的另一处重要区別是， decltype 的结果类型与表达式形式密切相关。<br> 特别注意  ：</p>
<ol>
<li><p>对于 decltype 所用的表达式来说， 如果变量名加上了一对括号， 则得到的类型与不加括号时会有不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype 的表达式如果是加上了括号的变量， 结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span> ( (i) ) d;		<span class="comment">// 错误： d是 int&amp;， 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span> (i) e;			<span class="comment">// 正确： e 是一个（ 未初始化的 ） int</span></span><br></pre></td></tr></table></figure></li>
<li><p>decltype( ( variable ) ) ( 注意是双层括号 ） 的结果永远是引用， 而decltype( variable) 结果只有当 variable 本身就是一个引用时才是引用。  </p>
</li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/#comment-container"><span class="display-none-class">1fb5fb78276704826e2511f75be4a35c</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="1fb5fb78276704826e2511f75be4a35c">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 分钟  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）</a></h1><div class="content"><h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><ol>
<li><p>const 对象一旦创建后其值就不能再改变， 所以 const 对象必须初始化。  </p>
</li>
<li><p>初始值可以是任意复杂的表达式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="built_in">get_size</span>()； <span class="comment">// 正确：运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>；<span class="comment">// 正确：编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k；<span class="comment">//错误，k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="初始化和-const"><a href="#初始化和-const" class="headerlink" title="初始化和 const"></a>初始化和 const</h5><ul>
<li><p>非 const 类型所能参与的操作相比， const 类型的对象能完成其中大部分  </p>
</li>
<li><p>只能在 const 类型的对象上执行不改变其内容的操作  </p>
</li>
<li><p>const对象可以用于初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci  = i；	<span class="comment">// 正确： i的值被拷贝给了 ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci；			<span class="comment">// 正确： ci的值被拷贝给了 j</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="默认状态下，-const-对象仅在文件内有效"><a href="#默认状态下，-const-对象仅在文件内有效" class="headerlink" title="默认状态下， const 对象仅在文件内有效"></a>默认状态下， const 对象仅在文件内有效</h5><ol>
<li><p>const对象的生效过程：</p>
<ul>
<li>当以编译时初始化的方式定义一个const对象时：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>; / / 输入缓冲区大小</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器将在编译过程中把用到该变量的地方都替换成对应的值。 </li>
<li>为了执行上述替换， 编译器必须知道变量的初始值  </li>
<li>如果程序包含多个文件， 则每个用了 const 对象的文件都必须得能访问到它的初始值才行。   </li>
<li>要做到这一点， 就必须在每一个用到变量的文件中都有对它的定义（ <a href = "# 2.2.2    变量声明和定义的关系 ">参见 2.2.2 节， 第 41 页  </a>）。</li>
<li>为了支持这一用法，同时避免对同一变量的重复定义， 默认情况下， const 对象被设定为仅在文件内有效  </li>
<li>当多个文件中出现了同名的 const 变量时， 其实等同于在不同文件中分别定义了独立的变量。  </li>
</ul>
</li>
<li><p>问题场景：</p>
<ul>
<li><p>某些时候有这样一种 const 变量， 它的初始值不是一个常量表达式， 但又确实有必要在文件间共享。 这种情况下， 我们不希望编译器为每个文件分别生成独立的变量。 相反，我们想让这类 const 对象像其他（ 非常量） 对象一样工作， 也就是说， 只在一个文件中定义 const， 而在其他多个文件中声明并使用它  </p>
</li>
<li><p>解决办法：</p>
<ul>
<li><p>如果想在多个文件之间共享 const 对象， 必须在变量的定义之前添加 extern关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_l.cc 定义并初始化了一个常量， 该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span> ( );</span><br><span class="line"><span class="comment">// file_l.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">/// / 与 file_1.cc 中定义的 bufSize 是同一个</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a>const 的引用</h4><ol>
<li><p>对常量 的引用（ reference to const)</p>
<p>把引用绑定到 const 对象上， 就像绑定到其他对象上一样，</p>
</li>
<li><p>对常量的引用不能被用作修改它所绑定的对象：</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// 正确： 引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;	<span class="comment">// 错误： r1 是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">// 错误： 试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>术语：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705153505715.png" alt="image-20220705153505715"></p>
<h5 id="初始化和对-const-的引用"><a href="#初始化和对-const-的引用" class="headerlink" title="初始化和对 const 的引用"></a>初始化和对 const 的引用</h5><ol>
<li><p>引用的类型必须与其所引用对象的类型一致（<a href =  "#2.3.1    引用">2.3.1 第46页</a>）， 但是有两个例外  </p>
<ol>
<li><p>在初始化常量引用时允许用任意表达式作为初始值， 只要该表达式的结果能转换成（<a href = "#2.1.2    类型转换">参见 2.1.2 节， 第 32 页</a> ） 引用的类型即可。  尤其， 允许为一个常量引用绑定非常量的对象、 字面值， 甚至是个一般表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// 允许将 const int &amp;绑定到一个普通 int 对象上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">// 正确： r1 是一个常量引用	</span></span><br><span class="line"><span class="comment">//读者疑问：这里和r1有什么关系？笔误吗？正确的写法是const int &amp;r2 = r1；？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// 正确： r3 是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">// 错误： r4 是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>细节探究1：当一个常量引用被绑定到另外一种类型上时到底发生了什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处 ri 引用了一个 int 型的数。 对 ri 的操作应该是整数运算， 但 dval 却是一个双精<br>度浮点数而非整数。 因此为了确保让 ri 绑定一个整数， 编译器把上述代码变成了如下<br>形式:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval；<span class="comment">// 由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;	<span class="comment">// // 让ri 绑定这个临时量</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下， ri 绑定了一个临时量 ( temporary ) 对象。</p>
<p>所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 </p>
<p>C++程序员们常常把临时量对象简称为临时量。</p>
<p>接下来探讨当ri 不是常量时， 如果执行了类似于上面的初始化过程将带来什么样的<br>后果。</p>
<p> 如果ri 不是常量， 就允许对ri 赋值， 这样就会改变ri 所引用对象的值。</p>
<p> 注意，此时绑定的对象是一个临时量而非 dval。 </p>
<p>程序员既然让 ri 引用 dval, 就肯定想通过ri改变dval的值， 否则干什么要给ri赋值呢？ </p>
<p>如此看来， 既然大家基本上不会想着把引用绑定到临时量上， C++语言也就把这种行为归为非法。  </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="对-const-的引用可能引用一个并非-const-的对象"><a href="#对-const-的引用可能引用一个并非-const-的对象" class="headerlink" title="对 const 的引用可能引用一个并非 const 的对象"></a>对 const 的引用可能引用一个并非 const 的对象</h5><ol>
<li><p>常量引用仅对引用可参与的操作做出了限定， 对于引用的对象本身是不是一个常量未作限定</p>
</li>
<li><p>因为对象也可能是个非常量， 所以允许通过其他途径改变它的值 :</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;<span class="comment">// 引 用 ri绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">// r2 也绑定对象i, 但是不允许通过 r2 修改i的值</span></span><br><span class="line">r1 =  <span class="number">0</span>;<span class="comment">// r1 并非常量 ， i的值修改为 0</span></span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">// 错误： r2 是一个常量引用</span></span><br></pre></td></tr></table></figure>

<p>读者疑问：那么在上面这个例子里面，常量引用r2的值也被改成了0吗？常量引用为什么可以改变？</p>
</li>
</ol>
<h4 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h4><ol>
<li><p>与引用一样， 也可以令指针指向常量或非常量  </p>
</li>
<li><p>类似于常量引用（  <a href ="#2.4.1    const 的引用">参见 2.4.1 节， 第54 页</a>）， 指向常量的指针（pointer to const) 不能用于改变其所指对象的值。  </p>
</li>
<li><p>要想存放常量对象的地址， 只能使用指向常量的指针：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;		<span class="comment">// pi 是个常量， 它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;			<span class="comment">// 错误： ptr 是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;	<span class="comment">// 正确： cptr 可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;					<span class="comment">// 错误： 不能给*cptr 賦值</span></span><br></pre></td></tr></table></figure></li>
<li><p>指针的类型必须与其所指对象的类型一致( <a href ="#2.3.2    指针">2.3.2 节（ 第 47 页）</a>)<br>例外情况：</p>
<ol>
<li><p>允许令一个指向常量的指针指向一个非常量对象  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;<span class="comment">// dval 是一个双精度浮点数， 它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;<span class="comment">//正确： 但是不能通过 cptr 改变 dval 的值</span></span><br></pre></td></tr></table></figure></li>
<li><p>和常量引用一样， 指向常量的指针也没有规定其所指的对象必须是一个常量  </p>
<ol>
<li>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值， 而没有规定那个对象的值不能通过<br>其他途径改变。</li>
</ol>
</li>
<li><p>关于指向常量的指针或者引用的总结：</p>
<p>试试这样想吧： 所谓指向常量的指针或引用， 不过是指针或引用 “ 自以为是’罢了， 它们觉得自己指向了常量， 所以自觉地不去改变所指对象的值。  </p>
</li>
</ol>
</li>
</ol>
<h5 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h5><ol>
<li><p>指针是对象而引用不是， 因此就像其他对象类型一样， 允许把指针本身定为常量  </p>
</li>
<li><p>常量指针 (const pointer) 必须初始化， 而且一旦初始化完成， 则它的值（ 也就是存放在指针中的那个地址） 就不能再改变了。   </p>
</li>
<li><p>不变的是指针本身的值而非指向的那个值<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215121742.png" alt="image-20220705215121742"></p>
</li>
<li><p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值， 能否这样做完全依赖于所指对象的类型</p>
<ol>
<li><p>所指向的对象是常量，则不能修改</p>
</li>
<li><p>所指向的对象是非常量，则完全可以通过这个对象或者这个常量指针 去修改这个被指向对象的值</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705215732072.png" alt="image-20220705215732072"></p>
</li>
</ol>
</li>
</ol>
<h4 id="顶层-const-读者注：这一小节读者表示看不明白"><a href="#顶层-const-读者注：这一小节读者表示看不明白" class="headerlink" title="顶层 const(读者注：这一小节读者表示看不明白~~~)"></a>顶层 const(读者注：这一小节读者表示看不明白~~~)</h4><ol>
<li><p>问题情景：</p>
<ol>
<li>指针本身是个对象，他又可以指向另外的对象；指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。 </li>
</ol>
</li>
<li><p>顶层const(top-level const)  </p>
<ol>
<li>指针本身是个常量  </li>
</ol>
</li>
<li><p>底层 const (low-level const)  </p>
<ol>
<li>指针所指的对象是一个常量  </li>
</ol>
</li>
<li><p>顶层const和底层 const的区分()</p>
<ol>
<li><p>顶层 const 可以表示任意的对象是常量， 这一点对任何数据类型都适用，如算术类型、 类、 指针等  </p>
</li>
<li><p>底层 const 则与指针和引用等复合类型的基本类型部分有关。  </p>
</li>
<li><p>指针类型既可以是顶层 const 也可以是底层 const  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> pi = &amp;i;<span class="comment">// 不能改变 pi 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">// 不能改变 ci 的值， 这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">// 允许改变 p2 的值， 这是一个底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的 const 是顶层 const, 靠左的是底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;<span class="comment">// 用于声明引用的 const 都是底层 const</span></span><br></pre></td></tr></table></figure></li>
<li><p>当执行对象的拷贝操作时， 常量是顶层 const 还是底层 const 区别明显。 其中， 顶层 const 不受什么影响：</p>
</li>
<li><p>另一方面， 底层 const 的限制却不能忽视。 当执行对象的拷贝操作时， 拷入和拷出的对象必须具有相同的底层 const 资格， 或者两个对象的数据类型必须能够转换。 一般来说， 非常量可以转换成常量， 反之则不行： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i= ci;<span class="comment">// 正确： 拷贝 ci 的值， ci 是一个顶层 const， 对此操作无影响</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 指向的对象类型相同， p3 顶层 const 的部分不影响</span></span><br><span class="line"><span class="keyword">int</span> *p = p3;<span class="comment">// 错误： p3 包含底层 const 的定义， 而 p 没有</span></span><br><span class="line">p2 = p3;<span class="comment">// 正确： p2 和 p3 都是底层 const</span></span><br><span class="line">p2 = &amp;i;<span class="comment">// 正确： int 能转换成 const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r ci;<span class="comment">// 错误： 普通的 int &amp;不能绑定到 int 常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 =i;<span class="comment">//正确：const int &amp;可以绑定到一个普通 int 上</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h4><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><ol>
<li><p>指值不会改变并且在编译过程就能得到计算结果的表达式 ；字面值属于常量表达式  </p>
</li>
<li><p>常量表达式初始化的 const 对象也是常量表达式  </p>
</li>
<li><p>一个对象（ 或表达式） 是不是常量表达式由它的数据类型和初始值共同决定  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221351129.png" alt="image-20220705221351129"></p>
<p>![image-20220705221413365](D:\书本和读书笔记\Primer C++ 第五版（第一部分 C++基础  第二章 变量和基本类型）.assets\image-20220705221413365.png)</p>
</li>
</ol>
<h5 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h5><ol>
<li>C++11 新标准规定， 允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式 </li>
<li>声明为 constexpr 的变量一定是一个常量， 而且必须用常量表达式初始化：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705221643749.png" alt="image-20220705221643749"></li>
<li>注意事项：<ol>
<li>函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量。  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） </li>
<li>相反的， 定义于所有函数体之外的对象其地址固定不变， 能用来初始化 constexpr 指针  </li>
<li>允许函数定义一类有效范围超出函数本身的变量  （ <a href ="#">6.1.1 节（ 第 184 页）</a>） ， 这类变量和定义在函数体之外的变量一样也有固定地址。 因此， constexpr 引用能绑定到这样的变量上， constexpr 指针也能指向这样的变量。  </li>
</ol>
</li>
</ol>
<h5 id="字面值类型-（-literal-type"><a href="#字面值类型-（-literal-type" class="headerlink" title="字面值类型  （ literal type)"></a>字面值类型  （ literal type)</h5><ul>
<li>问题情景：常量表达式的值需要在编译时就得到计算， 因此对声明 constexpr 时用到的类型必须有所限制  </li>
<li>这些类型一般比较简单， 值也显而易见、 容易得到， 就把它们称为“ 字面值类型”（ literal type)。</li>
<li>有哪些？<ul>
<li> 算术类型、 引用和指针都属于字面值类型  </li>
<li> 自定义类 Sales_item、 10 库、 string 类型则不属于字面值类型， 也就不能被定义成constexpr  </li>
<li> 其他字面值类型<a href = "#">7.5.6 节（ 第 267 页） 和 19.3 节（ 第 736 页）  </a></li>
</ul>
</li>
<li>指针和引用都能定义成 constexpr, 但它们的初始值却受到严格限制  </li>
<li>一个constexpr 指针的初始值必须是nullptr 或者 0,或者是存储于某个固定地址中的对象  </li>
</ul>
<h5 id="指针和-constexpr"><a href="#指针和-constexpr" class="headerlink" title="指针和 constexpr"></a>指针和 constexpr</h5><ul>
<li><p>在 constexpr 声明中如果定义了一个指针， 限定符 constexpr 仅  对指针有效， 与指针所指的对象无关</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223219365.png" alt="image-20220705223219365"></p>
</li>
</ul>
<p>​        p 是一个指向常量的指针， 而 q 是一个常量指针， 其中的关键在于 constexpr 把它所定义的对象置为了顶层 const <a href="#2.4.3    顶层 const(读者注：这一小节读者表示看不明白~~~)"> 2.4.3 节， 第 57 页</a>.</p>
<ul>
<li><p>constexpr 指针既可以指向常量也可以指向一个非常量：  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705223703473.png" alt="image-20220705223703473"></p>
</li>
</ul>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">83ddaccf0684812d1829b07735b89f52</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="83ddaccf0684812d1829b07735b89f52">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>20 分钟  <i class="fas fa-pencil-alt"> </i>3.0 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）</a></h1><div class="content"><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>基于其他类型定义的类型 </li>
<li>本章将介绍其中的两种： 引用和指针  </li>
<li>声明语句 :基本数据类型（ base type)  +  声明符( declarator) 列表  </li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol>
<li><p>概念：对象起了另外一个名字  </p>
<pre><code>引用类型引用（ refers to) 另外一种类型  ？（这话什么意思?）
</code></pre>
</li>
<li><p>如何定义：将声明符写成 &amp;d 的形式  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival； 	<span class="comment">// refVal 指向 ival ( 是 ival 的另一个名字 ）</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal；	<span class="comment">// 报错： 引用必须被初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用的实质：</p>
<ol>
<li><p>定义引用时， 程序把引用和它的初始值绑定（ bind) 在一起， 而不是将初始值拷贝给引用。   </p>
<ol>
<li>定义初始化引用和定义变量的区别：在初始化变量时， 初始值会被拷贝到新建的对象中；  </li>
</ol>
</li>
<li><p>一旦初始化完成， 引用将和它的初始值对象一直绑定在一起。 因为无法令引用重新绑定到另外一个对象， 因此引用必须初始化。 </p>
</li>
<li><p>引用并非对象， 相反的， 它只是为一个已经存在的对象所起的另外一个名字 </p>
</li>
<li><p>定义了一个引用之后， 对其进行的所有操作都是在与之绑定的对象上进行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把 2 賦给 refVal 指向的对象 ， 此处即是賦给了 ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal; <span class="comment">// 与ii = ival 执行结果一样</span></span><br><span class="line"><span class="comment">//正确： refVal3 绑定到了那个与 refVal 绑定的对象上， 这里就是绑定到 ival 上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">// 利 用 与 refVal 绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="keyword">int</span> i = refVal; <span class="comment">// 正确： i被初始化为 ival 的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h5><ul>
<li><p>允许在一条语句中定义多个引用， 其中每个引用标识符都必须以符号 &amp;开头 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>,i2 = <span class="number">2048</span>; <span class="comment">//i和i2 都是 int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r =i, r2 =i2;<span class="comment">// r 是一个引用， 与i绑定在一起， r2 是 int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri =i3; <span class="comment">//i3 是 int, ri是一个引用， 与i3 绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 =i2; <span class="comment">// r3 和 r4 都是引用</span></span><br></pre></td></tr></table></figure></li>
<li><p>所有引用的类型都要和与之绑定的对象严格匹配 ；（<a> </a><a href = "#2.4.1    const 的引用 ">2.4.1节</a>  、 <a href="#15.2.3    ">15.2.3节</a>将会介绍两种特殊情况） </p>
</li>
<li><p>引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起 （<a href= "#2.4.1    const 的引用">2.4.1 节详述 </a>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>; <span class="comment">// 错误： 引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval; <span class="comment">// 错误： 此处引用类型的初始值必须是 int 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol>
<li><p>定义：“ 指向（ point to)” 另外一种类型的复合类型  </p>
</li>
<li><p>作用：实现了对其他对象的间接访问  </p>
</li>
<li><p>指针和引用的区别：</p>
<ol>
<li>指针本身就是一个对象， 允许对指针赋值和拷贝</li>
<li>在指针的生命周期内它可以先后指向几个不同的对象  </li>
<li>指针无须在定义时赋初值</li>
<li>块作用域内定义的指针如果没有被初始化， 也将拥有一个不确定的值，这和和其他内置类型一样</li>
</ol>
</li>
<li><p>定义指针类型的方法 </p>
<ul>
<li><p>将声明符写成*d 的形式 </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ipl，*ip2； <span class="comment">// ipl 和ip2 都是指向 int 型对象的指针</span></span><br><span class="line"><span class="keyword">double</span> dp，*dp2; <span class="comment">// dp2 是指向 double 型对象的指针， dp 是 double 型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h5><ol>
<li><p>方法：取地址符（ 操作符 &amp; ):  </p>
</li>
<li><p>作用：指针存放某个对象的地址， &amp;获取该地址， </p>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p 存放变量 ival 的地址， 或者说p 是指向变量 ival 的指针</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项：</p>
<ol>
<li><p>引用不是对象， 没有实际地址， 所以不能定义指向引用的指针  </p>
</li>
<li><p>所有指针的类型都要和它所指向的对象严格匹配（<a href = "#2.4.2    指针和 const  ">2.4.2节</a>，<a href="#">15.2.3 节  </a>将介绍两种例外情况）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval；<span class="comment">// 正确： 初始值是 double 型对象的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd；<span class="comment">// 正确： 初始值是指向 double 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *pi = pd；<span class="comment">// 错误： 指针 pi 的类型和 pd 的类型不匹配</span></span><br><span class="line">pi = &amp;dval；<span class="comment">// 错误： 试图把 double 型对象的地址赋给 int 型指针</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>指针的值（ 即地址） 应属下列 4 种状态之一:  </p>
<ol>
<li>指向一个对象。  </li>
<li>指向紧邻对象所占空间的下一个位置。  </li>
<li>空指针， 意味着指针没有指向任何对象  </li>
<li>无效指针， 也就是上述情况之外的其他值  </li>
</ol>
<p>注意事项：</p>
<ol>
<li>试图拷贝或以其他方式访问无效指针的值都将引发错误（编译器不检查此类错误）</li>
<li>第 2 种和第 3 种形式的指针是有效的， 但其使用同样受到限制  ；这些指针没有指向任何具体对象， 所以试图访问此类指针（ 假定的） 对象的行为不被允许。</li>
</ol>
<h5 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h5><ol>
<li><p>如果指针指向了一个对象， 则允许使用解引用符（ 操作符* ) 来访问该对象:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">// p 存放着变量ival的地址， 或者说p 是指向变量ival的指针</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">// 由符号*得到指针 p 所指的对象， 输出 42</span></span><br></pre></td></tr></table></figure></li>
<li><p>对指针解引用会得出所指的对象  ;因此如果给解引用的结果赋值， 实际上也就是给指针所<br>指的对象赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;<span class="comment">// 由符号 *得到指针 p 所指的对象， 即可经由 p 为变量 ival 賦值</span></span><br><span class="line">cout &lt;&lt; *p； <span class="comment">//输出0</span></span><br><span class="line">cout &lt;&lt; ival； <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure></li>
<li><p>解引用操作仅适用于那些确实指向了某个对象的有效指针  </p>
</li>
<li><p>重点符号解析 <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705134829386.png" alt="image-20220705134829386"></p>
</li>
</ol>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><ol>
<li><p>空指针  （null pointer )   ：<br>不指向任何对象  </p>
</li>
<li><p>生成空指针的样例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705135446493.png" alt="image-20220705135446493"></p>
</li>
<li><p>注意事项：</p>
<p>在试图使用一个指针之前代码可以首先检查它是否为空  </p>
</li>
<li><p>拓展知识</p>
<ol>
<li>预处理变量（preprocessor variable)  ：NULL  给指针赋值， 这个变量在头文件 cstdlib 中定义， 它的值就是 0  </li>
<li>预处理器 （<a href = "# 2.6.3    编写自己的头文件 ">2.6.3 节</a>） ：是运行于编译过程之前的一段程序  <ol>
<li>预处理变量不属于命名空间 std  </li>
<li>由预处理器负责管理  </li>
</ol>
</li>
<li>关于给指针变量赋空指针的建议：<ol>
<li>最好使用 nullptr,同时尽量避免使用 NULL.  </li>
<li>把 int 变量直接陚给指针是错误的操作， 即使 int 变量的值恰好等于 0 也不行。<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140303477.png" alt="image-20220705140303477"></li>
<li>建议： 初始化所有指针<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705140417164.png" alt="image-20220705140417164"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h5><ol>
<li><p>指针和引用的区别：</p>
<ol>
<li><p>指针，指针和他指向的对象之间的对应关系可以修改，也就是说，指针可以修改</p>
</li>
<li><p>引用，并不是一个对象，引用一旦确定是无法修改的</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705142026882.png" alt="image-20220705142026882"></p>
</li>
</ol>
</li>
<li><p>一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值  </p>
<ol>
<li><p>赋值永远改变的是等号左侧的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;ival;<span class="comment">// pi 的值被改变， 现在 pi 指向了 ival</span></span><br><span class="line"></span><br><span class="line">*pi = <span class="number">0</span>;<span class="comment">// ival 的值被改变， 指针pi 并没有改变,</span></span><br><span class="line">		<span class="comment">//*Pi( 也就是指针pi 指向的那个对象） 发生改变。</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h5><p>更过内容参见 <a href = "#3.5.3     指针和数组 ">3.5.3节</a> </p>
<p>只要指针拥有一个合法值， 就能将它用在条件表达式中。 和采用算术值作为条件（ <a href = " # 2.1.2    类型转换">2.1.2 节， 第 32 页</a> ） 遵循的规则类似， 如果指针的值是 0, 条件取 false:  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143008646.png" alt="image-20220705143008646"></p>
<p>指针比较的注意事项：</p>
<ol>
<li>两个类型相同的合法指针， 可以用相等操作符（=) 或不相等操作符（!=) 来比较它们， 比较的结果是布尔类型</li>
<li>两个指针存放的地址值相同， 则它们相等： 反之它们不相等。  </li>
<li>必须使用合法指针， 使用非法指针作为条件或进行比较都会引发不可预计的后果。</li>
</ol>
<h5 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h5><p>特殊的指针类型， 可用于存放任意对象的地址</p>
<p>  <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705143502627.png" alt="image-20220705143502627"></p>
<ol>
<li>void* 指针 的作用<ol>
<li>和别的指针比较  </li>
<li>作为函数的输入或输出  </li>
<li>赋给另外一个 void*指针  </li>
</ol>
</li>
<li>void*不能做的事情<ol>
<li>不能直接操作 void*指针所指的对象， 因为我们并不知道这个对象到底是什么类型， 也就无法确定能在这个对象上做哪些操作  </li>
<li>详情参见<a href = "# ">19.1.1 节（ 第 726 页）  </a></li>
</ol>
</li>
<li>获取 void*指针所存地址的方法<br><a href = "# 4.11.3     显式转换 ">4.11.3 节（ 第 144<br>页）</a></li>
</ol>
<h4 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h4><ul>
<li>变量的定义包括 ：一个基本数据类型 （ base type) 和一组声明符  <ul>
<li>基本数据类型只有一个， 但是声明符的形式却可以不冋  <ul>
<li>一条定义语句可能定义出不同类型的变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144116016.png" alt="image-20220705144116016"></li>
</ul>
</li>
<li>很多程序员容易迷惑于基本数据类型和类型修饰符的关系， 其实后者（类修饰符）不过是声明符的一部分罢了。（读者问：为什么这么说？）  </li>
</ul>
</li>
</ul>
<h5 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h5><ol>
<li>场景误区1：<ol>
<li>在定义语句中， 类型修饰符（ <em>或 &amp; ) 作用于本次定义的全部变量  。样例如下：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705144855828.png" alt="image-20220705144855828"></em></li>
<li>基本数据类型是 int 而非 int* ;   *仅仅是修饰了 p 而已， 对该声明语句中的其他变量， 它并不产生任何作用：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145027723.png" alt="image-20220705145027723"> </li>
</ol>
</li>
<li>涉及指针（*）和引用（&amp;）的两种良好书写方式：<ol>
<li>把修饰符和变量标识符写在一起<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145121668.png" alt="image-20220705145121668"><br>着重强调变量具有的复合类型  </li>
<li>把修饰符和类型名写在一起， 并且每条语句只定义一个变量<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145234491.png" alt="image-20220705145234491"><br>着重强调本次声明定义了一种复合类型</li>
</ol>
</li>
</ol>
<h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><ul>
<li> 声明符中修饰符的个数并没有限制  </li>
<li> 多个修饰符连写在一起时， 按照 其逻辑关系详加解释即可  </li>
<li>样例：<ul>
<li>指针是内存中的对象， 像其他对象一样也有自己的地址， 因此允许把指针的地址再存放到另一个指针当中。这就是指向指针的指针  .</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145705407.png" alt="image-20220705145705407"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145719372.png" alt="image-20220705145719372"></p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145812143.png" alt="image-20220705145812143"></p>
<h5 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h5><ul>
<li><p>引用本身不是一个对象， 因此不能定义指向引用的指针。</p>
</li>
<li><p>但指针是对象， 所以存在对指针的引用  。</p>
</li>
</ul>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705145915375.png" alt="image-20220705145915375"></p>
<pre><code>解读方式：int *&amp;r = p;
1.最简单的办法是从右向左阅读 r 的定义
2.离变量名最近的符号（ 此例中是&amp;r 的符号&amp; ) 对变量的类型有最直接的影响， 因此 r 是一个引用。
3.声明符的其余部分用以确定 r 引用的类型是什么， 此例中的符号* 说明 r 引用的是一个指针。
4.最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。
</code></pre>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/#comment-container"><span class="display-none-class">ab6347e30ef93c668d39bdf0bae27331</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="ab6347e30ef93c668d39bdf0bae27331">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>15 分钟  <i class="fas fa-pencil-alt"> </i>2.2 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）</a></h1><div class="content"><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>具名的、 可供程序操作的存储空间；  </p>
</li>
<li><p>每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、 该空间能存储的值的范围， 以及变量能参与的运算。  </p>
</li>
</ul>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><h5 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h5><ol>
<li><p>首先是类型说明符 （ type specifier), 随后紧跟由一个或多个变量名组成的列表， 其中变量名以逗号分隔， 最后以分号结束；  </p>
</li>
<li><p>列表中每个变量名的类型都由类型说明符指定， 定义时还可以为一个或多个变量赋初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, value, units_sold = <span class="number">0</span>； 	<span class="comment">// sum、 value 和 units_sold 都是 int</span></span><br><span class="line">										<span class="comment">//units_sold 初值为 0</span></span><br><span class="line"></span><br><span class="line">Sales_item item；			<span class="comment">// item的类型是Sales_item(参见1.5.1节，第17页 ）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string是一种库类型,表示一个可变长的字符序列</span></span><br><span class="line">std::string <span class="built_in">book</span>(<span class="string">&quot;0-201-78345-X&quot;</span> )；<span class="comment">//book通过一个string字面值初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象初识：<br>一块能存储数据并具有某种类型的内存空间 。</p>
</li>
</ol>
<h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><p>当对象在创建时获得了一个特定的值， 我们说这个对象被初始化 （ initialized) 了。  </p>
<ol>
<li><p>于初始化变量的值可以是任意复杂的表达式 ；</p>
</li>
<li><p>当一次定义了两个或多个变量时， 对象的名字随着定义也就马上可以使用了  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ / 正确： price 先被定义并賦值， 随后被用于初始化 discount</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">109.99</span>, discount = price * <span class="number">0.16</span>;</span><br><span class="line">/ /正确： 调用函数 applyDiscount， 然后用函数的返回值初始化 <span class="function">salePrice</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> salePrice <span class="title">applyDiscount</span> <span class="params">(price, discount )</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化是一个异常复杂的问题 ；很多程序序员对于用等号=来初始化变量的方式倍感闲惑， 这种方式容易让人认为初始化足赋值的一种 </p>
<ul>
<li>初始化和赋值是两个完全不同的操作  </li>
<li>在很多编程语言中，二者的区别几乎可以忽略不计  </li>
<li>初始化不是賦值， 初始化的含义是创建变量时賦予其一个初始值， 而赋值的含义是把对象的当前值擦除， 而以一个新值来替代 </li>
</ul>
</li>
</ol>
<h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><ul>
<li><p>C++11 新标准的一部分  </p>
</li>
<li><p>```c++<br>int units_sold = 0；<br>int units_sold = {0}；//列表初始化<br>int units_sold{0}；//列表初始化<br>int units_sold(0)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 无论是初始化对象还是某些时候为对象赋新值， 都可以使用这样一组由花括号括起来的初始值了。</span><br><span class="line"></span><br><span class="line">- 当用于内置类型的变量时， 这种初始化形式有一个重要特点： </span><br><span class="line">      如果我们使用列表初始化初始值存在丢失信息的风险， 则编译器将报错：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  long double Id = 3.1415926536；</span><br><span class="line">  int a&#123;ld&#125;, b = &#123;Id&#125;；	//错误： 转换未执行， 因为存在去失信息的危险</span><br><span class="line">  int c(Id), d = Id；		//正确 ： 转换执行， 且确实丢失了部分值</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><ul>
<li>定义变量时没有指定初值， 则变量被默认初始化 （ default initialized )  </li>
<li>变量类型和定义变量的位置也会对此有影响。</li>
<li>内置类型的变量未被显式初始化， 它的值由定义的位置决定  </li>
<li>定义于任何函数体之外的变量被初始化为 0  </li>
<li>定义在函数体内部的内置类型变量将不被初始化（ uninitialized)。<ul>
<li> 未被初始化的内置类型变量的值是未定义的  </li>
<li> 试图拷贝或以其他形式访问此类值将引发错误。  </li>
</ul>
</li>
</ul>
<h4 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h4><h5 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h5><ol>
<li>目的：为了允许把程序拆分成多个逻辑部分来编写  </li>
<li>形式：允许将程序分割为若干个文件， 每个文件可被独立编译  </li>
<li>要求：需要有在文件间共享代码的方法  </li>
<li>例如：一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是 std::cout 和 std::cin,<br>它们定义于标准库， 却能被我们写的程序使用。</li>
<li>C++的支持模式：声明和定义分开<ol>
<li> 声明（ declaration) 使得名字为程序所知， 一个文件如果想使用别处定义的名字则必须包含对那个名字的声明  </li>
<li> 定义(definition) 负责创建与名字关联的实体。</li>
</ol>
</li>
</ol>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同  </p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>规定了变量的类型和名字， 在这一点上定义与之相同；定义还申请存储空间， 也可能会为变量赋一个初始值 </p>
<h5 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h5><ol>
<li><p>如果想声明一个变量而非定义它， 就在变量名前添加关键字 extern, 而且不要显式地初始化变量  </p>
</li>
<li><p>任何包含了显式初始化的声明即成为定义  </p>
</li>
<li><p>在函数体内部， 如果试图初始化一个由 extern 关键字标记的变量， 将引发错误</p>
</li>
<li><p>变量能且只能被定义一次， 但是可以被多次声明。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i； <span class="comment">// 声 明i而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j； <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>；<span class="comment">//声明并且定义了k，还为k申请了内存空间并且进行了显示初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span><span class="number">.16</span>; <span class="comment">// 定义    </span></span><br></pre></td></tr></table></figure></li>
<li><p>使用情景：</p>
<ol>
<li>如果要在多个文件中使用同一个变量， 就必须将声明和定义分离  </li>
<li>变量的定义必须出现在且只能出现在一个文件中， 而其他用到该变量的文件必须对其进行声明， 却绝对不能重复定义。 </li>
</ol>
</li>
</ol>
<h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110037691.png" alt="image-20220705110037691"></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li><p>由字母、 数字和下画线组成  </p>
</li>
<li><p>必须以字母或下画线开头  </p>
</li>
<li><p>长度没有限制 ；对大小写字母敏感  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ / 定义 <span class="number">4</span> 个不同的 <span class="keyword">int</span> 变量</span><br><span class="line"><span class="keyword">int</span> somename, someName, SomeName, SOMENAME;</span><br></pre></td></tr></table></figure></li>
<li><p>C++语言保留了一些名字供语言本身使用， 这些名字不能被用作标识符  ；如表 2.3 和表 2.4 所示<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110334152.png" alt="image-20220705110334152"><br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705110356276.png" alt="image-20220705110356276"></p>
</li>
<li><p>用户自定义的标识符中不能连续出现两个下画线， 也不能以下画线紧连大写字母开头  </p>
</li>
<li><p>定义在函数体外的标识符不能以下画线开头。</p>
</li>
</ul>
<h5 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h5><ul>
<li> 标识符要能体现实际含义。</li>
<li> 变量名一般用小写字母， 如 index, 不要使用 Index 或 INDEX。</li>
<li> 用户自定义的类名一般以大写字母开头， 如 SaleS_item。</li>
<li> 如果标识符由多个单词组成， 则单词间应有明显区分，如student_loan或student_Loan；不要使用 studentloan.</li>
</ul>
<h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><ol>
<li><p>每个名字都会指向一个特定的实体： 变量、 函数、 类型等  </p>
</li>
<li><p>同—个名字如果出现在程序的不同位置， 也可能指向的是不同实体  </p>
</li>
<li><p>作用域  </p>
<ol>
<li>C++语言中大多数作用域都以花括号分隔。</li>
</ol>
</li>
<li><p>实例：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705111857075.png" alt="image-20220705111857075"></p>
</li>
</ol>
<h5 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h5><ol>
<li><p>作用域能彼此包含  </p>
</li>
<li><p>内层作用域 ( innerscope )  ：被包含（ 或者说被嵌套） 的作用域  </p>
</li>
<li><p>外层作用域 ( outer scope)  ：包含着别的作用域的作用域  </p>
</li>
<li><p>作用域中一旦声明了某个名字， 它所嵌套着的所有作用域中都能访问该名字  </p>
</li>
<li><p>允许在内层作用域中重新定义外层作用域已有的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 该程序仅用于说明 ： 函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; / / reused 拥有全局作用域</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique <span class="number">0</span>; / / unique 拥有块作用域</span><br><span class="line">    <span class="comment">// 输出 #1: 使用全局变量 reused;输出 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量 reused， 覆盖了全局变量 reused</span></span><br><span class="line">    <span class="comment">// 输出 #2: 使用局部变量 reused; 输出 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出#3: 显式地访问全局变量 reused; 输出 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//全局作用域本身并没有名字， 所以当作用域操作符的左侧为空时， </span></span><br><span class="line">    <span class="comment">//向全局作用域发出请求获取作用域操作符右侧名字对应的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数有可能用到某全局变量， 则不宜再定义一个同名的局部变量 </p>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-06  <a class="commentCountImg" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/#comment-container"><span class="display-none-class">4f414a57dff37f6a58bd2f6e4d685fc6</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="4f414a57dff37f6a58bd2f6e4d685fc6">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>12 分钟  <i class="fas fa-pencil-alt"> </i>1.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/">Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）</a></h1><div class="content"><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><ul>
<li>包括算术类型（ arithmetic type ) 和空类型（ void)   </li>
</ul>
<h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><ol>
<li><p>整型（ integral type， 包括字符和布尔类型在内）   </p>
</li>
<li><p>浮点型 </p>
<p>算术类型的取值范围 </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630182629855.png" alt="image-20220630182629855"></p>
<ul>
<li>扩展字符集<ul>
<li>wchar_t, char16_t、 char32_t  </li>
<li>用于确保可以存放机器最大扩展字符集士的任意一个字符  </li>
<li>char16_t 和char32_t 则为 Unicode 字符集服务 (Unicode 是用于表示所有自然语言中字符的标准)  </li>
<li>大小关系：short &lt;=  int &lt;= long &lt;= long long;</li>
</ul>
</li>
<li>计算机内存单位转换<ul>
<li>寻址的最小内存块称为“ 字节（ byte )  ，一般一个字节由8比特组成</li>
<li>存储的基本单元称为 ‘‘ 字（ word )”， 它通常由几个字节组成  </li>
<li>字则由 32 或 64 比特构成， 也就是 4 或 8 字节  </li>
</ul>
</li>
<li>带符号类型和无符号类型  <ul>
<li>除去布尔型和扩展的字符型之外， 其他整型可以划分为带符号的（ signed) 和无符号<br>的（ unsigned) 两种  </li>
<li>带符号类型可以表示正数、 负数或 0  </li>
<li>无符号类型则仅能表示大于等于 0 的值。 </li>
</ul>
</li>
<li>字符型   <ul>
<li>char、 signed char 和 unsigned char  </li>
<li>类型 char 和类型 signed char 并不一样 </li>
<li>尽管字符型有三种， 但是字符的表现形式却只有两种： 带符号的和无符号的。 类型 char 实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定  </li>
</ul>
</li>
<li>数据类型选择准则<ul>
<li> 数值不可能为负时， 选用无符号类型</li>
<li> int 执行整数运算（short 常常显得太小  ）  </li>
<li> 整数运算的数值超过了int 的表示范围， 选用 long long（long 一般和 int有一样的尺寸）</li>
<li>算术表达式中不要使用 char 或 bool <ul>
<li> 类型 char 在一些机器上是有符号， 而在另一些机器上又是无符号，行运算特别容易出问题  ；</li>
<li> 如果你需要使用一个不大的整数，明确指定它的类型是 signed char 或者 unsigned char</li>
</ul>
</li>
<li> 执行浮点数运算选用 double, 这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几</li>
<li> long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视 。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>​                将对象从一种给定的类型转换 ( convert) 为另一种相关类型 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>; <span class="comment">// b 为真</span></span><br><span class="line"><span class="keyword">int</span> i = b;	<span class="comment">// i的值为 1</span></span><br><span class="line">i = <span class="number">3.14</span>;	<span class="comment">// i的值为 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;	<span class="comment">// pi 的值为 3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;	<span class="comment">// 假设 char 占 8 比特， c 的值为 255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;	<span class="comment">// 假设 char 占 8 比特， c2 的值是未定义的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非布尔类型  &gt; 布尔类型  :    初始值为 0 则结果为 false,否则结果为 true  </li>
<li>布尔值  &gt; 非布尔类型  :    初始值为 false 则结果为 0, 初始值为true 则结果为 1</li>
<li>浮点数  &gt;整数类型  :      值仅保留浮点数中小数点之前的部分。</li>
<li>整数 &gt;     浮点类型  :   整数部分不变，小数部分记为0；如果该整数所占的空间超过了浮点类型的容量， 精度可能有损失  </li>
<li>值  &gt; 无符号类型  :    初始值对无符号类型表示数值总数取模后的余数  ;</li>
<li>值  &gt;  带符号类型： 结果未定义；程序可能继续工作、可能崩溃，也可能生成垃圾数据</li>
</ul>
<h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><h5 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h5><ol>
<li><p>整型:</p>
<ul>
<li><p>以 0 开头的整数代表八进制数， </p>
</li>
<li><p>以 0x 或 0X 开头的代表十六进制数  </p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220703112008479.png" alt="image-20220703112008479"></p>
</li>
</ul>
</li>
<li><p>整型字面值具体的数据类型由它的值和符号决定  </p>
<ol>
<li>默认情况下， 十进制字面值是带符号数,八进制和十六进制字面值既可能是带符号的也可能是无符号的  ;</li>
<li>十进制字面值的类型是int、 long 和 long long 中尺寸最小的那个（例如， 三者当中最小是int), 当然前提<br>是这种类型要能容纳下当前的值  </li>
<li>八进制和十六进制字面值的类型是能容纳其数值的int、 unsignedint、 long、 unsigned long、 longlong 和 unsigned long long<br>中的尺寸最小者  </li>
<li>如果一个字面值连与之关联的最大的数据类型都放不下， 将产生错误  ;</li>
</ol>
</li>
</ol>
<h5 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h5><ol>
<li><p>字符字面值：单引号，单个字符</p>
</li>
<li><p>字符串字面值：双引号，零个或者多个字符</p>
<ol>
<li><p>常量字符构成的数组 ( array )  </p>
</li>
<li><p>编译器在每个字符串的结尾处添加一个空字符（ ‘\0’)  ;</p>
</li>
<li><p>字面值’ A’ 表示的就是单独的字符 A, 而字符串”A”则代表了一个字符的数组， 该数组包含两个字符： 一个是字母 A、 另一个是空字符;</p>
</li>
<li><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705093933509.png" alt="image-20220705093933509"></p>
</li>
<li><p>分行书写字符串：</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094045581.png" alt="image-20220705094045581"></p>
</li>
</ol>
</li>
</ol>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><ol>
<li>程序员不可使用的两类字符：<ol>
<li>不可打印字符：退格或其他控制字符，因为他们没有可视的图符</li>
<li>转义序列：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094438754.png" alt="image-20220705094438754"></li>
</ol>
</li>
</ol>
<h5 id="泛化的转义序列"><a href="#泛化的转义序列" class="headerlink" title="泛化的转义序列"></a>泛化的转义序列</h5><ol>
<li><p>\x 后紧跟 1 个或多个十六进制数字 </p>
</li>
<li><p>\后紧跟 1 个、 2 个或 3 个八进制数字  </p>
</li>
<li><p>数字部分表示的是字符对应的数值  </p>
</li>
<li><p>以Latin-1 字符集  实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705094653556.png" alt="image-20220705094653556"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>;		<span class="comment">// 输出 Hi MOM!, 转到新一行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;			<span class="comment">//输出 M, 转到新一行</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ol>
<li><p>反斜线\后面跟着的八进制数字超过 3 个， 只有前 3 个数字与\构成转义序列<br>例如， “\1234”表示 2 个字符， 即八进制数 123 对应的字符以及字符 4。  </p>
</li>
<li><p>\x要用到后面跟着的所有数字， 例如， “\x1234” 表示一个 16 位的字符， 该字符由这 4 个十六进制数所对应的比特唯一确定。  </p>
<p>读者不理解的地方：    </p>
<ul>
<li>因为大多数机器的 char 型数据占 8 位， 所以上面这个例子可能会报错。 一般来说， 超过 8 位的十六进制字符都是与表 2.2 中某个前缀作为开头的扩展字符集一起使用的。  </li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h5><p>​    通过添加如表 2.2 中所列的前缀和后缀， 可以改变整型、 浮点型和字符型字面值的默认类型。<br> <img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095748545.png" alt="image-20220705095748545"></p>
<p>实例：<br><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220705095835204.png" alt="image-20220705095835204"></p>
<h5 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h5><ol>
<li>布尔字面值<ol>
<li>true 和 false 是布尔类型的字面值  </li>
</ol>
</li>
<li>指针字面值<ol>
<li>nullptr 是指针字面值， 2.3.2 节（ 第 47 页） 将有更多关丁•指针和指针字面值的介绍  </li>
</ol>
</li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"><img class="fill" src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="C++Primer 第五版 第一章"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-03  <a class="commentCountImg" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/#comment-container"><span class="display-none-class">b6ac0b7125778ed92f89b6ee5b71136d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b6ac0b7125778ed92f89b6ee5b71136d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 分钟  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/">C++Primer 第五版 第一章</a></h1><div class="content"><h1 id="C-Primer-第五版-第一章"><a href="#C-Primer-第五版-第一章" class="headerlink" title="C++Primer 第五版 第一章"></a>C++Primer 第五版 第一章</h1><h2 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章    开始"></a>第1章    开始</h2><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1    编写一个简单的C++程序"></a>1.1    编写一个简单的C++程序</h3><ol>
<li><p>函数组成=返回类型+函数名+形参列表+函数体</p>
<p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/2022-06-30_124642.png"></p>
</li>
<li><p>注意事项</p>
<ul>
<li><p>main 函数的返回类型必须为 int  ；</p>
</li>
<li><p>int 类型是一种内置类型  ；</p>
</li>
<li><p>内置类型 （ built-in type ), 即语言自身定义的类型；</p>
</li>
<li><p>类型 ：不仅定义了数据元素的内容， 还定义了这类数据上可以进行的运算。  </p>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-1-编译、运行程序"><a href="#1-1-1-编译、运行程序" class="headerlink" title="1.1.1    编译、运行程序"></a>1.1.1    编译、运行程序</h4><ol>
<li><p>如何编译程序  ？</p>
<ul>
<li>依赖于操作系统和编译器  </li>
</ul>
</li>
<li><p>IDE  ：集成开发环境（ Integrated Developed Environment, IDE)  </p>
</li>
<li><p>特定编译器的相关使用细节， 请査阅参考手册或询问经验丰富的同事  </p>
</li>
<li><p>程序源文件命名约定  </p>
<ol>
<li>程序文件通常被称为源文件（ source file)  </li>
<li>源文件的名字以一个后缀为结尾  ，后缀是由一个句点后接一个或多个字符组成的  ；最常见的包括.CC、.cxx,.cPP、.cP 及.C </li>
</ol>
</li>
<li><p> 从命令行运行编译器  </p>
</li>
<li><p>源文件 progl.cc  </p>
</li>
<li><p>如下命令来编译  </p>
<ol>
<li><p>$ CC progl.cc  </p>
</li>
<li><p>CC 是编译器程序的名字， $是系统提示符。 编译器生成一个可执行文件。  </p>
</li>
<li><p>Windows  ：progl.exe</p>
<ol>
<li>progl.exe</li>
<li>$ progl  </li>
</ol>
</li>
<li><p>UNIX  :a.out</p>
<ol>
<li>a.out</li>
<li>$ a.out</li>
</ol>
</li>
<li><p>echo 命令获得其返回值  </p>
<ol>
<li>UNIX  : $ echo $?  </li>
<li>Windows  : $ echo %ERRORLKVEL%  </li>
</ol>
</li>
<li><p>特殊情况：须显式指出文件的位置  </p>
<ol>
<li>Windows  ：$ .\progl</li>
<li>Unix: $ ./a.out</li>
</ol>
</li>
<li><p>运行 GNU或微软编译器  </p>
<ol>
<li>Page 30</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2    初识输入输出"></a>1.2    初识输入输出</h3><ol>
<li>C++语言并未定义任何输入输出 (10 ) 语句  ;包含了一个全面的标准库( standard library) 来提供 10 机制（ 以及很多其他设施)</li>
<li>iostream 库  <ol>
<li>istream  输入流  </li>
<li>ostream  输出流  </li>
<li>流  <ol>
<li>一个流就是一个字符序列  </li>
<li>术语“ 流”（ stream)   :随着时间的推移， 字符是顺序生成或消耗的  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h4><ol>
<li><p>定义了 4 个 IO 对象 </p>
<ol>
<li> cin  </li>
<li>istream 类型的对象  </li>
<li>标准输入（ standard input)  </li>
<li>cout    <ol>
<li>ostream 类型的对象  </li>
<li>标准输出（ standard output)  </li>
</ol>
</li>
<li>cerr  <ol>
<li>输出警告和错误消息  </li>
<li>标准错误 （ standard error)  </li>
</ol>
</li>
<li>clog  <ol>
<li>输出程序运行时的一般性信息  </li>
</ol>
</li>
</ol>
</li>
<li><p>一个使用 IO 库的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:</span></span><br><span class="line"><span class="string">	int vl = 0, v2 = 0;</span></span><br><span class="line"><span class="string">	std::cin » vl » v2;</span></span><br><span class="line"><span class="string">	std::cout &lt;&lt; &quot;</span>The sum of <span class="string">&quot; &lt;&lt; vl &lt;&lt; &quot;</span> <span class="keyword">and</span> <span class="string">&quot; &lt;&lt; v2&lt;&lt; &quot;</span> is <span class="string">&quot; &lt;&lt; vl + v2 &lt;&lt;std::endl;</span></span><br><span class="line"><span class="string">	« std::endl;</span></span><br><span class="line"><span class="string">	return 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>头文件（ header)  <ol>
<li>指令和头文件的名字必须写在同一行中  </li>
<li>放在源文件的开始位置  </li>
<li>必须出现在所有函数之外 </li>
</ol>
</li>
</ol>
</li>
<li><p> 向流写入数据  </p>
</li>
<li><p>表达式（ expression)  : 一个或多个运算对象和（ 通常是） 一个运算符组成  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout « <span class="string">&quot;Enter two numbers: &lt;&lt; std::endl;  </span></span><br></pre></td></tr></table></figure></li>
<li><p>输出运算符（&lt;&lt;)  </p>
<ol>
<li><p>&lt;&lt;运算符接受两个运算对象： 左侧的运算对象必须是一个 ostream 对象， 右侧的运算对<br>象是要打印的值  </p>
</li>
<li><p>此运算符返回其左侧的运算对象  </p>
</li>
<li><p>将给定的值写到给定的 ostream 对象中  </p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(std::cout « <span class="string">&quot;Enter two numbers:&quot;</span> ) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span>；</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串字面值常量  “Enter two numbers:”</p>
<ol>
<li>双引号包围的字符序列  ，双引号之间的文本被打印到标准输出  </li>
</ol>
</li>
<li><p>endl  </p>
<ol>
<li>操纵符（ manipulator);  特殊值  </li>
<li>效果是结束当前行， 并将与设备关联的缓冲区 （ buffer) 中的内容刷到设备中  </li>
</ol>
</li>
</ol>
</li>
<li><p>使用标准库中的名字  </p>
<ol>
<li>std::cout 和 std::endl  </li>
<li>std 的命名空间(namespace)   </li>
<li>避免不经意的名字定义冲突  ,以及使用库中相同名字导致的冲突  </li>
<li>作用域运算符 (::)   </li>
</ol>
</li>
<li><p>从流读取数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl &gt;&gt; v2;  </span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入运算符（ &gt;&gt;)</p>
<ol>
<li><p>从给定的 istream 读入数据， 并存入给定对象中  </p>
</li>
<li><p>返回其左侧运算对象作为其计算结果</p>
</li>
<li><p>等价于  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( std::cin &gt;&gt; vl ) &gt;&gt; v2;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; vl;</span><br><span class="line">std::cin &gt;&gt; v2;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3    注释简介"></a>1.3    注释简介</h3><p>C++中注释的种类  </p>
<ul>
<li>C++中有两种注释： <ul>
<li>单行注释:以双斜线 ( / / ) 开始， 以换行符结束  ;当前行双斜线右侧的所有内容都会被编译器忽略  </li>
</ul>
</li>
<li>界定符对注释  <ul>
<li>继承自 C 语言的两个界定符（ /*<em>和</em> */ )  </li>
<li>落在/<strong>和</strong> <em>/之间的所有内容都当作注释 ; 可以包含除</em> /外的任意内容， 包括换行符  </li>
<li>注释界定符不能嵌套  </li>
</ul>
</li>
</ul>
<h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4    控制流"></a>1.4    控制流</h3><h4 id="1-4-1-while语句"><a href="#1-4-1-while语句" class="headerlink" title="1.4.1    while语句"></a>1.4.1    while语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630141324624.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &#123;condition)</span><br><span class="line">statement  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行过程是交替地检测 condition 条件和执行关联的语句statement  ，直到condition为假时停止  </p>
</li>
<li><p>小于等于运算符（&lt;=)</p>
</li>
<li><p>复合赋值运算符 （ +=)  </p>
</li>
<li><p>前缀递增运算符 （ ++ )  </p>
</li>
</ul>
<h4 id="1-4-2-for语句"><a href="#1-4-2-for语句" class="headerlink" title="1.4.2    for语句"></a>1.4.2    for语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> sum</span><br><span class="line">    / / 从 <span class="number">1</span>加到 <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">      sum += val; <span class="comment">// 等 价 于 + val  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	sum += sum = sum</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3     读取数量不定的输入数据"></a>1.4.3     读取数量不定的输入数据</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630142805148.png"></p>
<ul>
<li>使用一个 istream 对象作为条件时 ,其效果是检测流的状态;</li>
<li>流是有效的， 即流未遇到错误， 那么检测成功    </li>
<li>遇到文件结束符 ( end-of-file), 或遇到一个无效输入时（ 例如读入的值不是一个整数）， istream 对象的状态会变为无效  </li>
<li>如何指出文件结束  <ul>
<li>Windows 系统  <ul>
<li>敲 Ctrl+Z ( 按住 Ctrl 键的同时按 Z 键 ），然后按 Enter 或 Return 键  </li>
</ul>
</li>
<li>UNIX 系统  /MacOSX 系统  <ul>
<li>Ctrl+D  </li>
</ul>
</li>
</ul>
</li>
<li>再 探 编 译  <ul>
<li>语法错误（ syntax error )  </li>
<li>类型错误（ type error )  </li>
<li>声明错误（ declaration error )  </li>
<li>按照错误信息报告的顺序来逐个修正错误， 是一种好习惯  。因为单个错误常常会具有传递效应 ， 导致编译器在其后报告比实际数量多得多的错误信息。 另一个好习惯是在每修正一个错误后就立即重新编译代码， 或者最多是修正了一小部分明显的错误后就重新编译 ： 这就是所谓的 “编辑-编译-调试 ”（ edit-compile-debug ) 周期。  </li>
</ul>
</li>
</ul>
<h4 id="1-4-4-if语句"><a href="#1-4-4-if语句" class="headerlink" title="1.4.4    if语句"></a>1.4.4    if语句</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630143559254.png"></p>
<ul>
<li><p>相等运算符（ ==) </p>
<ul>
<li>C++用=进行赋值， 用==作为相等运算符；两个运算符都可以出现在条件中 。一个常见的错误是想在条件中使用== ( 相等判断 ）， 却误用了= 。</li>
</ul>
</li>
</ul>
<h3 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5    类简介"></a>1.5    类简介</h3><ul>
<li>类机制是 C++最重要的特性之一  </li>
<li>一个类定义了一个类型， 以及与其关联的一组操作  </li>
<li>通过定义一个类 (class) 来定义自己的数据结构 </li>
<li>使用头文件来访问为自己的应用程序所定义的类  <ul>
<li> 通常使用.h 作为头文件的后缀  </li>
<li>一些程序员习惯.H、 .hpp 或.hxx  </li>
<li>标准库头文件通常不带后缀  </li>
</ul>
</li>
<li>类的作者决定了类类型对象上可以使用的所有操作  </li>
</ul>
<h4 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1    Sales_item类"></a>1.5.1    Sales_item类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item item;</span><br></pre></td></tr></table></figure>

<p>表达 item 是一个 Sales_item 类型的对象。 我们通常将“ 一个 Sales_item 类型的对象” 简单说成“ 一个 Sales_item 对象”， 或更简单的“ 一个 Sales_item”。</p>
<h4 id="读写Sales-item"><a href="#读写Sales-item" class="headerlink" title="读写Sales_item"></a>读写Sales_item</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630150431130.png"></p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li><p>来自标准库的头文件 ：应该用尖括号（&lt; &gt;) 包围头文件名  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>不属于标准库的头文件  ：用双引号（ “ “） 包围  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_item.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Sales-item-对象的加法"><a href="#Sales-item-对象的加法" class="headerlink" title="Sales_item 对象的加法"></a>Sales_item 对象的加法</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630151614240.png"></p>
<p>对于 Sales_item 对象， 我们用了一个全新的“ 和” 的概念 : 两个 Sales_item 对象的成员对应相加的结果。</p>
<h4 id="使用文件取定向"><a href="#使用文件取定向" class="headerlink" title="使用文件取定向"></a>使用文件取定向</h4><p>​        当你测试程序时， 反复从键盘敲入这些销售记录作为程序的输入， 是非常乏味的 。大多数操作系统支持文件重定向， 这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addlterns &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>假定$是操作系统提示符， 我们的加法程序已经编译为名为 addltems.exe 的可执行文件（ 在 UNIX 中addltems ). 则上述命令会从一个名为 infile 的文件读取销售记录， 并将输出结果写入到一个名为 outfile 的文件中， 两个文件都位于当前目录中。  </p>
<h4 id="1-5-2-初识成员函数"><a href="#1-5-2-初识成员函数" class="headerlink" title="1.5.2    初识成员函数"></a>1.5.2    初识成员函数</h4><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152050811.png"></p>
<ol>
<li>什么是成员函数？  <ol>
<li>成员函数是定义为类的一部分的函数， 有时也被称为方法（ method)。</li>
<li>通常以一个类对象的名义来调用成员函数：iteml.isbn ( )      </li>
<li>点运算符（.）  <ol>
<li>只能用于类类型的对象。   </li>
<li>左侧运算对象必须是一个类类型的对象， 右侧运算对象必须是该类型<br>的一个成员名， 运算结果为右侧运算对象指定的成员  </li>
</ol>
</li>
<li>调用运算符（（ ） ）  <ol>
<li>调用运算符是一对圆括号， 里面放置实参( argument) 列表（ 可能为空）  </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-6-书店程序"><a href="#1-6-书店程序" class="headerlink" title="1.6    书店程序"></a>1.6    书店程序</h3><p><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/image-20220630152712392.png"></p>
<h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><ol>
<li>参数（ 实参， argument ) 向函数传递的值。  </li>
<li>赋值 ( assignment) 抹去一个对象的当前值， 用一个新值取代之。</li>
<li>程序块（ block ) 零条或多条语句的序列，用花括号包围。</li>
<li>缓冲区（ buffer ) —个存储区域， 用于保存数据。 IO 设施通常将输入 （ 或输出） 数据保存在一个缓冲区中， 读写缓冲区的动作与程序中的动作是无关的。 我们可以显式地刷新输出缓冲， 以便强制将缓冲区中的<br>数据写入输出设备。 默认情况下， 读 cin会刷新 cout； 程序非正常终止时也会刷新couto  </li>
<li>内置类型（ built-in type ) 由语言定义的类型， 如 int.</li>
<li>Cerr 一 个 ostream 对象， 关联到标准错误， 通常写入到与标准输出相同的设备。 默认情况下， 写到<br>Cerr的数据是不缓冲的，Cerr通常用于输出错误倍息或其他不屑于程序正常逻辑的输出内容  </li>
<li>字 符 串 字 面 值 常 量 （ character string literal) 术语 string literal 的另一种叫法  </li>
<li>cin —个 istream 对象， 用来从标准输入读取数据。  </li>
<li>类 (class) 一种用于定义自己的数据结构及其相关操作的机制。 类是 C++中最基木的特性之 一。 标准库类型中， 如 istream和ostream  都是类  </li>
<li>类 类 型 （ class type ) 类定义的类型。 类名即为类型名  </li>
<li>clog 一 个 ostream 对象， 关联到标准错误。 默认情况下， 写到 clog 的数据是被缓冲的。 clog 通常用于报告程序的执行信息. 存入一个日志文件中  </li>
<li>注 释（ comment) 被编译器忽略的程序文本。 C++有两种类羽的注释： 单行注释和界定符对注释。 单行注释以/ / 开始， 从 / /到行尾的所有内容都是注释。 界定符对注释以/ * 汗始， 其后的所有内容都萣注释,直至遇到* / 为止。    </li>
<li>条 件 ( condition) 求值结果为真或假的表达式。 通常用值 0 表示假， 用非零表示真。  </li>
<li>cout  一个 ostream 对象， 用于将数据写入标准输出。 通常用于程序的正常输出内容。  </li>
<li>花括号 ( curly brace ) 花括号用于划定程序块边界。 左花括号 ( { ) 为程序块开始，右花括号（ } ) 为结朿。  </li>
<li>数据结构 (data structure) 数据及其上所允许的操作的 一种逻辑组合。  </li>
<li>编辑-编译-调试 （ edit-compile-debug ) 使程序能正确执行的开发过程  </li>
<li>文件结束符 （ end-of-file) 系统特定的标识， 指出文件中无更多数据了。</li>
<li>表达式 （ expression ) 最小的计算单元。 一个表达式包含 一 个或多个运算对象， 通常还含 一个或多个运算符。 表达式求值会产生一个结果。 例如， 假设i和 j 是 int对象， 则i+j 是一个表达式, 它产生两个  int 值的和。  </li>
<li>……  </li>
</ol>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/C/">C++</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/C/">C++</a></div><hr></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/C/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/tags/C/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/C/">1</a></li><li><a class="pagination-link is-current" href="/tags/C/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="西北看长安"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">西北看长安</p><p class="is-size-6 is-block">斯人若彩虹,遇上方知有</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/panxizi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/6334161054/profile?topnav=1&amp;wvr=6"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:pxytravel@hotmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/07/13/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第二节 算术运算符）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-13T14:25:00.000Z">2022-07-13</time></p><p class="title"><a href="/2022/07/13/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第二节 算术运算符）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第四章 表达式 第一节 基础）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:42:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/">Primer C++ 第五版（第四章 表达式 第一节 基础）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="通信技术概论"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:33:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/">通信技术概论</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/12/%E6%88%91%E7%9A%84C++%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="我的C++学习之路"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-12T14:25:00.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/%E6%88%91%E7%9A%84C++%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">我的C++学习之路</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/"><img src="http://cdn.jsdelivr.net/gh/panxizi/blog_image/img/C++_pic/ffe1268ebd4674668d8b8adc79fa46d.png" alt="Primer C++ 第五版（第三章 字符串、向量和数组 第六节 多维数组）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-11T12:38:00.000Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/">Primer C++ 第五版（第三章 字符串、向量和数组 第六节 多维数组）</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="西北看长安" height="28"></a><p class="size-small"><span>&copy; 2022 Xizi Pan</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/7/30 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('caaaf20d3f0434f71aec','f6ec4790125791c276cfe048a3896b473cbc13e9','panxizi','panxizi.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>