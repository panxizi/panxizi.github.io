{"pages":[{"title":"","text":"个人简介 学习、挣钱、爱家人、爱自己 暂时就这么多 💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：电子信息科学与技术专业从事C++二层通信网络开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–*2020.07.30: 使用原博主的代码克隆代码–*2021.08.07: 修改博客的logo,头像,github链接,微博链接等外部链接–*2021.08.07: 添加博客文章进行发表博客的功能测试,顺带测试标签分类等功能–*2021.08.07: 调试博客文章的评论功能–*2.21.08.07: 学习并调试利用jsDelivr+Github搭建博客图床–*2021.08.07: 调试看板娘,但是我觉得她不符合猛男气质,所以把她给干掉了–*2021.08.08: 调试留言,碎碎念等功能模块–*2021.08.08: 修改关于页面的内容 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 暂时没有更新 其他 网易云音乐歌单分享 这里还没更新内容，如你所见，歌单是别人的。 计划2021计划2021.07.30 2021-GOALS(Jul.~Dec.) 搭建个人博客 系统学习C++服务器端开发只是 额外： 憨批,学习,挣钱 总结： 憨批,学习,挣钱 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 馒头 风景 径山 东极岛 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://github.com/panxizi/panxizi.github.io/blob/88702530126cb894ccc8c5bb76262e9c8f61ae8e/img/avatar.png 网站名称：西北看长安 网站地址：https://panxizi.github.io/ 网站简介：通信开发，技术分享,记录生活 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '523cfe3e817178155ce2', clientSecret: '723c2f242ffd459f850590b17962112dfcf59920', id: '7777777', repo: 'issue_database', owner: 'panxizi', admin: \"panxizi\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Git Tag详解","text":"Git tag 详解1、什么是标签？​ 和大多数的VCS一样，git可以对某一个时间点上的版本打标签，通俗的说法是就是标记某个时间的位置；它的好处是让我们更加容易的找到某个特定的提交记录，方便我们从这个时间进行一些版本管理动作，例如发布发某个版本，或者是从某个特定的时间点拉出分支进行开发。 2、如何列出已有的标签？ ​ 列出所有已有标签的命令是git tag 123$ git tag v0.1 v1.3 根据指定规则列出所有符合要求的标签 12345$ git tag -a v1.4 -m 'my version 1.4' $ git tag v0.1 v1.3 v1.4 注解：以上两种列出标签的结果按照字母先后排序，排序位置不代表重要性。 3、如何新建标签？轻量级标签 轻量级标签实质上就是一个指向一个特定提交对象的引用。在这里我们将某一次的提交称之为一个提交对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455test@test MINGW64 /d/VC_Code/git_test (develop)$ git tag v1.0test@LAPTOP-ECCQUA9A MINGW64 /d/VC_Code/git_test (develop)$ git show v1.0commit e0c54eb32518ba283dc0e1b7a407a369c441ac57 (HEAD -&gt; develop, tag: v1.0, origin/develop)Author: test&lt;test@hotmail.com&gt;Date: Mon Apr 18 23:53:50 2022 +0800 code testdiff --git a/git_test/Student.h b/git_test/Student.hindex cc470c6..5cf10d7 100644--- a/git_test/Student.h+++ b/git_test/Student.h@@ -3,6 +3,6 @@ class Student { //test -1-+ //test -2 };test@test MINGW64 /d/VC_Code/git_test (develop)$ git logcommit e0c54eb32518ba283dc0e1b7a407a369c441ac57 (HEAD -&gt; develop, tag: v1.0, origin/develop)Author: test&lt;test@hotmail.com&gt;Date: Mon Apr 18 23:53:50 2022 +0800 code testcommit 4317fd26d5be6c9daaf3fc84a05e5be1a72a27b9Author: test &lt;test@hotmail.com&gt;Date: Mon Apr 18 23:53:18 2022 +0800 code reviewcommit fffede0c1a93246e2574aad82891fd234b79c0e7 (origin/master, master)Author: test &lt;test@hotmail.com&gt;Date: Mon Apr 18 23:47:49 2022 +0800 first commitcommit 5586d72f74a5ea10c664305515b3c7abe9a6bd62Author: test &lt;test@hotmail.com&gt;Date: Mon Apr 18 23:35:32 2022 +0800 添加项目文件。commit 74981babd7cb44a0ae2b96e1c3e80311dc39f664Author: test &lt;test@hotmail.com&gt;Date: Mon Apr 18 23:35:30 2022 +0800 添加 .gitignore 和 .gitattributes。 注解： 创建轻量级标签的时候不需要任何的参数 查看此标签信息，发现其对应的提交对象是最后一次的提交commit。 含附注的标签 含附注的标签则可以理解为一个特定的提交对象，它有自身的校验和信息，包含了标签名称、邮箱地址、日期和标签说明；标签本身允许使用GPG（GUN Privacy Guard）来签署或者验证。 建议：推荐使用含附注的标签，他可以保留更多的信息；如果只是临时性、不需要旁注额外信息的，则建议使用轻量级标签。 1234567891011121314151617$ git tag -a v1.4 -m 'my version 1.4' $ git tag v0.1 v1.3 v1.4$ git show v1.4 tag v1.4 Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Feb 9 14:45:11 2009 -0800 my version 1.4 commit 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge: 4a447f7... a6b4c97... Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sun Feb 8 19:02:46 2009 -0800 Merge branch 'experiment' 注解： -a anotated的首字母，指定标签名 -m 指定对应的标签说明，git会将这个标签说明一起存在上次的提交对象中；如果没有给出该项，git会启动文本编辑软件来供作者输入标签说明 签署标签 需要私匙，也可以用GPG来验证 1234567891011121314151617181920212223$ git tag -s v1.5 -m 'my signed 1.5 tag' You need a passphrase to unlock the secret key for user: &quot;Scott Chacon &lt;schacon@gee-mail.com&gt;&quot; 1024-bit DSA key, ID F721C45A, created 2009-02-09$ git show v1.5 tag v1.5 Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Feb 9 15:22:20 2009 -0800 my signed 1.5 tag -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.4.8 (Darwin) iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/ =WryJ -----END PGP SIGNATURE----- commit 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge: 4a447f7... a6b4c97... Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sun Feb 8 19:02:46 2009 -0800 Merge branch 'experiment' 注解： 将参数-a 改为-s，即singed的首字母 我们将在在后面学习如何验证签署标签！ 验证标签 可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证 12345678910111213$ git tag -v v1.4.2.1 object 883653babd8ee7ea23e6a5c392bb739348b1eb61 type commit tag v1.4.2.1 tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700 GIT 1.4.2.1 Minor fixes since 1.4.2, including git-mv and git-http with alternates. gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot; gpg: aka &quot;[jpeg image of size 1513]&quot; Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A 注解： 若是没有签署者的公钥，会报告类似下面这样的错误： 123gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A gpg: Can't check signature: public key not found error: could not verify the tag 'v1.4.2.1' 后期加注标签 可以在后期对早先的某次提交加注标签 1234567891011121314151617181920212223242526272829303132$ git log --pretty=oneline 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment' a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support 0d52aaab4479697da7686c15f77a3d64d9165190 one more thing 6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment' 0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function 4682c3261057305bdd616e23b64b0857d832627b added a todo file 166ae0c4d3f420721acbb115cc33848dfcc2121a started write support 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile 964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo 8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme$ git tag -a v1.2 9fceb02$ git tag v0.1 v1.2 v1.3 v1.4 v1.4-lw v1.5$ git show v1.2 tag v1.2 Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Feb 9 15:32:16 2009 -0800 version 1.2 commit 9fceb02d0ae598e95dc970b74767f19372d61af8 Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt; Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile ... 分享标签 默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可 1234567$ git push origin v1.5 Counting objects: 50, done. Compressing objects: 100% (38/38), done. Writing objects: 100% (44/44), 4.56 KiB, done. Total 44 (delta 18), reused 8 (delta 1) To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 注解： 如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项 1234567891011$ git push origin --tags Counting objects: 50, done. Compressing objects: 100% (38/38), done. Writing objects: 100% (44/44), 4.56 KiB, done. Total 44 (delta 18), reused 8 (delta 1) To git@github.com:schacon/simplegit.git * [new tag] v0.1 -&gt; v0.1 * [new tag] v1.2 -&gt; v1.2 * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw * [new tag] v1.5 -&gt; v1.5 4.如何从一个标签上检出分支进行开发 如我们在第一部分中说的，当我们需要检出某个标签的提交对象进行二次开发的时候，我们可以进行一下操作： 1234567$ git tag v1.0.0$ git push origin v1.0.0Total 0 (delta 0), reused 0 (delta 0)To github.com:benben/testBranch.git * [new tag] v1.0.0 -&gt; v1.0.0$ git checkout -b version1 v1.0.0Switched to a new branch 'version1'","link":"/2022/04/18/Git%20Tag%20%E8%AF%A6%E8%A7%A3/"},{"title":"C++Primer 第五版 第一章","text":"C++Primer 第五版 第一章第1章 开始1.1 编写一个简单的C++程序 函数组成=返回类型+函数名+形参列表+函数体 注意事项 main 函数的返回类型必须为 int ； int 类型是一种内置类型 ； 内置类型 （ built-in type ), 即语言自身定义的类型； 类型 ：不仅定义了数据元素的内容， 还定义了这类数据上可以进行的运算。 1.1.1 编译、运行程序 如何编译程序 ？ 依赖于操作系统和编译器 IDE ：集成开发环境（ Integrated Developed Environment, IDE) 特定编译器的相关使用细节， 请査阅参考手册或询问经验丰富的同事 程序源文件命名约定 程序文件通常被称为源文件（ source file) 源文件的名字以一个后缀为结尾 ，后缀是由一个句点后接一个或多个字符组成的 ；最常见的包括.CC、.cxx,.cPP、.cP 及.C 从命令行运行编译器 源文件 progl.cc 如下命令来编译 $ CC progl.cc CC 是编译器程序的名字， $是系统提示符。 编译器生成一个可执行文件。 Windows ：progl.exe progl.exe $ progl UNIX :a.out a.out $ a.out echo 命令获得其返回值 UNIX : $ echo $? Windows : $ echo %ERRORLKVEL% 特殊情况：须显式指出文件的位置 Windows ：$ .\\progl Unix: $ ./a.out 运行 GNU或微软编译器 Page 30 1.2 初识输入输出 C++语言并未定义任何输入输出 (10 ) 语句 ;包含了一个全面的标准库( standard library) 来提供 10 机制（ 以及很多其他设施) iostream 库 istream 输入流 ostream 输出流 流 一个流就是一个字符序列 术语“ 流”（ stream) :随着时间的推移， 字符是顺序生成或消耗的 标准输入输出对象 定义了 4 个 IO 对象 cin istream 类型的对象 标准输入（ standard input) cout ostream 类型的对象 标准输出（ standard output) cerr 输出警告和错误消息 标准错误 （ standard error) clog 输出程序运行时的一般性信息 一个使用 IO 库的程序 12345678910#include &lt;iostream&gt;int main ( ){ std::cout &lt;&lt; &quot;Enter two numbers: int vl = 0, v2 = 0; std::cin » vl » v2; std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; vl &lt;&lt; &quot; and &quot; &lt;&lt; v2&lt;&lt; &quot; is &quot; &lt;&lt; vl + v2 &lt;&lt;std::endl; « std::endl; return 0} 头文件（ header) 指令和头文件的名字必须写在同一行中 放在源文件的开始位置 必须出现在所有函数之外 向流写入数据 表达式（ expression) : 一个或多个运算对象和（ 通常是） 一个运算符组成 1std::cout « &quot;Enter two numbers: &lt;&lt; std::endl; 输出运算符（&lt;&lt;) &lt;&lt;运算符接受两个运算对象： 左侧的运算对象必须是一个 ostream 对象， 右侧的运算对象是要打印的值 此运算符返回其左侧的运算对象 将给定的值写到给定的 ostream 对象中 等价于 1(std::cout « &quot;Enter two numbers:&quot; ) &lt;&lt; std::endl; 或者： 12std::cout &lt;&lt; &quot;Enter two numbers:&quot;；std::cout &lt;&lt; std::endl; 字符串字面值常量 “Enter two numbers:” 双引号包围的字符序列 ，双引号之间的文本被打印到标准输出 endl 操纵符（ manipulator); 特殊值 效果是结束当前行， 并将与设备关联的缓冲区 （ buffer) 中的内容刷到设备中 使用标准库中的名字 std::cout 和 std::endl std 的命名空间(namespace) 避免不经意的名字定义冲突 ,以及使用库中相同名字导致的冲突 作用域运算符 (::) 从流读取数据 1std::cin &gt;&gt; vl &gt;&gt; v2; 输入运算符（ &gt;&gt;) 从给定的 istream 读入数据， 并存入给定对象中 返回其左侧运算对象作为其计算结果 等价于 1( std::cin &gt;&gt; vl ) &gt;&gt; v2; 或者 12std::cin &gt;&gt; vl;std::cin &gt;&gt; v2; 1.3 注释简介C++中注释的种类 C++中有两种注释： 单行注释:以双斜线 ( / / ) 开始， 以换行符结束 ;当前行双斜线右侧的所有内容都会被编译器忽略 界定符对注释 继承自 C 语言的两个界定符（ /*和 */ ) 落在/和 /之间的所有内容都当作注释 ; 可以包含除 /外的任意内容， 包括换行符 注释界定符不能嵌套 1.4 控制流1.4.1 while语句 12while {condition)statement 执行过程是交替地检测 condition 条件和执行关联的语句statement ，直到condition为假时停止 小于等于运算符（&lt;=) 复合赋值运算符 （ +=) 前缀递增运算符 （ ++ ) 1.4.2 for语句1234567891011#include &lt;iostream&gt;int main ( ){ int sum / / 从 1加到 10 for (int val = 1; val &lt;= 10; ++val) sum += val; // 等 价 于 + val std::cout &lt;&lt; &quot;Sum of 1 to 10 inclusive is &quot; &lt;&lt; sum &lt;&lt; std::endl; sum += sum = sum return 0;} 1.4.3 读取数量不定的输入数据 使用一个 istream 对象作为条件时 ,其效果是检测流的状态; 流是有效的， 即流未遇到错误， 那么检测成功 遇到文件结束符 ( end-of-file), 或遇到一个无效输入时（ 例如读入的值不是一个整数）， istream 对象的状态会变为无效 如何指出文件结束 Windows 系统 敲 Ctrl+Z ( 按住 Ctrl 键的同时按 Z 键 ），然后按 Enter 或 Return 键 UNIX 系统 /MacOSX 系统 Ctrl+D 再 探 编 译 语法错误（ syntax error ) 类型错误（ type error ) 声明错误（ declaration error ) 按照错误信息报告的顺序来逐个修正错误， 是一种好习惯 。因为单个错误常常会具有传递效应 ， 导致编译器在其后报告比实际数量多得多的错误信息。 另一个好习惯是在每修正一个错误后就立即重新编译代码， 或者最多是修正了一小部分明显的错误后就重新编译 ： 这就是所谓的 “编辑-编译-调试 ”（ edit-compile-debug ) 周期。 1.4.4 if语句 相等运算符（ ==) C++用=进行赋值， 用==作为相等运算符；两个运算符都可以出现在条件中 。一个常见的错误是想在条件中使用== ( 相等判断 ）， 却误用了= 。 1.5 类简介 类机制是 C++最重要的特性之一 一个类定义了一个类型， 以及与其关联的一组操作 通过定义一个类 (class) 来定义自己的数据结构 使用头文件来访问为自己的应用程序所定义的类 通常使用.h 作为头文件的后缀 一些程序员习惯.H、 .hpp 或.hxx 标准库头文件通常不带后缀 类的作者决定了类类型对象上可以使用的所有操作 1.5.1 Sales_item类1Sales_item item; 表达 item 是一个 Sales_item 类型的对象。 我们通常将“ 一个 Sales_item 类型的对象” 简单说成“ 一个 Sales_item 对象”， 或更简单的“ 一个 Sales_item”。 读写Sales_item 头文件 来自标准库的头文件 ：应该用尖括号（&lt; &gt;) 包围头文件名 1#include &lt;iostream&gt; 不属于标准库的头文件 ：用双引号（ “ “） 包围 1#include &quot;Sales_item.h&quot; Sales_item 对象的加法 对于 Sales_item 对象， 我们用了一个全新的“ 和” 的概念 : 两个 Sales_item 对象的成员对应相加的结果。 使用文件取定向​ 当你测试程序时， 反复从键盘敲入这些销售记录作为程序的输入， 是非常乏味的 。大多数操作系统支持文件重定向， 这种机制允许我们将标准输入和标准输出与命名文件关联起来： 1$ addlterns &lt;infile &gt;outfile 假定$是操作系统提示符， 我们的加法程序已经编译为名为 addltems.exe 的可执行文件（ 在 UNIX 中addltems ). 则上述命令会从一个名为 infile 的文件读取销售记录， 并将输出结果写入到一个名为 outfile 的文件中， 两个文件都位于当前目录中。 1.5.2 初识成员函数 什么是成员函数？ 成员函数是定义为类的一部分的函数， 有时也被称为方法（ method)。 通常以一个类对象的名义来调用成员函数：iteml.isbn ( ) 点运算符（.） 只能用于类类型的对象。 左侧运算对象必须是一个类类型的对象， 右侧运算对象必须是该类型的一个成员名， 运算结果为右侧运算对象指定的成员 调用运算符（（ ） ） 调用运算符是一对圆括号， 里面放置实参( argument) 列表（ 可能为空） 1.6 书店程序 术语表 参数（ 实参， argument ) 向函数传递的值。 赋值 ( assignment) 抹去一个对象的当前值， 用一个新值取代之。 程序块（ block ) 零条或多条语句的序列，用花括号包围。 缓冲区（ buffer ) —个存储区域， 用于保存数据。 IO 设施通常将输入 （ 或输出） 数据保存在一个缓冲区中， 读写缓冲区的动作与程序中的动作是无关的。 我们可以显式地刷新输出缓冲， 以便强制将缓冲区中的数据写入输出设备。 默认情况下， 读 cin会刷新 cout； 程序非正常终止时也会刷新couto 内置类型（ built-in type ) 由语言定义的类型， 如 int. Cerr 一 个 ostream 对象， 关联到标准错误， 通常写入到与标准输出相同的设备。 默认情况下， 写到Cerr的数据是不缓冲的，Cerr通常用于输出错误倍息或其他不屑于程序正常逻辑的输出内容 字 符 串 字 面 值 常 量 （ character string literal) 术语 string literal 的另一种叫法 cin —个 istream 对象， 用来从标准输入读取数据。 类 (class) 一种用于定义自己的数据结构及其相关操作的机制。 类是 C++中最基木的特性之 一。 标准库类型中， 如 istream和ostream 都是类 类 类 型 （ class type ) 类定义的类型。 类名即为类型名 clog 一 个 ostream 对象， 关联到标准错误。 默认情况下， 写到 clog 的数据是被缓冲的。 clog 通常用于报告程序的执行信息. 存入一个日志文件中 注 释（ comment) 被编译器忽略的程序文本。 C++有两种类羽的注释： 单行注释和界定符对注释。 单行注释以/ / 开始， 从 / /到行尾的所有内容都是注释。 界定符对注释以/ * 汗始， 其后的所有内容都萣注释,直至遇到* / 为止。 条 件 ( condition) 求值结果为真或假的表达式。 通常用值 0 表示假， 用非零表示真。 cout 一个 ostream 对象， 用于将数据写入标准输出。 通常用于程序的正常输出内容。 花括号 ( curly brace ) 花括号用于划定程序块边界。 左花括号 ( { ) 为程序块开始，右花括号（ } ) 为结朿。 数据结构 (data structure) 数据及其上所允许的操作的 一种逻辑组合。 编辑-编译-调试 （ edit-compile-debug ) 使程序能正确执行的开发过程 文件结束符 （ end-of-file) 系统特定的标识， 指出文件中无更多数据了。 表达式 （ expression ) 最小的计算单元。 一个表达式包含 一 个或多个运算对象， 通常还含 一个或多个运算符。 表达式求值会产生一个结果。 例如， 假设i和 j 是 int对象， 则i+j 是一个表达式, 它产生两个 int 值的和。 ……","link":"/2022/07/03/C++Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第一节 命名空间的using声明）","text":"命名空间的 using 声明 域操作符（参见 1.2 节， 第 7 页 ）含义：例如std::cin 译器应从操作符左侧名字所示的作用域中寻找右侧那个名字 更简单的方法： using 声明（ using declaration) ，详参18.2.2 节（ 第 702 页） using声明形式： 1using namespace::name; 样例： 每个名字都需要独立的using声明 按照规定， 每个 using 声明引入命名空间中的一个成员 例如： 123456789101112#include &lt;iostream&gt;// 通过下列 using 声明， 我们可以使用标准库中的名字using std::cin;using std::cout; using std::endl;int main ( ){ cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; endl; int vl, v2; cin &gt;&gt; vl &gt;&gt; v2; cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; vl &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot;is&quot; &lt;&lt; vl + v2 &lt;&lt; endl; return 0; } 头文件不应该包含using声明​ 如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明 ，可能产生始料未及的名字冲突 一点注意事项​ 本书后面的程序中不再包含using声明和#include指令，运行本书中后面章节的代码请读者自行补全","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E%EF%BC%89/"},{"title":"Git untracked files","text":"Git untracked files问题场景：当我们使用git status 命令是，有时候会出现一些untracked files,这些文件是没有纳入git代码库监管的文件 文件为什么产生？ 编译生成的一些文件 码农自己新加的一些无用文件或者测试文件，不需要纳入代码库管理 删除 untracked files1git clean -f 解析：仅仅是删掉那些未纳入监管的文件 连 untracked 的目录也一起删掉 场景解析：有的时候会生成一整个目录的未监管文件，包括这个目录都是未监管的 1git clean -fd 连 gitignore 的untrack 文件/目录也一起删掉 慎用，一般这个是用来删掉编译出来的 .o之类的文件用的 1git clean -xfd 删除前必须进行的检查 查看哪些未监管文件将会被删掉 123git clean -nxfdgit clean -nfgit clean -nfd","link":"/2022/07/15/Git-untracked-files/"},{"title":"Linux 命令行学习篇一 shell基础和工具篇","text":"shell什么是shell一句话解释:shell是用户对Linux/Unix操作系统和内核进行操作和管理的工具 Linux/Unix操作系统的核心是内核,内核的主要任务是任务调度、内存管理和硬件控制，而shell是用户与Linux/Unix内核之间的一个沟通的桥梁。 shell发展史 世界上第一款shell叫做Thompson shell，诞生于1971年，1975年开始广泛传播使用。它的一个别名是V6 shell Thompson shell的作者是Thompson,Tompson shell 诞生于他在贝尔实验室工作期间.Thomspon后期开发Unix操作系统. shell种类 名称 全称 诞生于 流行于 sh Bourne Shell 1977 Unix (t)csh C Shell 1978 Unix ksh Kron Shell 1983 Unix bash Bourne Again shell 1989 Linux zsh Zhong Shao Shell 1990 Linux dash Debian Almquist Shell 2002 Linux 也有其他的一些小众的shell,例如pdksh、psh和mksh等。 如何查看当前系统安装的shell（以CentOS为例）cat /etc/shells12345678[root@cnhzldvcmpl67 npti.src]# cat /etc/shells /bin/sh/bin/bash/usr/bin/sh/usr/bin/bash/bin/tcsh/bin/csh[root@cnhzldvcmpl67 npti.src]# 补充命令:如何查看系统版本信息(以CentOS为例) 电脑及操作系统相关信息 123[root@cnhzldvcmpl67 npti.src]# uname -aLinux cnhzldvcmpl67 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux[root@cnhzldvcmpl67 npti.src]# 正在运行的内核版本 123[root@cnhzldvcmpl67 npti.src]# cat /proc/version Linux version 3.10.0-957.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Thu Nov 8 23:39:32 UTC 2018[root@cnhzldvcmpl67 npti.src]# 发行版本信息 12345[root@cnhzldvcmpl67 npti.src]# cat /etc/issue\\SKernel \\r on an \\m[root@cnhzldvcmpl67 npti.src]# 这里有个问题,输出和预期不一致!!! 查看、安装、切换其他类型shell查看当前使用的shell123[root@cnhzldvcmpl67 npti.src]# echo $SHELL/bin/bash[root@cnhzldvcmpl67 npti.src]# 安装(以zsh为例)1234567891011121314151617181920212223242526272829303132333435363738394041[root@cnhzldvcmpl67 npti.src]# yum install zshLoaded plugins: fastestmirror, langpacksDetermining fastest mirrorsECI-base-CentOS-7.6 | 3.6 kB 00:00:00 ECI-puppet6-rhel7 | 2.9 kB 00:00:00 ECI-updates-CentOS-7.4 | 2.9 kB 00:00:00 ECI-updates-CentOS-7.6 | 3.4 kB 00:00:00 Resolving Dependencies--&gt; Running transaction check---&gt; Package zsh.x86_64 0:5.0.2-31.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved======================================================================================================================================================================= Package Arch Version Repository Size=======================================================================================================================================================================Installing: zsh x86_64 5.0.2-31.el7 ECI-base-CentOS-7.6 2.4 MTransaction Summary=======================================================================================================================================================================Install 1 PackageTotal download size: 2.4 MInstalled size: 5.6 MIs this ok [y/d/N]: yDownloading packages:zsh-5.0.2-31.el7.x86_64.rpm | 2.4 MB 00:00:07 Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : zsh-5.0.2-31.el7.x86_64 1/1 Verifying : zsh-5.0.2-31.el7.x86_64 1/1 Installed: zsh.x86_64 0:5.0.2-31.el7 Complete![root@cnhzldvcmpl67 npti.src]# 切换12345678910[root@cnhzldvcmpl67 npti.src]# which zsh/usr/bin/zsh[root@cnhzldvcmpl67 npti.src]# chsh -s /bin//bin/bash /bin/csh /bin/sh /bin/tcsh /bin/zsh [root@cnhzldvcmpl67 npti.src]# chsh -s /bin//bin/bash /bin/csh /bin/sh /bin/tcsh /bin/zsh [root@cnhzldvcmpl67 npti.src]# chsh -s /bin/zsh Changing shell for root.Shell changed.[root@cnhzldvcmpl67 npti.src]# 总结: 应用最广泛的shell是bash; 功能最强大的shell是zsh. 用chsh改变shell利用chsh修改当前使用的shell命令行,具体操作方法见前一章节 那么chsh到底修改了哪里呢? 123456[root@cnhzldvcmpl67 npti.src]# chsh -s /bin/zsh Changing shell for root.Shell changed.[root@cnhzldvcmpl67 npti.src]# cat /etc/passwd |grep &quot;zsh&quot;root:x:0:0:root:/root:/bin/zsh[root@cnhzldvcmpl67 npti.src]# export环境变量export变量输出12345678910111213141516171819202122232425262728[root@cnhzldvcmpl67 npti.src]# exportdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/root&quot;declare -x HOSTNAME=&quot;cnhzldvcmpl67&quot;declare -x LANG=&quot;en_US.UTF-8&quot;declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;declare -x LOGNAME=&quot;panxiyan&quot;declare -x LS_COLORS=&quot;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:&quot;declare -x MAIL=&quot;/var/spool/mail/panxiyan&quot;declare -x MANPATH=&quot;:/opt/puppetlabs/puppet/share/man&quot;declare -x OLDPWDdeclare -x PATH=&quot;/usr/lib64/ccache:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin:/root/bin&quot;declare -x PWD=&quot;/home/panxiyan/npti.src&quot;declare -x SHELL=&quot;/bin/bash&quot;declare -x SHLVL=&quot;2&quot;declare -x SSH_AUTH_SOCK=&quot;/tmp/ssh-Bogi4DVSt6/agent.437&quot;declare -x SSH_CLIENT=&quot;172.18.100.189 59362 22&quot;declare -x SSH_CONNECTION=&quot;172.18.100.189 59362 10.91.90.77 22&quot;declare -x SSH_TTY=&quot;/dev/pts/0&quot;declare -x TERM=&quot;vt100&quot;declare -x USER=&quot;panxiyan&quot;declare -x XDG_DATA_DIRS=&quot;/home/panxiyan/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share&quot;declare -x XDG_RUNTIME_DIR=&quot;/run/user/986&quot;declare -x XDG_SESSION_ID=&quot;44419&quot;declare -x http_proxy=&quot;http://147.234.159.146:3128&quot;declare -x no_proxy=&quot;127.0.0.1,147.234.154.159,alpina,147.234.159.138,globe,ibiza,.ecitele.com,147.234.150.92,.ecicloud.com,147.234.249.0/24,repo,147.234.245.15,ilptlpvdevgit02,ilptlpvdevgit01,cnhzlpvbktmirror01.ecitele.com,ilptltvbbp01.ecitele.com,bitbucketpocmirror1.ecitele.com&quot;[root@cnhzldvcmpl67 npti.src]# export相关命令总结在Linux系统中,除了export之外,还要env、set和declare等三个命令会显示shell中的变量 shell中变量分为环境变量和自定义变量。环境变量可以在当前线程的子线程中生效，而自定义变量的作用范围无法延伸到当前线程的子线程中。 总结： ​ 命令 显示范围 特征 env 环境变量 不显示自定义变量 export 环境变量 输出内容按照变量名称排序 set 环境变量+自定义变量 显示shell中所有的变量 declare 环境变量+自定义变量 输出内容按照变量名称排序 tips：执行set前会执行clear命令,而执行declare前会执行set命令 如何利用export设置shell环境变量$PATH变量内容​ $PATH是Linux中最常用的环境变量,这个变量中的内容如下: 123[root@cnhzldvcmpl67 npti.src]# echo $PATH/usr/lib64/ccache:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin:/root/bin[root@cnhzldvcmpl67 npti.src]# $PATH 的作用​ 当用户在shell命令行中输入一个指令的时候,Linux系统会去$PATH下的路径寻找这个指令,如果找到了,就执行该指令;如果没有找到,就直接退出并显示该指令不存在. 如何使用$PATH变量​ 例如在运维工作中,我们在/home/roc/operation_tools路径下存放了很多的运维小工具,如何在我们使用这些工具的时候避免每次都需要输入这些工具的绝对路径? ​ 办法如下: 1[root@cnhzldvcmpl67 npti.src]# export PATH=$PATH:/home/roc/operation_tools export使用案例和日常避坑​ 当我们向$PATH环境变量中添加新的变量时,一定要注意语法格式,否则会出现什么命令都用不了的现象,如下: 使用案例​ 定义自定义变量var1和var2,然后通过export发布自定义变量var1使之成为环境变量,最后通过bash子进程访问环境变量var1: 12345678910111213141516[root@cnhzldvcmpl67 npti.src]# var1=&quot;hello&quot;[root@cnhzldvcmpl67 npti.src]# echo $var1hello[root@cnhzldvcmpl67 npti.src]# var2=&quot;world'&gt; &quot;[root@cnhzldvcmpl67 npti.src]# echo $var2world'[root@cnhzldvcmpl67 npti.src]# export var1[root@cnhzldvcmpl67 npti.src]# bash[root@cnhzldvcmpl67 npti.src]# echo var1var1[root@cnhzldvcmpl67 npti.src]# echo $var1hello[root@cnhzldvcmpl67 npti.src]# echo $var2[root@cnhzldvcmpl67 npti.src]# 日常避坑​ 下面的写法存在语法错误,但是系统并不会检测出来, 1[root@cnhzldvcmpl67 npti.src]# export PATH=PATH/home/roc/operation_tools ​ 当我们发布上面这个环境变量的时候,由于存在语法错误,它会导致我们的$PATH变量中原来的内容被全部清空. 届时我们连cat命令都无法使用的!!!! read命令详解exper计算器tmux多窗口alias和昵称history命令xargs命令timesleep","link":"/2021/10/11/Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80---shell%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%AF%87/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第三节 标准库类型 vector）","text":"标准库类型 vector重点: 标准库类型 对象的集合,所有对象的类型相同 每个对象都有索引 被称为容器(container) 后续章节均假设已做如下using声明: 12#include &lt;vector&gt;using std::vector C++ 中有类模板和函数模板,vector 是一种类模板 实例化: 编译器根据模板创建类或者函数的过程称之为实例化 对于类模板,需要提供额外信息来指定模板实例化成什么样的类 方式:在模板名字后面跟一对尖括号， 在括号内放上信息。 案例: 引用不是对象,所以不存在包含引用的vector C++新老版本中的一点区别 如果vector的元素还是vector(或者其他的模板类型) 老标准:外层 vector对象的右尖括号和其元素类型之间添加一个空格 1vector&lt;vector&lt;int&gt; &gt; 新标准(C++11) 1vector&lt;vector&lt;int&gt;&gt; 定义和初始化 vector 对象 vector模板控制定义和初始化向量的方法 vector对象之间的拷贝对象的类型必须相同 列表初始化vector对象列表初始化:(参考第2.2.1节 第39页) vector列表初始化案例: C++提供的几种初始化方法:参考2.2.1节第39页 vector初始化时的注意事项: 使用拷贝初始化时(=)(参考3.2.1节第76页),只能提供一个值 如果提供的是类内初始值(参考2.6.1节第64页),则只能使用拷贝初始化或者使用花括号的形式初始化 如果提供的是初识元素值的列表,必须使用花括号而不能使用圆括号 实例: 创建指定数量元素 值初始化 只提供 vector 对象容纳的元素数量而不用略去初始值 库会创建一个值初始化的（ value-initialized) 元素初值， 并把它赋给容器中的所有元素 初值由 vector 对象中元素的类型决定 实例: 特殊情况 有些类要求必须明确地提供初始值 ,参见2.2.1节第40页 只提供了元素的数量而没有设定初始值,只能使用直接初始化 解析:这里的10是用来说明如何初始化vector对象的,本意是创建含有10个值初始化了的元素的vector对象 实际上,这里是把10拷贝到了vector对象中,因此这里不适宜用拷贝初始化,更多内容参考7.5.4节第265页 列表初始值还是元素数量通过使用花括号或圆括号可以区分 总结: 圆括号， 可以说提供的值是用来构造（ construct) vector 对象的。 例如v1和v2 花括号， 可以表述成我们想列表初始化 ( list initialize) 该 vector 对象。 例如上例中， 给 v2 和 v4 无法执行列表初始化时才会考虑其他初始化方式; 如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象了例如: 要想列表初始化 vector 对象， 花括号里的值必须与元素类型相间 ;确认无法执行列表初始化后， 编译器会尝试用默认值初始化 vector 对象。 向 vector 对象中添加元素 直接初始化适用的三种情况 初始值已知且数量较少 初始值是另一个 vector 对象的副本 所有元素的初始值都一样 问题情景: 不清楚vector对象元素个数 vector对象元素的值不清楚 vector对象的元素个数多而且各不相同 解决办法: 先创建一个空 vector ,在运行时再利用push_back 向其中添加元素 解析push_back 把一个值当成 vector 对象的尾元素“ 压到（ push)” vector 对象的“ 尾端 （ back )” 案例1: 案例2:读入数值然后将其赋予vector对象: 关键概念:vector对象能高效增长在定义vector对象时不要设定其大小 向vector对象添加元素蕴含的编程假定 如果循环体内部包含有向 vector 对象添加元素的语句， 则不能使用范围 for 循环 ,详细解释参见5.4.3节第168页 范围 for 语句体内不应改变其所遍历序列的大小。 其他 vector 操作 vector支持的其他操作 访问vector对象元素和string的类似 案例 123456vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9}for(auto &amp;i : v) //对于v中的每个元素(注意:i是一个引用,这样就可以通过i来修改v中元素的值) i *= i; //求元素值的平方for(auto i : v) //对于v中的每个元素 cout&lt;&lt;i&lt;&lt;&quot; &quot;; //输出该元素cout&lt;&lt;endl; vector 的 empty 和 size 两个成员与 string 的同名成员(3.2.2 节， 第 78页 )功能完全一致 empty 检查 vector 对象是否包含元素然后返回一个布尔值 size则返回 vector 对象中元素的个数， 返回值的类型是由 vector 定义的 size_type 类型 Note:要使用 size_type, 需首先指定它是由哪种类型定义的 案例: 12vector&lt;int&gt;::size_type //正确vector::size_type //错误 相等性运算符和关系运算符也与string的类似(3.2.2节第79页) 相等:大小,元素位置,元素值 关系运算符:比较规则参考string的 只有当元素可以比较时,vector对象才能被比较例如:不能比较两个 vector&lt;Sales item〉对象 计算 vector 内对象的索引 vector对象的下标也是从0开始 下标的类型是相应的 size_type 类型 只要vector 对象不是一个常量， 就能向下标运算符返回的元素赋值 样例: 不能用下标形式添加元素 错误案例 123vector&lt;int&gt; ivec; // 空 vector 对象for (decltype (ivec.size ()) ix = 0; ix != 10; ++ix) ivec[ix] = ix;//严重错误:ivec不包含任何元素 解析:ivec 是一个空 vector, 根本不包含任何兀素， 当然也就不能通过下标去访问任何元素！ 如前所述， 正确的方法是使用 push_back: 正解: 12for(decltype(ivec.size()) ix = 0;ix != 10; ++ix ) ivec.push_back(ix); 解析:下标仅能用来访问已经存在的元素,不可用于添加元素 下标操作的一点总结 只能对确知已存在的元素执行下标操作 错误案例: 12345vector&lt;int&gt; ivec; //空vector对象cout &lt;&lt; ivec [0]; //错误:ivec不包含任何元素vector&lt;int&gt; ivec2(10); //含有10个元素的vector对象cout&lt;&lt; ivec2[10]; //错误:ivec2的合法下标是0到9 错误案例总结: 通过下标访问一个不存在的元素将导致错误,但是编译器不能发现这种错误 他会在运行时产生一个不可预知的值 这类错误被称为缓冲区溢出(buffer overflow); 确保下标合法 的有效手段是使用范围for语句","link":"/2022/07/09/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%B8%89%E8%8A%82%20%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-vector%EF%BC%89/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第二节 标准库类型string）","text":"标准库类型 string 注意事项：需包含以下代码： 12#include &lt;string&gt;using std::string; 关于string的更多内容请阅读9.5 节（ 第 320 页） 定义和初始化 string 对象 初始化string对象的方法 样例： 直接初始化和拷贝初始化 直接初始化不使用“=” 拷贝初始化使用“=”初始化变量 样例 特殊情况 ​ 用多个值进行初始化时如果非要用拷贝初始化的方式来进行， ​ 表面过程：​ ​ 实际过程： ​ string 对象上的操作 string上操作： 读写string对象​ 使用IO操作符读写string对象： ​ string对象读写规则 读规则： 忽略开头的空白（ 即空格符、 换行符、 制表符等）； 从第一个真正的字符开始读起 ； 遇到下一个空白时结束读入 写规则： 返回运算符左侧的运算对象作为结果 总结： 多个输入和输出可以连写到一起 案例： 如果程序输入“ Hello world! ”;输出将会是”Hello” 代码案例 123string s1, s2;cin &gt;&gt; s1 &gt;&gt; s2;// 把第一个输入读到 s1 中， 第二个输入读到 s2 中cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;// 输 出 两 个 string 对 象 输入是“ Hello world! ”;输出是”HelloWorld!” 读取未知数量的string对象​ 参照1.4.3节 第13页读入未知数量的整数 ​ 使用getline读取一整行​ 若想保留输入时的空白符,则需要用getline函数代替”&gt;&gt;”; 参数: 一个输入流+一个string对象 读入规则: 从给定的流中读入内容 遇到换行符结束(换行符也读进来) 将读入的内容存入到string对象中(不存换行符) 如果输入一开始就是换行符则立马结束读入,所得的结果是空string 案例: 备注:出发getline函数返回(结束读入)的换行符其实被丢掉了,得到的string对象并不包含改换行符 string的empty和size操作 empty函数 结合点操作符使用: string对象.empty() 根据string对象是否为空返回一个bool值,参照2.1 第30页 案例: size函数 返回string对象的长度(字符的个数) 案例:输出长度超过80个字符的行: string::size_type类型 string类的几种配套类型之一;其他大多数标准库类型也有这种配套类型 体现了标准库类型和机器无关的特性 足以放下任何string对象的大小 是一个unsigned值 通过auto或者decltype来推测变量类型 size函数返回的是一个无符号整型数 避坑: 禁止表达式中混用无符号数和有符号数假设 n是一个有符号数,则 s.size()&lt;n则几乎肯定为true,因为负值n会自动的转换成一个比较大的无符号数 比较string对象 比较字符串的运算符会逐一比较string对象中的字符,且大小写敏感 相等性运算符(== 和!=) 检验两个string对象是否相等 相等:长度和包含的字符完全相同 关系性运算符(&lt;,&lt;=,&gt;,&gt;=),这些运算符依照大小写敏感的字典顺序: 两个string对象长度不同:且较短的对象的字符和较长的一样,则较短string对象&lt;较长string对象 两个string对象在某些对应位置上不一致,则比较结果是string对象中第一对相异字符的比较结果 案例: 比较结果:str &lt; phraseslang&gt; strslang&gt; phrase 为string对象赋值对于 string 类而言， 允许把一个对象的值赋给另外一个对象: 两个string对象相加两个string对象相加得到新的string对象 字面值和string对象相加 字面值和string对象相加会转换拼接成新的string对象 当string对象和字符字面值以及字符串字面值混在一条语句中使用时,至少确保每个”+”两侧的运算对象有一个是string: 因为某些历史原因,字符串字面值并不是标准库类型中的string对象. 切记:字符串字面值和string对象是不同的类型 处理 string 对象中的字符问题场景: string 对象是否包含空白 把 string 对象中的字母改成小写 査看某个特定的字符是否出现 工具:cctype 头文件 建议:使用C++版的c标准库头文件 处理每个字符?使用基于范围的for语句C++11新标准提供的一种语句: 范围 for (range for) 语句 语法: 案例1: 使用范围 for 语句把 string 对象中的字符每行一个输出出来： 案例2:使用范围 for 语句和 ispunct 函数来统计 string 对象中标点符号的个数 解析: 1,关于punct_cnt的类型(string::size_type ),参考 2.5.3节 第62页 使用范围for语句改变字符串中的字符 关键点: 要改变 string 对象中字符的值， 必须把循环变量定义成引用类型(参考2.3.1节 第45页) 使用标准库函数 toupper () 案例: 只处理一部分字符? 问题情景:只访问修改string对象中的部分字符 解决办法 使用下标 使用迭代器(参考3.4节 第95页) 使用下标访问string对象部分字符 下标运算符（ [ ] ) 输入参数是 string::size_type 类型的值(第3.2.2节 第79页)， 参数表示要访问的字符的位置 返回值I该位置上字符的引用 string 对象的下标从 0 计起;s [ 0 ] 是第1个字符,s[1]是第2个字符,s [ s.size () -1] 是最后一个字符 string 对象的下标必须大于等于 0 而小于 s.size ( ); 使用下标访问空 string 也会引发不可预知的结果。 案例1:下标运算符输出 string 对象中的第一个字符 案例2:将字符串的首字符改成了大写形式 总结: 只要string对象不是常量,就可以通过下标访问string对象中的字符方式来对其进行修改 使用下标进行迭代 输出结果是: SOME string 知识拓展: 逻辑与运算符 &amp;&amp; 注意检查下标的合法性 下标必须是大于等于 0 而小于字符串的 size()的 值 解决办法: 设 下 标 的 类 型 为string::size_type, 因为此类型是无符号数， 可以确保下标不会小于 0 代码作者还需自行保证下标小于size(); 使用下表执行随机访问案例:把 0 到 15 之间的十进制数转换成对应的十六进制形式 123456789101112131415const string hexdigits = &quot;0123456789ABCDEF&quot;; // 可能的十六进制数字cout &lt;&lt; &quot;Enter a series of numbers between 0 and 15&quot; &lt;&lt; &quot;separated by spaces. Hit ENTER when finished: &quot; &lt;&lt; endl;string result; //用于保存十六进制数string::size_type n;while(cin&gt;&gt;n){ if(n&lt;hexdigits.size()) { result += hexdigits[n]; } }cout&lt;&lt;&quot;Your Hex number is :&quot;&lt;&lt; result &lt;&lt; endl; 加入输入如下: ​ 12 0 5 15 8 15 程序的输出结果将是: ​ Your hex number is: C05F8F","link":"/2022/07/07/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring%EF%BC%89/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第四节 迭代器介绍）","text":"迭代器介绍 迭代器的作用 和下表类似，用来访问标准容器中的元素，例如vector 注意：string并不属于容器类型，只不过很多容器类型支持的操作string也支持而已 迭代器的有效无效之分： 有效：指向容器中的某个元素或者容器尾元素的下一位置 无效：除有效情况之外，迭代器指向其他位置均为无效 和指针类似 提供了对对象的间接访问 读者问题： 为啥不对迭代器下一个定义？？？ 使用迭代器 获取迭代器 不是使用取地址符 ，有迭代器的类型同时拥有返回迭代器的成员 begin 成员负责返回指向第一个元素（ 或第一个字符） 的迭代器 该迭代器指示的是容器的一个本不存在的“ 尾后（offtheend)”元素。 这样的迭代器没什么实际含义， 仅是个标记而已， 表示我们已经处理完了容器中的所有元素。 end 成员返回的迭代器常被称作尾后迭代器（ off-the-end iterator ) 或者简称为尾迭代器 ( end iterator ) 容器为空， 则 begin 和 end 返回的是同一个迭代器；都是尾后迭代器。 迭代器运算符 案例：利用迭代器把 string 对象的第一个字母改为了大写形式 123456string s (&quot;some string&quot; };if (s.begin () != s.end()) // 确保 s 非空{ auto it = s.begin ();// it 表示 s 的第一个字符 it = toupper (*it); // 将当前字符改成大写形式 } 将迭代器从一个元素移动到另外一个元素注意一个说法：是容器对象的迭代器 迭代器使用递增 (++) 运算符1.4.1节第11页 来从一个元素移动到下一个元素 因为 end 返回的迭代器并不实际指示某个元素， 所以不能对其进行递增或解引用的操作 案例：利用迭代器和迭代器的递增运算符把 string 对象中第一个单词改写为大写形式 迭代器类型一般是不知道也无需知道迭代器的类型的,就像不知道 string 和 vector 的 size_type 成员（参见 3.2.2 节， 第 79 页） 到底 是什么类型一样 ; 拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型: begin和end运算符 begin 和 end 返回的具体类型由对象是否是常量决定 对象是常量 返回 const_iterator 否则返回iterator; 案例: 1234vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin();// itl 的类型是 vector&lt;int&gt;::iteratorauto it2 = cv.begin();// it2 的类型是 vector&lt;int&gt;::const_iterator C++11 新标准cbegin和 cend 不管对象是否常量,返回的都是const_iterator; 使用场景:对象只需读操作而无须写操作 结合解引用和成员访问操作 解引用迭代器可获得迭代器所指的对象; 案例: 箭头运算符（ -&gt;) 把解引用和成员访问两个操作结合在一起 解析:it-&gt;mem 和（*it) .mem 表达的意思相同 案例: 名为 text 的字符串向量存放文本文件中的数据 某些对 vector 对象的操作会使迭代器失效 某些对 vector 对象的操作会使迭代器失效 不能在范围 for 循环中向 vector 对象添加元素 任何一种可能改变 vector 对象容量的操作， 比如 push_back, 都 会 使 该vector 对象的迭代器失效 (参见9.3.6节第315页) 但凡是使用了迭代器的循环体， 都不要向迭代器所属的容器添加元素 迭代器运算 所有的标准库容器都有支持递增运算的迭代器 细节由表 3.7 列出 迭代器的算术运算 如果 vi 有 20 个元素， vi.size() /2 得 10, 此例中即令 mid 等于 vi.begin( ) +10。已知下标从 0 开始， 则迭代器所指的元素是 vi[10]; 对于 string 或 vector 的迭代器(参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（ 或者尾元素的下一位置）) 使用关系运算符(&lt;、&lt;=、 &gt;、 &gt;=) 对其进行比较 ; 来比较它们所指的位置孰前孰后 其相减， 所得结果是两个迭代器的距离 右侧的迭代器向前移动多少位置就能追上左侧的迭代器， 其类型是名为 difference_type 的带符号整型数 这 个 距 离 可 正 可 负 ， 所 以difference_type 是带符号类型的。 使用迭代器运算 经典算法 二分搜索 案例: 解析: 如何设置两个循环终止条件? 如何在循环内部重新设置中间位置和结束位置?","link":"/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D%EF%BC%89/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第六节 多维数组）","text":"多维数组 严格来讲,C++中没有多维数组;所谓多维数组不过是数组的数组而已 多维数组的两个维度 一个维度表示数组本身大小， 另外 -个维度表示其元素（ 也是数组） 大小： 案例: 多维数组的初始化 允许使用花括号括起来的一组值初始化多维数组 案例: 案例拓展: 允许部分初始化多维数组的元素 案例: 其他未列出的元素执行默认值初始化 在这种情况下如果再省略掉内层的花括号， 结果就大不一样了 案例: 初始化的是第一行的 4 个元素， 其他元素被初始化为 0 多维数组下标的引用 使用下标运算符来访问多维数组的元素， 此时数组的每个维度对应一个下标运算符 案例1： 案例2：两层嵌套的 for 循环来处理多维数组的元素 用范围 for 语句处理多维数组 C++11 新标准中新增了范围 for 语句 ，上面的代码简化如下 案例： 两个比较的案例 正确的例子: 错误的例子： 解析; 总结： 指针和多维数组 当程序使用多维数组的名字时， 也会自动将其转换成指向数组首元素的指针 定义指向多维数组的指针时， 千万别忘了这个多维数组实际上是数组的数组. 多维数组名转换得来的指针实际上是指向第一个内层数组的指针 案例; 解析;首先明确（*P) 意味着 p 是一个指针。 接着观察右边发现， 指针 p 所指的是一个维度为 4 的数组； 再观察左边知道， 数组中的元素是整数。 因此， p 就是指向含有 4 个整数的数组的指针。 特别注意; C++11 新标准 使用 auto 或者 decltype 案例：尽可能地避免在数组前面加上一个指针类型 标准库函数 begin 和 end 简化 案例： 类型别名简化多维数组的指针","link":"/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第三节 复合类型）","text":"复合类型 基于其他类型定义的类型 本章将介绍其中的两种： 引用和指针 声明语句 :基本数据类型（ base type) + 声明符( declarator) 列表 引用 概念：对象起了另外一个名字 引用类型引用（ refers to) 另外一种类型 ？（这话什么意思?） 如何定义：将声明符写成 &amp;d 的形式 123int ival = 1024;int &amp;refVal = ival； // refVal 指向 ival ( 是 ival 的另一个名字 ）int &amp;refVal； // 报错： 引用必须被初始化 引用的实质： 定义引用时， 程序把引用和它的初始值绑定（ bind) 在一起， 而不是将初始值拷贝给引用。 定义初始化引用和定义变量的区别：在初始化变量时， 初始值会被拷贝到新建的对象中； 一旦初始化完成， 引用将和它的初始值对象一直绑定在一起。 因为无法令引用重新绑定到另外一个对象， 因此引用必须初始化。 引用并非对象， 相反的， 它只是为一个已经存在的对象所起的另外一个名字 定义了一个引用之后， 对其进行的所有操作都是在与之绑定的对象上进行的： 123456refVal = 2;// 把 2 賦给 refVal 指向的对象 ， 此处即是賦给了 ivalint ii = refVal; // 与ii = ival 执行结果一样//正确： refVal3 绑定到了那个与 refVal 绑定的对象上， 这里就是绑定到 ival 上int &amp;refVal3 = refVal;// 利 用 与 refVal 绑定的对象的值初始化变量iint i = refVal; // 正确： i被初始化为 ival 的值 引用的定义 允许在一条语句中定义多个引用， 其中每个引用标识符都必须以符号 &amp;开头 1234int i = 1024,i2 = 2048; //i和i2 都是 intint &amp;r =i, r2 =i2;// r 是一个引用， 与i绑定在一起， r2 是 intint i3 = 1024, &amp;ri =i3; //i3 是 int, ri是一个引用， 与i3 绑定在一起int &amp;r3 = i3, &amp;r4 =i2; // r3 和 r4 都是引用 所有引用的类型都要和与之绑定的对象严格匹配 ；（ 2.4.1节 、 15.2.3节将会介绍两种特殊情况） 引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起 （2.4.1 节详述 ） 123int &amp;refVal4 = 10; // 错误： 引用类型的初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; // 错误： 此处引用类型的初始值必须是 int 型对象 指针 定义：“ 指向（ point to)” 另外一种类型的复合类型 作用：实现了对其他对象的间接访问 指针和引用的区别： 指针本身就是一个对象， 允许对指针赋值和拷贝 在指针的生命周期内它可以先后指向几个不同的对象 指针无须在定义时赋初值 块作用域内定义的指针如果没有被初始化， 也将拥有一个不确定的值，这和和其他内置类型一样 定义指针类型的方法 将声明符写成*d 的形式 样例 12int *ipl，*ip2； // ipl 和ip2 都是指向 int 型对象的指针double dp，*dp2; // dp2 是指向 double 型对象的指针， dp 是 double 型对象 获取对象的地址 方法：取地址符（ 操作符 &amp; ): 作用：指针存放某个对象的地址， &amp;获取该地址， 样例 12int ival = 42;int *p = &amp;ival; // p 存放变量 ival 的地址， 或者说p 是指向变量 ival 的指针 注意事项： 引用不是对象， 没有实际地址， 所以不能定义指向引用的指针 所有指针的类型都要和它所指向的对象严格匹配（2.4.2节，15.2.3 节 将介绍两种例外情况） 12345double dval;double *pd = &amp;dval；// 正确： 初始值是 double 型对象的地址double *pd2 = pd；// 正确： 初始值是指向 double 对象的指针int *pi = pd；// 错误： 指针 pi 的类型和 pd 的类型不匹配pi = &amp;dval；// 错误： 试图把 double 型对象的地址赋给 int 型指针 指针值指针的值（ 即地址） 应属下列 4 种状态之一: 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针， 意味着指针没有指向任何对象 无效指针， 也就是上述情况之外的其他值 注意事项： 试图拷贝或以其他方式访问无效指针的值都将引发错误（编译器不检查此类错误） 第 2 种和第 3 种形式的指针是有效的， 但其使用同样受到限制 ；这些指针没有指向任何具体对象， 所以试图访问此类指针（ 假定的） 对象的行为不被允许。 利用指针访问对象 如果指针指向了一个对象， 则允许使用解引用符（ 操作符* ) 来访问该对象: 123int ival = 42;int *p = &amp;ival;// p 存放着变量ival的地址， 或者说p 是指向变量ival的指针cout &lt;&lt; *p;// 由符号*得到指针 p 所指的对象， 输出 42 对指针解引用会得出所指的对象 ;因此如果给解引用的结果赋值， 实际上也就是给指针所指的对象赋值： 123*p = 0;// 由符号 *得到指针 p 所指的对象， 即可经由 p 为变量 ival 賦值cout &lt;&lt; *p； //输出0cout &lt;&lt; ival； //输出0 解引用操作仅适用于那些确实指向了某个对象的有效指针 重点符号解析 空指针 空指针 （null pointer ) ：不指向任何对象 生成空指针的样例： 注意事项： 在试图使用一个指针之前代码可以首先检查它是否为空 拓展知识 预处理变量（preprocessor variable) ：NULL 给指针赋值， 这个变量在头文件 cstdlib 中定义， 它的值就是 0 预处理器 （2.6.3 节） ：是运行于编译过程之前的一段程序 预处理变量不属于命名空间 std 由预处理器负责管理 关于给指针变量赋空指针的建议： 最好使用 nullptr,同时尽量避免使用 NULL. 把 int 变量直接陚给指针是错误的操作， 即使 int 变量的值恰好等于 0 也不行。 建议： 初始化所有指针 赋值和指针 指针和引用的区别： 指针，指针和他指向的对象之间的对应关系可以修改，也就是说，指针可以修改 引用，并不是一个对象，引用一旦确定是无法修改的 一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值 赋值永远改变的是等号左侧的对象 1234pi = &amp;ival;// pi 的值被改变， 现在 pi 指向了 ival*pi = 0;// ival 的值被改变， 指针pi 并没有改变, //*Pi( 也就是指针pi 指向的那个对象） 发生改变。 其他指针操作更过内容参见 3.5.3节 只要指针拥有一个合法值， 就能将它用在条件表达式中。 和采用算术值作为条件（ 2.1.2 节， 第 32 页 ） 遵循的规则类似， 如果指针的值是 0, 条件取 false: 指针比较的注意事项： 两个类型相同的合法指针， 可以用相等操作符（=) 或不相等操作符（!=) 来比较它们， 比较的结果是布尔类型 两个指针存放的地址值相同， 则它们相等： 反之它们不相等。 必须使用合法指针， 使用非法指针作为条件或进行比较都会引发不可预计的后果。 void* 指针特殊的指针类型， 可用于存放任意对象的地址 void* 指针 的作用 和别的指针比较 作为函数的输入或输出 赋给另外一个 void*指针 void*不能做的事情 不能直接操作 void*指针所指的对象， 因为我们并不知道这个对象到底是什么类型， 也就无法确定能在这个对象上做哪些操作 详情参见19.1.1 节（ 第 726 页） 获取 void*指针所存地址的方法4.11.3 节（ 第 144页） 理解复合类型的声明 变量的定义包括 ：一个基本数据类型 （ base type) 和一组声明符 基本数据类型只有一个， 但是声明符的形式却可以不冋 一条定义语句可能定义出不同类型的变量 很多程序员容易迷惑于基本数据类型和类型修饰符的关系， 其实后者（类修饰符）不过是声明符的一部分罢了。（读者问：为什么这么说？） 定义多个变量 场景误区1： 在定义语句中， 类型修饰符（ 或 &amp; ) 作用于本次定义的全部变量 。样例如下： 基本数据类型是 int 而非 int* ; *仅仅是修饰了 p 而已， 对该声明语句中的其他变量， 它并不产生任何作用： 涉及指针（*）和引用（&amp;）的两种良好书写方式： 把修饰符和变量标识符写在一起着重强调变量具有的复合类型 把修饰符和类型名写在一起， 并且每条语句只定义一个变量着重强调本次声明定义了一种复合类型 指向指针的指针 声明符中修饰符的个数并没有限制 多个修饰符连写在一起时， 按照 其逻辑关系详加解释即可 样例： 指针是内存中的对象， 像其他对象一样也有自己的地址， 因此允许把指针的地址再存放到另一个指针当中。这就是指向指针的指针 . 指向指针的引用 引用本身不是一个对象， 因此不能定义指向引用的指针。 但指针是对象， 所以存在对指针的引用 。 解读方式：int *&amp;r = p; 1.最简单的办法是从右向左阅读 r 的定义 2.离变量名最近的符号（ 此例中是&amp;r 的符号&amp; ) 对变量的类型有最直接的影响， 因此 r 是一个引用。 3.声明符的其余部分用以确定 r 引用的类型是什么， 此例中的符号* 说明 r 引用的是一个指针。 4.最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第一节 基本内置类型）","text":"基本内置类型 包括算术类型（ arithmetic type ) 和空类型（ void) 算术类型 整型（ integral type， 包括字符和布尔类型在内） 浮点型 算术类型的取值范围 扩展字符集 wchar_t, char16_t、 char32_t 用于确保可以存放机器最大扩展字符集士的任意一个字符 char16_t 和char32_t 则为 Unicode 字符集服务 (Unicode 是用于表示所有自然语言中字符的标准) 大小关系：short &lt;= int &lt;= long &lt;= long long; 计算机内存单位转换 寻址的最小内存块称为“ 字节（ byte ) ，一般一个字节由8比特组成 存储的基本单元称为 ‘‘ 字（ word )”， 它通常由几个字节组成 字则由 32 或 64 比特构成， 也就是 4 或 8 字节 带符号类型和无符号类型 除去布尔型和扩展的字符型之外， 其他整型可以划分为带符号的（ signed) 和无符号的（ unsigned) 两种 带符号类型可以表示正数、 负数或 0 无符号类型则仅能表示大于等于 0 的值。 字符型 char、 signed char 和 unsigned char 类型 char 和类型 signed char 并不一样 尽管字符型有三种， 但是字符的表现形式却只有两种： 带符号的和无符号的。 类型 char 实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定 数据类型选择准则 数值不可能为负时， 选用无符号类型 int 执行整数运算（short 常常显得太小 ） 整数运算的数值超过了int 的表示范围， 选用 long long（long 一般和 int有一样的尺寸） 算术表达式中不要使用 char 或 bool 类型 char 在一些机器上是有符号， 而在另一些机器上又是无符号，行运算特别容易出问题 ； 如果你需要使用一个不大的整数，明确指定它的类型是 signed char 或者 unsigned char 执行浮点数运算选用 double, 这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几 long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视 。 类型转换​ 将对象从一种给定的类型转换 ( convert) 为另一种相关类型 。 123456bool b = 42; // b 为真int i = b; // i的值为 1i = 3.14; // i的值为 3double pi = i; // pi 的值为 3.0unsigned char c = -1; // 假设 char 占 8 比特， c 的值为 255signed char c2 = 256; // 假设 char 占 8 比特， c2 的值是未定义的 非布尔类型 &gt; 布尔类型 : 初始值为 0 则结果为 false,否则结果为 true 布尔值 &gt; 非布尔类型 : 初始值为 false 则结果为 0, 初始值为true 则结果为 1 浮点数 &gt;整数类型 : 值仅保留浮点数中小数点之前的部分。 整数 &gt; 浮点类型 : 整数部分不变，小数部分记为0；如果该整数所占的空间超过了浮点类型的容量， 精度可能有损失 值 &gt; 无符号类型 : 初始值对无符号类型表示数值总数取模后的余数 ; 值 &gt; 带符号类型： 结果未定义；程序可能继续工作、可能崩溃，也可能生成垃圾数据 字面值常量整型和浮点型字面值 整型: 以 0 开头的整数代表八进制数， 以 0x 或 0X 开头的代表十六进制数 整型字面值具体的数据类型由它的值和符号决定 默认情况下， 十进制字面值是带符号数,八进制和十六进制字面值既可能是带符号的也可能是无符号的 ; 十进制字面值的类型是int、 long 和 long long 中尺寸最小的那个（例如， 三者当中最小是int), 当然前提是这种类型要能容纳下当前的值 八进制和十六进制字面值的类型是能容纳其数值的int、 unsignedint、 long、 unsigned long、 longlong 和 unsigned long long中的尺寸最小者 如果一个字面值连与之关联的最大的数据类型都放不下， 将产生错误 ; 字符和字符串字面值 字符字面值：单引号，单个字符 字符串字面值：双引号，零个或者多个字符 常量字符构成的数组 ( array ) 编译器在每个字符串的结尾处添加一个空字符（ ‘\\0’) ; 字面值’ A’ 表示的就是单独的字符 A, 而字符串”A”则代表了一个字符的数组， 该数组包含两个字符： 一个是字母 A、 另一个是空字符; 分行书写字符串： 转义序列 程序员不可使用的两类字符： 不可打印字符：退格或其他控制字符，因为他们没有可视的图符 转义序列： 泛化的转义序列 \\x 后紧跟 1 个或多个十六进制数字 \\后紧跟 1 个、 2 个或 3 个八进制数字 数字部分表示的是字符对应的数值 以Latin-1 字符集 实例： 12std::cout &lt;&lt; &quot;Hi \\x4dO\\115!\\n&quot;; // 输出 Hi MOM!, 转到新一行std::cout &lt;&lt; '\\115'&lt;&lt; '\\n'; //输出 M, 转到新一行 注意： 反斜线\\后面跟着的八进制数字超过 3 个， 只有前 3 个数字与\\构成转义序列例如， “\\1234”表示 2 个字符， 即八进制数 123 对应的字符以及字符 4。 \\x要用到后面跟着的所有数字， 例如， “\\x1234” 表示一个 16 位的字符， 该字符由这 4 个十六进制数所对应的比特唯一确定。 读者不理解的地方： 因为大多数机器的 char 型数据占 8 位， 所以上面这个例子可能会报错。 一般来说， 超过 8 位的十六进制字符都是与表 2.2 中某个前缀作为开头的扩展字符集一起使用的。 指定字面值的类型​ 通过添加如表 2.2 中所列的前缀和后缀， 可以改变整型、 浮点型和字符型字面值的默认类型。 实例： 布尔字面值和指针字面值 布尔字面值 true 和 false 是布尔类型的字面值 指针字面值 nullptr 是指针字面值， 2.3.2 节（ 第 47 页） 将有更多关丁•指针和指针字面值的介绍","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第二节 变量）","text":"变量 具名的、 可供程序操作的存储空间； 每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、 该空间能存储的值的范围， 以及变量能参与的运算。 变量定义基本形式 首先是类型说明符 （ type specifier), 随后紧跟由一个或多个变量名组成的列表， 其中变量名以逗号分隔， 最后以分号结束； 列表中每个变量名的类型都由类型说明符指定， 定义时还可以为一个或多个变量赋初值 1234567int sum = 0, value, units_sold = 0； // sum、 value 和 units_sold 都是 int //units_sold 初值为 0Sales_item item； // item的类型是Sales_item(参见1.5.1节，第17页 ）//string是一种库类型,表示一个可变长的字符序列std::string book(&quot;0-201-78345-X&quot; )；//book通过一个string字面值初始化 对象初识：一块能存储数据并具有某种类型的内存空间 。 初始值当对象在创建时获得了一个特定的值， 我们说这个对象被初始化 （ initialized) 了。 于初始化变量的值可以是任意复杂的表达式 ； 当一次定义了两个或多个变量时， 对象的名字随着定义也就马上可以使用了 1234/ / 正确： price 先被定义并賦值， 随后被用于初始化 discountdouble price = 109.99, discount = price * 0.16;/ /正确： 调用函数 applyDiscount， 然后用函数的返回值初始化 salePricedouble salePrice applyDiscount (price, discount ); 初始化是一个异常复杂的问题 ；很多程序序员对于用等号=来初始化变量的方式倍感闲惑， 这种方式容易让人认为初始化足赋值的一种 初始化和赋值是两个完全不同的操作 在很多编程语言中，二者的区别几乎可以忽略不计 初始化不是賦值， 初始化的含义是创建变量时賦予其一个初始值， 而赋值的含义是把对象的当前值擦除， 而以一个新值来替代 列表初始化 C++11 新标准的一部分 ```c++int units_sold = 0；int units_sold = {0}；//列表初始化int units_sold{0}；//列表初始化int units_sold(0)； 12345678910- 无论是初始化对象还是某些时候为对象赋新值， 都可以使用这样一组由花括号括起来的初始值了。- 当用于内置类型的变量时， 这种初始化形式有一个重要特点： 如果我们使用列表初始化初始值存在丢失信息的风险， 则编译器将报错： ```c++ long double Id = 3.1415926536； int a{ld}, b = {Id}； //错误： 转换未执行， 因为存在去失信息的危险 int c(Id), d = Id； //正确 ： 转换执行， 且确实丢失了部分值 默认初始化 定义变量时没有指定初值， 则变量被默认初始化 （ default initialized ) 变量类型和定义变量的位置也会对此有影响。 内置类型的变量未被显式初始化， 它的值由定义的位置决定 定义于任何函数体之外的变量被初始化为 0 定义在函数体内部的内置类型变量将不被初始化（ uninitialized)。 未被初始化的内置类型变量的值是未定义的 试图拷贝或以其他形式访问此类值将引发错误。 变量声明和定义的关系分离式编译 目的：为了允许把程序拆分成多个逻辑部分来编写 形式：允许将程序分割为若干个文件， 每个文件可被独立编译 要求：需要有在文件间共享代码的方法 例如：一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是 std::cout 和 std::cin,它们定义于标准库， 却能被我们写的程序使用。 C++的支持模式：声明和定义分开 声明（ declaration) 使得名字为程序所知， 一个文件如果想使用别处定义的名字则必须包含对那个名字的声明 定义(definition) 负责创建与名字关联的实体。 声明规定了变量的类型和名字， 在这一点上定义与之相同 定义规定了变量的类型和名字， 在这一点上定义与之相同；定义还申请存储空间， 也可能会为变量赋一个初始值 声明和定义的区别 如果想声明一个变量而非定义它， 就在变量名前添加关键字 extern, 而且不要显式地初始化变量 任何包含了显式初始化的声明即成为定义 在函数体内部， 如果试图初始化一个由 extern 关键字标记的变量， 将引发错误 变量能且只能被定义一次， 但是可以被多次声明。 1234extern int i； // 声 明i而非定义iint j； //声明并定义jint k = 10；//声明并且定义了k，还为k申请了内存空间并且进行了显示初始化extern double pi = 3.14.16; // 定义 使用情景： 如果要在多个文件中使用同一个变量， 就必须将声明和定义分离 变量的定义必须出现在且只能出现在一个文件中， 而其他用到该变量的文件必须对其进行声明， 却绝对不能重复定义。 静态类型 标识符 由字母、 数字和下画线组成 必须以字母或下画线开头 长度没有限制 ；对大小写字母敏感 12/ / 定义 4 个不同的 int 变量int somename, someName, SomeName, SOMENAME; C++语言保留了一些名字供语言本身使用， 这些名字不能被用作标识符 ；如表 2.3 和表 2.4 所示 用户自定义的标识符中不能连续出现两个下画线， 也不能以下画线紧连大写字母开头 定义在函数体外的标识符不能以下画线开头。 变量命名规范 标识符要能体现实际含义。 变量名一般用小写字母， 如 index, 不要使用 Index 或 INDEX。 用户自定义的类名一般以大写字母开头， 如 SaleS_item。 如果标识符由多个单词组成， 则单词间应有明显区分，如student_loan或student_Loan；不要使用 studentloan. 名字的作用域 每个名字都会指向一个特定的实体： 变量、 函数、 类型等 同—个名字如果出现在程序的不同位置， 也可能指向的是不同实体 作用域 C++语言中大多数作用域都以花括号分隔。 实例： 嵌套的作用域 作用域能彼此包含 内层作用域 ( innerscope ) ：被包含（ 或者说被嵌套） 的作用域 外层作用域 ( outer scope) ：包含着别的作用域的作用域 作用域中一旦声明了某个名字， 它所嵌套着的所有作用域中都能访问该名字 允许在内层作用域中重新定义外层作用域已有的名字 1234567891011121314151617#include &lt;iostream&gt;// 该程序仅用于说明 ： 函数内部不宜定义与全局变量同名的新变量int reused = 42; / / reused 拥有全局作用域int main ( ){ int unique 0; / / unique 拥有块作用域 // 输出 #1: 使用全局变量 reused;输出 42 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; int reused = 0; // 新建局部变量 reused， 覆盖了全局变量 reused // 输出 #2: 使用局部变量 reused; 输出 0 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; // 输出#3: 显式地访问全局变量 reused; 输出 42 0 std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; //全局作用域本身并没有名字， 所以当作用域操作符的左侧为空时， //向全局作用域发出请求获取作用域操作符右侧名字对应的变量 return 0;} 如果函数有可能用到某全局变量， 则不宜再定义一个同名的局部变量","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%8F%98%E9%87%8F%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第五节 处理类型）","text":"处理类型 问题情景：程序越来越复杂， 程序中用到的类型也越来越复杂 一是一些类型难于“ 拼写”， 它们的名字既难记又容易写错， 还无法明确体现其真实目的和含义 二是有时候根本搞不清到底需要的类型是什么， 程序员不得不回过头去从程序的上下文中寻求帮助。 类型别名 类型别名（ type alias) 定义：是一个名字， 它是某种类型的同义词。 好处：让复杂的类型名字变得简单明了、 易于理解和使用， 还有助于程序员清楚地知道使用该类型的真实目的。 定义类型别名 关键字 typedef 别名声明（ aliasdeclaration) 使用场景：类型别名和类型的名字等价， 只要是类型的名字能出现的地方， 就能使用类型别名： 12345typedef double wages; //wages 是 double 的同义词typedef wages base, *p; //base 是 double 的同义词， p 是 double *的同义词wages hourly, weekly;// 等价于 double hourly、 weekly;SI item; // 等价于 Sales_item item 指针、 常量和类型别名 如果某个类型别名指代的是复合类型或常量， 那么把它用到声明语句里就会产生意想不到的后果 下面的声明语句用到了类型pstring,它实际上是类型 char *的别名： pstring 实际上是指向 char 的指针， 因此， const pstring 就是指向char 的常量指针， 而非指向常量字符的指针。 人们往往会错误地尝试把类型别名替换成它本来的样子， 以理解该语句的含义： 这样改写的结果是， const char 成了基本数据类型。 前后两种声明含义截然不同， 前者声明了一个指向 char 的常量指针， 改写后的形式则声明了一个指向 const char 的指针。 auto 类型说明符 C++11 新标准引入了 auto 类型说明符 让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符（ 比如 double) 不同， auto 让编译器通过初始值来推算变量的类型。 显然， auto 定义的变量必须有初始值 使用 auto 也能在一条语句中声明多个变量。 因为一条声明语句只能有一个基本数据类型， 所以该语句中所有变量的初始基本数据类型都必须一样： 复合类型、 常量和 auto 编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样， 编译器会适当地改变结果类型使其更符合初始化规则。 当引用被用作初始值时， 真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为 auto的类型： auto —般会忽略掉顶层 const (参见 2.4.3 节， 第 57 页）， 同时底层 const 则会 保留下来， 比如当初始值是一个指向常量的指针时： 如果希望推断出的 auto 类型是一个顶层 const, 需要明确指出： 将引用的类型设为 auto, 此时原来的初始化规则仍然适用： 要在一条语句中定义多个变量， 切记， 符号&amp;和*只从属于某个声明符， 而非基本数据类型的一部分， 因此初始值必须是同一种类型： decltype 类型指示符 问题情景：希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量。 decltype 类型指示符 ：C++11 新标准引入了第二种类型说明符decltype. 它的作用是选择并返回操作数的数据类型。 在此过程中， 编译器分析表达式并得到它的类型， 却不实际计算表达式的值： decltype 处理顶层 const 和引用的方式与 auto 有些许不同。 如果 decltype 使用的表达式是一个变量， 则 decltype 返回该变量的类型( 包括顶层 const 和引用在内）： decltype 和引用如果 decltype 使用的表达式不是一个变量， 则 decltype 返回表达式结果对应的类型。 r 是一个引用， 因此 decltype (r ) 的结果是引用类型 如果想让结果类型是 r 所指的类型， 可以把 r 作为表达式的一部分， 如 r+0, 显然这个表达式的结果将是一个具体值而非一个引用。 如果表达式的内容是解引用操作， 则 decltype 将得到引用类型。 解引用指针可以得到指针所指的对象， 而且还能给这个对象赋值 因此， decltype ( *p) 的结果类艰就是 int &amp;， 而非 int。 decltype 和 auto 的另一处重要区別是， decltype 的结果类型与表达式形式密切相关。 特别注意 ： 对于 decltype 所用的表达式来说， 如果变量名加上了一对括号， 则得到的类型与不加括号时会有不同 123// decltype 的表达式如果是加上了括号的变量， 结果将是引用decltype ( (i) ) d; // 错误： d是 int&amp;， 必须初始化decltype (i) e; // 正确： e 是一个（ 未初始化的 ） int decltype( ( variable ) ) ( 注意是双层括号 ） 的结果永远是引用， 而decltype( variable) 结果只有当 variable 本身就是一个引用时才是引用。","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89/"},{"title":"Primer C++ 第五版（第三章 字符串、向量和数组 第五节 数组）","text":"数组 存放类型相同的对象的容器 存放的对象本身没有名字,需通过其所在位置访问 数组大小确定不变,不可随意增加元素 如果不清楚对象元素的个数,请选择 vector 定义和初始化内置数组 数组声明 a[d] a是名字，d是维度，d必须大于0；d必须是常量表达式： 案例： 默认情况下，数组的元素被默认初始化 定义数组必须指明数组类型，不允许使用auto关键来声明数组类型 数组元素必须为对象，不存在引用类型数组 显式初始化数组元素 对数组进行列表初始化（参见3.3.1节第88页） 数组的维度和初始值的总数量应该匹配 初始值个数大于维度 报错 初始值小于维度 初始化靠前位置的元素，其余元素进行默认值初始化（参见3.3.1节第88页） 案例： 字符数组的特殊性 字符数组额外的初始化方法：使用字符串字面值（2.1.3节第36页）进行字符数组的初始化 特殊请注意：字符串结尾的空字符也会和其他字符一样拷贝到字符数组中去 案例： 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值， 也不能用数组为其他数组赋值 案例： 特殊情况： 理解复杂的数组声明 数组可以存放大多数的对象 可以定义一个存放指针的数组 允许定义数组的指针 和 数组的引用 定义存放指针的数组比较简单和直接 案例1： 案例2： 1int *(&amp;arry)[10] = ptrs; // arry 是数组的引用， 该教组含有 10 个指针 总结： 要想理解数组声明的含义， 最好的办法是从数组的名字开始按照由内向外的顺序阅读 访问数组元素 范围for语句访问数组元素 下标访问数组元素 数组下标从0开始 数组下标的类型是size_t类型，这是一种机器相关的无符号类型；足够大；在 cstddef 头文件中定义了 size_t 类型 数组大小固定；其他用法和vector类似 案例1： 案例2：使用范围for语句访问遍历数组元素 检查下标的值 数组的下标是否在合理范围之内由程序员负责检查， 所谓合理就是说下标应该大于等于 0 而小于数组的大小 大多数常见的安全问题都源于缓冲区溢出错误；当数组或其他类似数据结构的下标越界并试图访问非法内存区域时， 就会产生此类错误 指针和数组 总结：在C++中，数组和指针关系密切；使用数组的时候编译器一般会把数组转换成指针 使用取地址符获取数组元素的地址 备注：取地址符的作用是获取某个对象的指针，适用于任何对象；数组的元素也是对象！！！ 数组名会被转换成指向数组首元素的指针： 案例： 数组的操作其实是对指针的操作（auto） 使用数组作为auto变量的初始值，得到的类型是指针案例： 上述案例等价于： 使用decltype关键字时不会发生上述转换 指针也是迭代器 vector和string的迭代器支持的，数组的指针全部支持 案例： 使用指针遍历数组元素 前提：获取数组第一个元素的指针和数组尾元素的下一位置的指针 尾元素下一位置的指针： 尾后指针 不指向具体的元素 不能对尾后指针进行解引用和递增的操作 案例：使用尾后指针和第一个指针进行数组遍历输出 标准库函数begin和end 问题情景： 尾后指针的计算很容易出错 C++11新标准引入的解决方案:begin 和 end 注意事项:数组不是类类型,所以这两个函数不是成员函数,使用方法和容器中的略微不同;正确形式是将数组作为两个函数的参数 案例1: 案例2:使用begin和end找到整型数组中的第一个负数 特别注意: 指针运算 指向数组元素的指针可以执行表3.6第96页和表3.7第99页列出的所有迭代器的操作 案例: 指针和整数相加得到的仍需是同一数组的元素;或者指向尾后指针 两个指针相减得到元素之间的距离;必须是同一数组中的元素指针 两个指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型 定义在cstddef头文件中机器相关的类型 带符号类型 案例:遍历数组元素 错误案例:两个指针指向不相关的对象,则不能比较 解引用和指针运算的交互 如果指针指向一个元素,则允许解引用 案例： 表达式中含有解引用运算符或者点运算符的时候，请适当加上圆括号 案例： 这就和上面产生了截然不同的结果 下标和指针 使用数组名实际上使用的是指向数组首元素的指针 案例： 12345int ia[] = { 0,2,4,6,8 }; // 含有 5 个整数的数组int i = ia[2]; // ia 转换成指向数组首元素的指针 // ia [2] 得到（ia + 2）所指的元素int *p = ia; // p 指向 ia 的首元素i = *(p + 2); //等价于i = ia[2]； 只要指针指向的是数组元素，均可以进行指针运算 案例1： 特殊情况： 标准库类型限定使用的下标必须是无符号数；内置的下标无此限制 内置下标可以处理负值 但是！！！结果地址必须指向原来的指针所指同一数组中的元素（ 或是同一数组尾元素的下一位置）。 C风格字符串 备注！！！ 字符串字面值是一种通用结构的实例 ；C++由 C 继承而来的 C 风格字符串(C-style character string) 存放在字符数组中并以空字符结束 ( nullterminated) C 标准库 String 函数 头文件：定义在 cstring 头文件中， cstring 是 C 语言头文件 string.h 的 C++版本 c风格字符串的函数 所列的函数不负责验证其字符串参数 传入此类函数的指针必须指向以空字符作为结束的数组 案例： 比较字符串 ！！！比较C风格字符串的方法和比较标准库string对象的方法完全不同 比较标准库 string 对象 案例1：普通的关系运算符和相等性运算符 比较c 风格字符串 案例2：比较的将是指针而非字符串本身 strcmp 函数 比较两个 C 风格字符串 两个字符串相等， strcmp 返回 0 前面的字符串较大， 返回正值 否则负值 案例： 目标字符串的大小由调用者指定 连接和拷贝C风格字符串和标准库string对象的也不一样 标准库string对象 案例1： C风格字符串 如果和string一样相加，就是两个指针相加，毫无意义 使用 strcat 函数和 strcpy 函数 前提：提供一个用于存放结果字符串的数组， 该数组必须足够大以便容纳下结果字符串及末尾的空字符 案例： 注意事项： 对大多数应用来说， 使用标准库 string 要比使用 C 风格字符串更安全、 更高效。 与旧代码的接口 问题情景 现代的 c++程序不得不与那些充满了数组和/或 C 风格字符串的代码衔接， 为了使这一工作简单易行， C++专门提供了一组功能 混用 string 对象和 C 风格字符串 允许使用字符串字面值来初始化 string 对象 案例： 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代: 允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值 在 string 对象的加法运算中允许使用以空字符结朿的字符数组作为其中一个运算对象（ 不能两个运算对象都是)； 在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象 注意事项：!!! 如果程序的某处需要一个 C 风格字符串， 无法直接用string 对象来代替它 案例:不能用 string 对象直接初始化指向字符的指针 解决办法:string的c_str 成员函数 关于c_str函数的注意事项: 无法保证 c_str 函数返回的数组一直有效， 事实上， 如果后续的操作改变了 s的值就可能让之前返ii]的数组失去效用。 如果执行完 c_str() 函数后程序想一直都能使用其返回的数组， 最好将该数组重新拷贝一份。 使用数组初始化vector对象 不允许使用一个数组为另一个内置类型的数组赋初值 不允许使用 vector 对象初始化数组 允许使用数组来初始化 vector 对象 案例1:使用数组的全部值初始化vector对象 案例2:使用数组的部分值初始化vector对象 写在最后:","link":"/2022/07/11/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AC%AC%E4%BA%94%E8%8A%82-%E6%95%B0%E7%BB%84%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第六节 自定义数据结构）","text":"自定义数据结构 数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法 定义Sales_data类型 初步想法是定义一个用户可以直接访问类中数据元素但是不带任何运算功能 类以关键字 struct 开始， 紧跟着类名和类体（ 其中类体部分可以为空) 内部定义的名字必须唯一， 但是可以与类外部定义的名字重复。 类体右侧的表示结束的花括号后必须写一个分号， 这是因为类体后面可以紧跟变量名以示对该类型对象的定义， 所以分号必不可少 1234struct Sales_data { /* ... */ } accum, trans, *salesptr;// 与上一条语句等价， 但可能更好一些struct Sales_data { /* • • • */ };Sales_data accum, trans, *salesptr; 类体定义类的成员， 我们的类只有数据成员（ data member) C++11 新标准规定， 可以为数据成员提供一个类内初始值（in-class initializer)。 创建对象时， 类内初始值将用于初始化数据成员。 没有初始值的成员将被默认初始化 使用 Sales_data 类 计算两次交易结果相加的记录，输入数据如下 添加两个 Sales_data 对象假设己知 Sales_data 类定义于 Sales_data.h 文件内 ；头文件定义参见（2.6.3 节 ） 程序较长，分成几份介绍，总体结构如下： Sales_data 对象读入数据 输出两个 Sales_data 对象的和剩下的工作就是检查两笔交易涉及的 ISBN 编号是否相同了。 如果相M输出它们的和,否则输出一条报错信息： 编写自己的头文件 为了确保各个文件中类的定义一致， 类通常被定义在头文件中， 而且类所在头文件的名字应与类的名字一样 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明 预处理器概述 预处理器是在编译之前执行的一段程序， 可以部分地改变我们所写的程序。 预处理功能#include, 当预处理器看到#include标记时就会用指定的头文件的内容代替#include C++程序还会用到的一项预处理功能是头文件保护符 （ header guard), 头文件保护符依赖于预处理变量 （2.3.2 节， 第 48 页 ）预处理变量有两种状态： 己定义和未定义。 #define 指令把一个名字设定为预处理变量， 另外两个指令则分别检查某个指定的预处理变量是否己经定义 #ifdef 当且仅当变量已定义时为真， #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真， 则执行后续操作直至遇到#endif 指令为止。 目的：有效地防止重复包含的发生 预处理变量无视 C++语言中关于作用域的规则。 头文件即使（ 目前还 ） 没有被包含在任何其他头文件中， 也应该设置保护符头文件保护符很简单， 程序员只要习惯性地加上就可以了 ， 没必要太在乎你的程序到底需不需要。 整个程序中的预处理变量包括头文件保护符必须唯一， 通常的做法是基于头文件中类的名字来构建保护符的名字， 以确保其唯一性。 为了避免与程序中的其他实体发生名字冲突， 一般把预处理变量的名字全部大写。","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/"},{"title":"Primer C++ 第五版（第二章 变量和基本类型 第四节 const限定符）","text":"const 限定符 const 对象一旦创建后其值就不能再改变， 所以 const 对象必须初始化。 初始值可以是任意复杂的表达式 123const int i = get_size()； // 正确：运行时初始化const int j = 42；// 正确：编译时初始化const int k；//错误，k是一个未经初始化的常量 初始化和 const 非 const 类型所能参与的操作相比， const 类型的对象能完成其中大部分 只能在 const 类型的对象上执行不改变其内容的操作 const对象可以用于初始化 123int i = 42;const int ci = i； // 正确： i的值被拷贝给了 ciint j = ci； // 正确： ci的值被拷贝给了 j 默认状态下， const 对象仅在文件内有效 const对象的生效过程： 当以编译时初始化的方式定义一个const对象时： 1const int bufSize = 512; / / 输入缓冲区大小 编译器将在编译过程中把用到该变量的地方都替换成对应的值。 为了执行上述替换， 编译器必须知道变量的初始值 如果程序包含多个文件， 则每个用了 const 对象的文件都必须得能访问到它的初始值才行。 要做到这一点， 就必须在每一个用到变量的文件中都有对它的定义（ 参见 2.2.2 节， 第 41 页 ）。 为了支持这一用法，同时避免对同一变量的重复定义， 默认情况下， const 对象被设定为仅在文件内有效 当多个文件中出现了同名的 const 变量时， 其实等同于在不同文件中分别定义了独立的变量。 问题场景： 某些时候有这样一种 const 变量， 它的初始值不是一个常量表达式， 但又确实有必要在文件间共享。 这种情况下， 我们不希望编译器为每个文件分别生成独立的变量。 相反，我们想让这类 const 对象像其他（ 非常量） 对象一样工作， 也就是说， 只在一个文件中定义 const， 而在其他多个文件中声明并使用它 解决办法： 如果想在多个文件之间共享 const 对象， 必须在变量的定义之前添加 extern关键字。 1234// file_l.cc 定义并初始化了一个常量， 该常量能被其他文件访问extern const int bufSize = fcn ( );// file_l.h 头文件extern const int bufSize;/// / 与 file_1.cc 中定义的 bufSize 是同一个 const 的引用 对常量 的引用（ reference to const) 把引用绑定到 const 对象上， 就像绑定到其他对象上一样， 对常量的引用不能被用作修改它所绑定的对象： 样例： 1234const int ci = 1024;const int &amp;r1 = ci; // 正确： 引用及其对应的对象都是常量r1 = 42; // 错误： r1 是对常量的引用int &amp;r2 = ci; // 错误： 试图让一个非常量引用指向一个常量对象 术语： 初始化和对 const 的引用 引用的类型必须与其所引用对象的类型一致（2.3.1 第46页）， 但是有两个例外 在初始化常量引用时允许用任意表达式作为初始值， 只要该表达式的结果能转换成（参见 2.1.2 节， 第 32 页 ） 引用的类型即可。 尤其， 允许为一个常量引用绑定非常量的对象、 字面值， 甚至是个一般表达式： 12345678int i = 42;const int &amp;r1 = i; // 允许将 const int &amp;绑定到一个普通 int 对象上const int &amp;r2 = 42;// 正确： r1 是一个常量引用 //读者疑问：这里和r1有什么关系？笔误吗？正确的写法是const int &amp;r2 = r1；？const int &amp;r3 = r1 * 2; // 正确： r3 是一个常量引用int &amp;r4 = r1 * 2; // 错误： r4 是一个普通的非常量引用 细节探究1：当一个常量引用被绑定到另外一种类型上时到底发生了什么？ 12double dval = 3.14;const int &amp;ri = dval; 此处 ri 引用了一个 int 型的数。 对 ri 的操作应该是整数运算， 但 dval 却是一个双精度浮点数而非整数。 因此为了确保让 ri 绑定一个整数， 编译器把上述代码变成了如下形式: 12const int temp = dval；// 由双精度浮点数生成一个临时的整型常量 const int &amp;ri = temp; // // 让ri 绑定这个临时量 在这种情况下， ri 绑定了一个临时量 ( temporary ) 对象。 所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 C++程序员们常常把临时量对象简称为临时量。 接下来探讨当ri 不是常量时， 如果执行了类似于上面的初始化过程将带来什么样的后果。 如果ri 不是常量， 就允许对ri 赋值， 这样就会改变ri 所引用对象的值。 注意，此时绑定的对象是一个临时量而非 dval。 程序员既然让 ri 引用 dval, 就肯定想通过ri改变dval的值， 否则干什么要给ri赋值呢？ 如此看来， 既然大家基本上不会想着把引用绑定到临时量上， C++语言也就把这种行为归为非法。 对 const 的引用可能引用一个并非 const 的对象 常量引用仅对引用可参与的操作做出了限定， 对于引用的对象本身是不是一个常量未作限定 因为对象也可能是个非常量， 所以允许通过其他途径改变它的值 : 样例： 12345int i = 42;int &amp;r1 = i;// 引 用 ri绑定对象iconst int &amp;r2 = i;// r2 也绑定对象i, 但是不允许通过 r2 修改i的值r1 = 0;// r1 并非常量 ， i的值修改为 0r2 = 0;// 错误： r2 是一个常量引用 读者疑问：那么在上面这个例子里面，常量引用r2的值也被改成了0吗？常量引用为什么可以改变？ 指针和 const 与引用一样， 也可以令指针指向常量或非常量 类似于常量引用（ 参见 2.4.1 节， 第54 页）， 指向常量的指针（pointer to const) 不能用于改变其所指对象的值。 要想存放常量对象的地址， 只能使用指向常量的指针： 1234const double pi = 3.14; // pi 是个常量， 它的值不能改变double *ptr = &amp;pi; // 错误： ptr 是一个普通指针const double *cptr = &amp;pi; // 正确： cptr 可以指向一个双精度常量*cptr = 42; // 错误： 不能给*cptr 賦值 指针的类型必须与其所指对象的类型一致( 2.3.2 节（ 第 47 页）)例外情况： 允许令一个指向常量的指针指向一个非常量对象 12double dval = 3.14;// dval 是一个双精度浮点数， 它的值可以改变cptr = &amp;dval;//正确： 但是不能通过 cptr 改变 dval 的值 和常量引用一样， 指向常量的指针也没有规定其所指的对象必须是一个常量 所谓指向常量的指针仅仅要求不能通过该指针改变对象的值， 而没有规定那个对象的值不能通过其他途径改变。 关于指向常量的指针或者引用的总结： 试试这样想吧： 所谓指向常量的指针或引用， 不过是指针或引用 “ 自以为是’罢了， 它们觉得自己指向了常量， 所以自觉地不去改变所指对象的值。 const 指针 指针是对象而引用不是， 因此就像其他对象类型一样， 允许把指针本身定为常量 常量指针 (const pointer) 必须初始化， 而且一旦初始化完成， 则它的值（ 也就是存放在指针中的那个地址） 就不能再改变了。 不变的是指针本身的值而非指向的那个值 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值， 能否这样做完全依赖于所指对象的类型 所指向的对象是常量，则不能修改 所指向的对象是非常量，则完全可以通过这个对象或者这个常量指针 去修改这个被指向对象的值 顶层 const(读者注：这一小节读者表示看不明白~~~) 问题情景： 指针本身是个对象，他又可以指向另外的对象；指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。 顶层const(top-level const) 指针本身是个常量 底层 const (low-level const) 指针所指的对象是一个常量 顶层const和底层 const的区分() 顶层 const 可以表示任意的对象是常量， 这一点对任何数据类型都适用，如算术类型、 类、 指针等 底层 const 则与指针和引用等复合类型的基本类型部分有关。 指针类型既可以是顶层 const 也可以是底层 const 123456int i = 0;int *const pi = &amp;i;// 不能改变 pi 的值， 这是一个顶层 constconst int ci = 42;// 不能改变 ci 的值， 这是一个顶层 constconst int *p2 = &amp;ci;// 允许改变 p2 的值， 这是一个底层 constconst int *const p3 = p2; // 靠右的 const 是顶层 const, 靠左的是底层 constconst int &amp;r = ci;// 用于声明引用的 const 都是底层 const 当执行对象的拷贝操作时， 常量是顶层 const 还是底层 const 区别明显。 其中， 顶层 const 不受什么影响： 另一方面， 底层 const 的限制却不能忽视。 当执行对象的拷贝操作时， 拷入和拷出的对象必须具有相同的底层 const 资格， 或者两个对象的数据类型必须能够转换。 一般来说， 非常量可以转换成常量， 反之则不行： 1234567i= ci;// 正确： 拷贝 ci 的值， ci 是一个顶层 const， 对此操作无影响p2 = p3;// 正确： p2 和 p3 指向的对象类型相同， p3 顶层 const 的部分不影响int *p = p3;// 错误： p3 包含底层 const 的定义， 而 p 没有p2 = p3;// 正确： p2 和 p3 都是底层 constp2 = &amp;i;// 正确： int 能转换成 const int*int &amp;r ci;// 错误： 普通的 int &amp;不能绑定到 int 常量上const int &amp;r2 =i;//正确：const int &amp;可以绑定到一个普通 int 上 constexpr 和常量表达式常量表达式 指值不会改变并且在编译过程就能得到计算结果的表达式 ；字面值属于常量表达式 常量表达式初始化的 const 对象也是常量表达式 一个对象（ 或表达式） 是不是常量表达式由它的数据类型和初始值共同决定 ![image-20220705221413365](D:\\书本和读书笔记\\Primer C++ 第五版（第一部分 C++基础 第二章 变量和基本类型）.assets\\image-20220705221413365.png) constexpr 变量 C++11 新标准规定， 允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式 声明为 constexpr 的变量一定是一个常量， 而且必须用常量表达式初始化： 注意事项： 函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量。 （ 6.1.1 节（ 第 184 页）） 相反的， 定义于所有函数体之外的对象其地址固定不变， 能用来初始化 constexpr 指针 允许函数定义一类有效范围超出函数本身的变量 （ 6.1.1 节（ 第 184 页）） ， 这类变量和定义在函数体之外的变量一样也有固定地址。 因此， constexpr 引用能绑定到这样的变量上， constexpr 指针也能指向这样的变量。 字面值类型 （ literal type) 问题情景：常量表达式的值需要在编译时就得到计算， 因此对声明 constexpr 时用到的类型必须有所限制 这些类型一般比较简单， 值也显而易见、 容易得到， 就把它们称为“ 字面值类型”（ literal type)。 有哪些？ 算术类型、 引用和指针都属于字面值类型 自定义类 Sales_item、 10 库、 string 类型则不属于字面值类型， 也就不能被定义成constexpr 其他字面值类型7.5.6 节（ 第 267 页） 和 19.3 节（ 第 736 页） 指针和引用都能定义成 constexpr, 但它们的初始值却受到严格限制 一个constexpr 指针的初始值必须是nullptr 或者 0,或者是存储于某个固定地址中的对象 指针和 constexpr 在 constexpr 声明中如果定义了一个指针， 限定符 constexpr 仅 对指针有效， 与指针所指的对象无关 ​ p 是一个指向常量的指针， 而 q 是一个常量指针， 其中的关键在于 constexpr 把它所定义的对象置为了顶层 const 2.4.3 节， 第 57 页. constexpr 指针既可以指向常量也可以指向一个非常量：","link":"/2022/07/06/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E8%8A%82-const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89/"},{"title":"Primer C++ 第五版（第四章 表达式 第一节 基础）","text":"基本概念 写在前面！！！ 由一个或多个运算对象（ operand) 组成， 对表达式求值将得到一个结果（ result); 最简单的表达式 ( expression)是字面值和变量 ;结果就是他们的值 一个运算符和一个或者多个表达式结合可以得到复杂的表达式 一元运算符（ unary operator) 作用于一个运算对象的运算符 案例： 取地址符 （ &amp;) 和解引用符 (* ) 二元运算符（ binary operator) 作用于两个运算对象 案例：相等运算符（==) 和乘法运算符（ *) 三元运算符 作用于三个运算对象 函数调用 一种特殊的运算符， 它对运算对象的数量没有限制。 注意： 一些符号既能作为一元运算符也能作为二元运算符 案例：* 作为一元运算符时执行解引用操作， 作为二元运算符时执行乘法操作。 总结： 由它的上下文决定 组合运算符和运算对象 想要理解复含有多个运算符的表达式，就必须先理解运算符的优先级、结合律以及运算对象的求值顺序 案例： 15 + 10 * 20/2; 盲目理解*的四种可能： 10 和 20 10 和 20/2 15 和 20 . 15 和 20/2 运算对象转换 类型转换（参见 2.1.2 节， 第 32 页 ） 案例：小整数类型（ 如 bool、 char、 short 等） 通常会被提升（ promoted) 成较大的整数类型 （int）；4.11 节（ 第 141 页） 重载运算符 为已存在的运算符赋予了另外一层含义 ， 所以称之为重载运算符 ( overloadedoperator) 案例： IO库的&gt;&gt;和&lt;&lt; 运算符 string 对象、 vector 对象和迭代器使用的运算 注意事项 使用重载运算符时， 其包括运算对象的类型和返回值的类型， 都是由该运算符定义的 ； 运算对象的个数、 运算符的优先级和结合律都是无法改变的 左值和右值 C++的表达式要不然是右值（ rvalue, 读 作 “are-value”)， 要不然就是左值（ lvalue,读作 “ ell-value”)。 从 C 语言继承 案例： 左值可以位于赋值语句的左侧， 右值则不能。 总结： 对象被用作右值的时候， 用的是对象的值（ 内容）； 对象被用作左值的时候， 用的是对象的身份（ 在内存中的位置） 使用规则总结： 需要右值的地方可以用左值来代替， 但是不能把右值当成左值（ 也就是位置） 使用。 参见13.6 节， 第 470 页 将介绍一种例外的情况 案例： 赋值运算符需要一个（ 非常量） 左值作为其左侧运算对象， 得到的结果也仍然是一个左值。 取地址符（参见 2.3.2 节， 第 47 页）作用于一个左值运算对象， 返回一个指向该运算对象的指针， 这个指针是一个右值 内置解引用运算符、 下标运算符（参见 2.3.2 节， 第 48 页、参见 3.5.2 节， 第 104页）、 迭代器解引用运算符、 string 和 vector 的下标运算符(参见 3.4.1 节， 第95 页、参见 3.2.3 节， 第 83 页、参见 3.3.3 节， 第 91 页)的求值结果都是左值。 内置类型和迭代器的递增递减运算符(参见 1.4.1 节， 第 11 页、参见 3.4.1 节， 第96 页)作用于左值运算对象， 其前置版本（ 本书之前章节所用的形式） 所得的结果也是左值 优先级和结合律 复合表达式（ compound expression) 是指含有两个或多个运算符的表达式 优先级与结合律决定了运算对象组合的方式 表达式中的括号无视上述规则， 高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组合在一起 如果优先级相同， 则其组合规则由结合律确定 括号无视优先级与结合律 括号无视普通的组合规则， 表达式中括号括起来的部分被当成一个单元来求值， 然后再与其他部分一起按照优先级组合 案例： 优先级与结合律有何影响 优先级会影响程序的正确性 案例：解引用和指针运算中也有所体现 4.12 节（ 第 147 页） 罗列出了全部的运算符， 并用双横线将它们分割成若干组。 同一组内的运算符优先级相同， 组的位置越靠前组内的运算符优先级越高 求值顺序 求值顺序对程序正确性的影响 案例1： 1int i = f1() * f2(); 解析： 相乘之前会调用f1()和f2() 但是我们无法知道先调哪一个！！！ 案例2：如果表达式指向并修改了同一个对象， 将 会引发错误并产生未定义的行为 （参见 2.1.2 节， 第 33 页 ） 12int i = 0;cout&lt;&lt;i&lt;&lt;&quot;&quot;&lt;&lt;++i&lt;&lt;endl;//错误：未定义的 解析： 因为程序是未定义的， 所以我们无法推断它的行为 编译器可能先求++i的值再求i的值，此时输出结果是 1 1; 也可能先求i的值再求++i的值， 输出结果是 0 1: 明确规定了运算对象的求值顺序 的四种运算符 逻辑与（ &amp; &amp; ) 运算符 先求左侧运算对象的值， 只有当左侧运算对象的值为真时才继续求右侧运算对象的值 逻辑或(||)运算符 参见 4.3 节， 第 126 页 条件（？： ） 运算符 参见 4.7 节， 第 134 页 逗号（， ） 运算符 参见 4.10 节， 第 140 页 求值顺序、 优先级、 结合律 运算对象的求值顺序与优先级和结合律无关 案例：f ( ) +g ( ) *h ( ) +j ( ) ； 解析： 优先级规定， g ( ) 的返回值和 h ( ) 的返回值相乘。 结合律规定， f ( ) 的返回值先与 g ( &gt; 和 h ( ) 的乘积相加， 所得结果再与 j ( ) 的返回值相加。 对于这些函数的调用顺序没有明确规定. 深度剖析： 如果 f、 g、 h 和 j 是无关函数， 它们既不会改变同一对象的状态也不执行 10 任务， 那么函数的调用顺序不受限制 如果其中某几个函数影响同一对象， 则它是一条错误的表达式， 将产生未定义的行为。 总结：对书写复杂表达式的两点建议！！！","link":"/2022/07/12/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E7%A1%80%EF%BC%89/"},{"title":"Primer C++ 第五版（第四章 表达式 第二节 算术运算符）","text":"算术运算符 表4.1按照优先级分组 一元运算符的优先级最高；乘除法次之；加减法最低 高优先级的运算符比低优先级的运算符组合更加紧密； 优先级相同时，按照从左往右的顺序进行组合 算术运算符的运算对象和求值结果都是右值； 表达式求值之前， 小整数类型的运算对象被提升成较大的整数类型， 所有运算对象最终会转换成同一类型。 一元正号运算符、 加法运算符和减法运算符都能作用于指针。 当一元正号运算符作用于一个指针或者算术值时， 返回运算对象值的一个（提升后的） 副本。 案例：布尔值不应该参与运算， -b 就是一个很好的例子 123456int i = 1024;int k = -i;// k 是-1024bool b = true;bool b2 = -b;// b2 是 true! 解析：布尔变量 b 的值为真， 参与运算时将被提升成整数值 1 ( 参见 2.1.2 节， 第 32 页）， 对它求负后的结果是-1。 将-1再转换回布尔值并将其作为 b2 的初始值， 显然这个初始值不等于 0,转换成布尔值后应该为 1。 所以， b2 的值是真 二元加法和减法运算符作用于指针的情况。 参见3.5.3 节（ 第 106 页） 溢出和其他运算异常 当作用于算术类型的对象时， 算术运算符+、 *、 /的含义分别是加法、 减法、 乘法和除法。 整数相除结果还是整数， 也就是说， 如果商含有小数部分， 直接弃除 案例： 12int ivall = 21/6;// ivall 是 3, 结果进行了删节， 余数被抛弃掉了int ival2 = 21/7;// ival2 是 3, 没有余数， 结果是整数值 运算符％俗称“ 取余” 或“ 取模” 运算符， 负责计算两个整数相除所得的余数， 参与取余运算的运算对象必须是整数类型 案例： 1234int ival = 42;double dval = 3.14;ival % 12;// 正确： 结果是 6ival % dval;// 错误： 运算对象是浮点类型 根据取余运算的定义， 如果 HI 和 n 是整数且 n 非 0, 则表达式（m/n) *n+m%n 的求值结果与 m 相等。 隐含的意思是， 如果 m%n 不等于 0, 则它的符号和 m 相同。 C++语言的早期版本允许 m%n 的符号匹配 n 的符号， 而且商向负无穷一侧取整， 这一方式在新标准中已经被禁止使用了。 除了-m 导致溢出的特殊情况， 其他时候（ -m) /n 和 -(m/n)都 等 于- (m/n) ， m% (-n) 等于 m%n, (-m ）%n 等于- (m%n) 。 具体示例如下：","link":"/2022/07/13/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/"},{"title":"Primer C++ 第五版（第四章 表达式 第三节 逻辑和关系运算符）","text":"前言总结： 关系运算符 作用于算术类型或指针类型 返回值：布尔类型 ；值为0的表示假， 否则表示真 运算对象和求值结果都是右值 逻辑运算符 作用于任意能转换成布尔值的类型 返回值：布尔类型 ；值为0的表示假， 否则表示真 运算对象和求值结果都是右值 逻辑与和逻辑或运算符逻辑与 （ &amp;&amp; ) 当且仅当两个运算对象都为真时结果为真 先求左侧运算对象的值再求右侧运算对象的值 短路求值（ short-circuit evaluation)。 逻辑或（ II ) 只要两个运算对象中的一个为真结果就为真 先求左侧运算对象的值再求右侧运算对象的值 短路求值（ short-circuit evaluation)。 总结： 应用提高： 左侧运算对象是可以确保右侧运算对象求值过程的正确性和安全性 案例1： 1index != s.size()&amp;&amp;!isspace(s[index]) 解析： 首先检查 index 是否到达 string 对象的末尾 有当 index 在合理范围之内时才会计算右侧运算对象的值。 案例2：有一个存储着若干 string 对象的 vector 对象， 要求输出 string 对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。 if 语句的条件部分首先检查 S 是否是一个空string, 如果是， 则不论右侧运算对象的值如何都应该换行。 只有当 string 对象非空时才需要求第二个运算对象的值， 也就是检査 string 对象是否是以句号结束的。 text的元素是 string 对象， 可能非常大， 所以将 s 声明成引用类型可以避免对元素的拷贝； 又因为不需要对 string 对象做写操作， 所以 s 被声明成对常量的引用。 逻辑非运算符（!） 运算对象的值取反后返回 案例：使用逻辑非运算符将 empty 函数的返回值取反从而检査整数类型的 vector 对象 vec 是否含有元素 123//输出vec对象的首元素（如果有的话）if(!vec.empty()) cout&lt;&lt;vec(0); 解析：empty 函数返回假时结果为真 关系运算符 比较运算对象的大小关系并返回布尔值 关系运算符都满足左结合律 几个关系运算符连写在一起会产生意想不到的结果： 案例： 12// 哎哟！ 这个条件居然拿 1 &lt; j 的布尔值结果和 k 比较！if (i &lt; j &lt; k) // 若 k 大于 1 则为真！ 解析： 首先把i、 j 和第一个&lt;运算符组合在一起， 其返回的布尔值再作为第二个&lt;运算符的左侧运算对象 正解： 12// 正确： 当i小于 j 并且 j 小于 k 时条件为真if (i &lt; j &amp; &amp; j &lt; k) { /* ...*/ } 相等性测试与布尔字面值 问题场景：如果想测试一个算术对象或指针对象的真值， 最直接的方法就是将其作为 if 语句的条件 案例： 12if(val)(/*......*/) //如果 val 是任意的非 0 值， 条件为真if(!val)(/*......*/) //如果 val 是 0, 条件为真 解析： 编译器都将 val 转换成布尔值 案例改写： 1if (val == true) { /* ...*/ } // 只有当 val 等于 1 时条件才为真！ 解析： 上面这种写法较长而且不太直接(尽管大家都认为缩写的形式对初学者来说有点难理解） 如果 val 不是布尔值， 这样的比较就失去了原来的意义。 进行比较之前会首先把 true 转换成 val 的类型 如果真想知道 val 的值是否是 1, 应该直接写出 1这个数值来， 而不要与 true 比较。 总结：","link":"/2022/07/16/Primer-C++-%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89/"},{"title":"我的C++学习之路","text":"我的C++学习之路C++https://www.runoob.com/cplusplus/cpp-tutorial.html Socket、多线程、Boost、STLLinux操作系统 Linux kernel优化和裁剪 https://www.runoob.com/linux/linux-tutorial.html 设计模式https://www.runoob.com/design-pattern/design-pattern-resources.html TCP/IP 协议栈，http、https等应用层协议 多线程、网络编程，并发编程SQL、Oraclehttps://www.runoob.com/cplusplus/cpp-tutorial.html 数据结构+算法https://www.runoob.com/data-structures/data-structures-tutorial.html Makefile、shellhttps://www.runoob.com/linux/linux-shell.html 操作系统原理https://blog.csdn.net/SakuraA6/article/details/108810916 可以考虑的证书：网络安全认证资质 CISP CISAW https://zhuanlan.zhihu.com/p/533080699 CMAKEGit统计分析目前手上负责的代码 ERPS LACP MC_LACP link-oam lmdp pfm portiop","link":"/2022/07/12/%E6%88%91%E7%9A%84C++%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"},{"title":"博客首次测试文档","text":"博客框架搭建测试首次上线博客测试创建时间 测试标签","link":"/2021/08/06/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95/"},{"title":"通信技术概论","text":"通信技术概论第一章、通信和通信系统概述1、信号和系统 信号（本书讨论的是电信号） 信号的传递方式 电信号 光信号 （电）信号的分类 模拟信号 取值范围连续，有无限多的取值，包含时间连续函数和时间离散函数 子主题 2 数字信号 系统 2、通信系统的组成和工作原理3、通信系统的分类第二章、信号的传输和交换1、信号的传输和交换2、模拟信号数字化—脉冲编码调制3、数字信号的传输系统第三章、光纤通信系统1、光纤的结构和分类2、光纤的传输特性3、光缆的结构和种类4、光纤通信系统的组成第四章、通信网1、通信网的种类2、通信网的拓扑结构3、通信网的分类4、综合业务数字网第五章、通信技术的发展方向1、通信网的数字化2、通信网的综合化3、通信网的宽带化4、通信网的智能化5、通信的个人化6、通信的全球化第六章、华为通信产品综述1、华为公司的主要产品系列2、华为主要产品概述3、华为产品在现代通信网中的应用","link":"/2022/07/12/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA/"},{"title":"博客搭建常见问题汇总","text":"1.博客部署问题-1问题描述Failed to connect to github.com port 443: Timed out 解决方法1234git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080git config --global --unset http.proxygit config --global --unset https.proxy 2.博客部署问题-2问题描述123456789fatal: unable to access 'https://github.com/***/***.github.io/': Encountered end of fileFATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 解决办法方案11234cd /usr/local/src/hexo/ ##进入站点根目录rm -rf .deploy_git/ ##删除git提交内容文件夹git config --global core.autocrlf false ##执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d ##最后 方案21234567891011##修改hexo根目录下deploy相关配置cd /usr/local/src/hexo/ ##进入站点根目录vim _config.yml ##删除git提交内容文件夹deploy: ##修改type: gitrepo: ##如下一行修改仓库地址https://github.com/***/***.github.io.git -&gt; git@github.com:***/***.github.io.gitbranch: masterhexo clean &amp;&amp; hexo g &amp;&amp; hexo d ##最后 方案31234##强制推送部署,不建议cd /usr/local/src/hexo/ ##进入站点根目录cd .deploy_git/ ##进入depoly文件夹git push -f ##强制推送 3.博客部署问题-3问题描述123456789101112fatal: unable to access 'https://github.com/panxizi/panxizi.github.io.git/': OpenSSL SSL_read: Connection was reset, errno 10054FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:375:28) at ChildProcess.cp.emit (D:\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 解决方案1$ git config --global http.sslVerify &quot;false&quot;","link":"/2021/08/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"《社会性动物》第一部分：检视阅读笔记","text":"社会性动物阅读Tips阅读步骤 检视阅读 检视阅读第一层 子主题 1 检视阅读第二层 检视阅读的问题 这本书在谈什么 这本书的架构如何 这本书分为哪些部分 这是什么类型的书籍 检视阅读的目的 有限的时间内，最好最完整的阅读（就是系统的略读） 分析阅读 阅读原则：无限时间内最完整最好的全盘系统化的阅读 分析阅读步骤 1、书籍分类 2、简要概括书本内容 3、列出重要篇章，看他们 4、找出作者想问的问题或者想要解决的问题 5、找出共通的词义 6、从重要句子中解析作者想要表达的主旨 7、找出作者的 论述以及前因后果，以明白作者的主张； 8、明确作者解决了哪些问题；哪些是未解决的；在未解决的问题中，哪些是作者认为无法解决的。 10、对一本书进行整体评价；但是要注意评价的智慧礼节和批评观点的特别标准。 主题阅读 阅读笔记 书本笔记 笔记时间 检视阅读第一层 笔记规则 在书上做笔记 好处 1.保持十分清醒，集中注意力 2.主动阅读也是一种思考，既然是思考，我们就应该可以表达出来，不管是用写的还是说的。 常用方法： 1.画底线 主要的重点、重要切有力的句子 2.底线栏外再画一条线 着重强调1的重要性，并且避免底线过长。 3.空白处画星号或其他符号 标记书中少数十分重要的声明或者段落；还可以折角加以标记。慎用！ 4.空白处编号 作者的某个重要论点发展出来的一系列重要论述。 5.空白处记下其他的页码 标记作者在书中其他位置相同相似的论点甚至是相反的论点；这样可以让全书散落的想法统一起来。CF(参照或者比较) 6.关键字或句子圈出来 作用同1 7.书页中的空白处做笔记 1.记录读者的一些问题或者答案 2.将复杂的论点简化说明 3.记录全书主要论点的发展顺序 4.书中最后一页作为读者索引,依序记录作者主要观点 8.在最后一页写下读者索引,在第一页写下本书大纲,写出本书整体架构,列出基本大纲和前后篇章次序 结构笔记 检视阅读的三个问题 这是一本什么样的书 整本书在谈什么 作者借着什么样的架构,来发展他的观点或者陈述他对这个主题的理解 笔记的重点是全书的结构,而不是内容,至少不是细节 概念笔记 什么是概念笔记 概念既是作者的观点,在我们进行检视阅读的时候,读者也许可以掌握作者所要表达的一些观点。但是对这些观点的准确性和意义，我们需要在分析阅读中去寻找答案。当读者阅读的深度和广度增加之后，自然也会出现自己的观点。 另一种概念笔记 在我们进行主题阅读的时候，我们会阅读主题相关的多本书籍，这个时候的笔记应该也是概念笔记。只是这个时候我们在书中空白页处记下 的页码不再是本书的，也有些是其他书中的。 阅读反思（主动阅读者该做的一些工作） 1、整体来说，这本书在谈什么？ 2、作者细说了什么？又是怎么说的？ 3、作者说的有道理吗？ 4、这本书和我有什么关系 阅读笔记检视阅读 结构笔记 包含内容：读者大纲、名词解释、好句摘录 书本大纲 第一章：什么是社会心理学 第一部分：定义 社会心理学定义 关于社会影响的几个问题 影响的定义 如何影响人们 影响的隐含意义 影响的持续性和变量因素 影响的强弱和变量因素 特定环境影响人类行为的论述 第二章：从众 第一部分;定义 从众的定义 群体压力的定义 群体压力的几个问题 第二部分：增强和减弱从众的因素 一致性 表态 责任 个体和文化 施加压力的群体 第三部分：从众的原因：奖惩和信息 浪费水资源和乱丢垃圾 社会影响和情绪 社会影响：生和死 第四部分:对社会影响的态度 依从 服从和依从的关系 米尔格拉姆实验中的不服从 认同 内化 第四部分：不介入的旁观者是从众者 第五部分：从众实验中的伦理问题 第三章：大众传播、宣传和说服 第一部分： 说服的努力 媒体感染 政治家就是演员 借助感染力的效果 教育还是宣传？ 第二部分：说服的两种路径 中心路径说服 边缘路径说服 第三部分：宣传的来源 可信性 可信性的增加 吸引力 第四部分：宣传的性质 借助理性 借助情感 恐怖和恐怖主义的威胁 一致性的统计证据和个别例证 单方面例证和两方面例证 观点呈现的次序 差异的大小 第五部分:接受者的特征 自尊 接受者的前期经验 第六部分：这些原则的作用方式 第四章：社会认知 第一部分:我们如何理解世界 第二部分：背景对社会判断的影响 参照点和对比效应 启动和易接受性的形成 为决策设置框架 信息的先后次序 首因效应和印象形成 信息量 第三部分：便捷式判断 代表性便捷式判断 易得性便捷式判断 态度便捷式判断 人们何时会使用便捷式判断？ 第四部分：分类和社会定型 定型化认识和预期 发现不存在的关系：虚假关联 内群体-外群体效应 第四部分：重构性记忆 第五部分：自传性记忆 记忆恢复现象 第六部分：人类认知的保守性 第七部分：态度和信念如何指导行动 人们心目中的态度和行为关系 什么时候态度可以预测行为 依据感知觉行动 第八部分：社会解释中可能出现的三种偏差 基本归因错误 行动者-观察者偏差 自我偏差 自我偏差的价值 自我对社会认知产生的影响 自我中心思维 自利偏差 第五章：自我辩护 第一部分：自我辩护的定义和适用范围 第二部分：减少失调和理性行为 第三部分：决策造成的失调 决策后果的一些历史例证 第四部分：不可改变的重要性 有关不道德行为的决策 第五部分：不充分理由心理 外部理由的构成 不充分理由 失调和自我概念 不充分奖赏在教育中的运用 不充分惩罚 第六部分：为努力进行辩护 第七部分：为残忍进行辩护 第八部分：对待不可避免事件的心理 第九部分：自尊的重要作用 第十部分：是不安？还是自我知觉 第十一部分：失调对生理和动机的影响 第十二部分：失调理论的实际运用 理解对灾难的反应 通过减少失调来减肥 失调与艾滋病预防 失调和水资源保护 对宗教领袖权威的解释 本拉登是在利用失调理论吗？ 第十三部分：减少失调和文化 第十四部分：“人”不能只靠和谐生活 第六章：人类的攻击性 第一部分：对攻击性的定义 第二部分：攻击性是本能的吗？ 第三部分：攻击性是否有益 适者生存 宣泄能发挥作用吗？ 报复是过激行为 第三部分：攻击的原因 神经学和化学方面的原因 睾丸素 酒精类饮料 痛苦与不适 挫折与攻击 拒绝、排斥和奚落 社会学习和攻击性 社会学习、暴力和大众传媒 电视暴力的麻木效应 媒体暴力为什么会影响观众的攻击性 媒体、色情描写以及针对女性的暴力 暴力有助于推销吗？ 用攻击性去吸引公众的注意 第四部分：如何减少暴力 纯粹的励志 惩罚 对攻击性榜样的惩罚 对替代性行为的奖赏 非攻击性榜样的作用 建立对他人的移情 第七章：偏见 第一部分：定型和偏见 定型威胁 第二部分：定型和归因 性别定型 第三部分：归咎于受害者 第四部分：偏见和科学 第五部分：偏见的一些微妙影响 不易察觉的性别歧视和性别角色社会化 第六部分：偏见和媒体 第七部分：偏见的原因 经济和政治竞争 替代性攻击：替罪羊理论 自我形象和地位的维持 带有偏见的人格 从众引起的偏见 第八部分：国家干预可以改变民间偏见 地位平等的接触的影响 取消种族隔离的其他影响 其他条件不同的情况 第九部分：相互依赖：一种可能的解决办法 潜在机制 来自差异的挑战 第八章：喜欢、爱和人际敏感性 第一部分：赞扬和帮助他人的效果 第二部分：个人特征 能力 外表吸引力 第三部分：相似和吸引 第四部分：喜欢、被人喜欢和自尊 第五部分：尊重的获得和丧失 对共有关系的需求 第六部分：爱和亲密 人们对爱的认识 对爱的界定 得失理论：亲密关系的含义 第七部分：亲密、真实性和交流 第八部分：有效交流的特征 开门见山 的重要性 情感与看法 交流与完美之爱 第九章：作为一门科学的社会心理学 第一部分：什么是科学的方法 科学和艺术的关系 第二部分:从推测到实验 实验设计 第三部分:随机分配的重要性 第四部分：社会心理学实验的挑战性 控制和影响 现实性 隐瞒 第五部分：伦理问题 实验人员对被实验者的责任 第六部分：假如作者的发现被误用怎么办？ 名词解释 行动者-观察者偏差 将他人的行为归因于行动者稳定的人格素质，而自己的行为解释为情境性因素的倾向 攻击行为 旨在引起身体痛苦或者心理痛苦的有意行为 攻击性刺激 与攻击反应相关的刺激物品（例如：手枪），仅仅因为他们的出现便增加了攻击的可能性 利他行为 对他人有益而不会给施助者带来利益的行为，这种行为往往需要帮助者付出一定的代价 杏仁核 大脑中央区一个和攻击性行为有关的区域 态度 对人、事务和观点持有的持久的（正面或者负面）的评价；态度包含情感评价和认知评价 态度的可通达性 某个事物同我们对它的评价之间的联系强度；可通达性可以通过人们报告他们对特定事物、问题感受如何的速度来加以测量 态度便捷式判断 决策时采取的一种捷径；将认知对象归为有利的一类或者不利的一类。 归因理论 对人们解释自己或者他人行为原因的方式所做的描述 真实性 一个人的行为和交往与他自己的感受相一致 易得性便捷式判断 人们在进行判断时所借助的心里规则依据是轻易想到的事物 善意的性别歧视 看起来对女性持一种正向的（甚至正直的）态度，但从本质上看却有定型化特征；例如，认为女性必须受到保护。 归咎于受害者 将所受到的伤害归咎于受害者本人（进行素质归因）的倾向，导致这种倾向的动机一般是希望看到世界是公平的 这个名词解释我觉得很不理解：这种倾向和动机之间的逻辑关系是如何成立的？ 旁观者效应 目睹某个紧急性事件的旁观者人数越多，他们中间某个人出手救助的可能性越小 这是否可以理解为从众行为？个体是如何受到旁观者群体影响的？如果不从众，需要承担什么责任？ 宣泄 指的是这样一种看法：“排放系统”（通过实施攻击行为、目睹他人实施攻击行为或者幻想性的攻击行为）释放聚集起来的攻击性能量，并因此减少出现进一步攻击行为的可能性。 说服的中心路径 在这种情况下，人们会对说服信息进行详细的思考，仔细聆听其中的观点并进行深入地思考；只有在人们既具备一定的信息接受能力又具有相应动机的时候，这种情况出现 认知失调 一种紧张冲突的状态。无论何时只要某个人同时拥有心理上不一致的两种认知（态度、想法、信念、意见），就会出现这种状态 当认知失调出现后，言行会受到什么影响？ 什么是认知?认知包括态度、想法、信念和意见 认知吝啬者 人们在进行决策的时候，为了尽力保存认知能量，总是想法采用心理捷径 什么是认知能量？人为什么想要保存认知能量？ 共有关系 在这种人际关系中，人们首先关系的是对他人的需要进行响应。 伴侣之爱 人们在深深地关心着另外一个人时所体验到的亲密和情感，但不一定在这个人出现的时候体验到激情 依从 个体因希望获得奖励或者害怕受到惩罚而对社会影响做出的反应 证实偏差 指的是这样一种倾向：人们一旦持有了某种看法，只要有可能，他们便会待有偏见的看待随后出现的事件，以证实自己的看法 这个概念是不是逆向证明了第一印象的重要性？ 从众 由于受到来自他人的真实的或者想象的影响，导致一个人的行为发生了变化。 完美之爱 根据滕伯格的观点，这是激情、亲密和承诺三种成分的混合。 滕伯格的什么观点？ 对比效应 某一认知对象看起来比它自身好或者差，取决于同它进行比较的认知对象的质量 一致性判断 将某个人的行为归因于此人类似的属性或者特质的倾向 态度相反的倡议 当某个人陈述某种与自己的个人信念或态度 相反的意见或态度时出现的认知失调过程。 掩饰性情节 设计情境或实验来增加实验的现实性，在这种情境中被试可以自然地行动，他们的行动不会因为知道自己的哪些行为正在被研究而受到妨碍。 来源的可信性 如果信息来源具有专家身份而且值得相信，她（他）很可能对接收者的信念产生影响 心理纾解 在一项实验结束时，研究者就研究目的以及所发生的事情对被试者进行解释的程序 诱饵 消费者在决策的过程中，会遇到的一种明显差于其他可能选择的选择，它出现旨在通过对比让其他可能选择中的一种看上去更好 非人化 将受害者视为非人的过程，通过这一过程来降低自身攻击行为的限制，从而更容易更有可能进行进一步的攻击行为。 去个性化 一种自我意识弱化的状态（往往是因为匿名引起的），其结果会导致人们对社会评价的关注度的降低，以及对那些被禁止行为的抑制降低。 因变量 在一项实验中，研究者用以考察是否会受到自变量影响的变量；研究者假定，因变量依存于自变量的水平 稀释效应 有关某个问题的额外的无关信息会弱化人们对该问题的判断或印象的趋势。 这是转移话题、转移视线的理论依据吗？ 素质归因 指的是这样一种假定：一个人的行为取决于他（她）的人格（素质），而不是情境压力 自我中心思维 倾向于更多地讲自己视为事件的中心，而实际上却并非如此 自我防卫 行为的目的是为了维持对自己的正向看法，但却丧失了对世界的正确认识。 谁对自己的看法？是自己还是他人？自我防卫和丧失对世界的正确认识之间的逻辑关系？ 情绪感染 情绪或者行为在人群中迅速传播 移情 将自己置于他人位置上的能力，即采用此人的体验方式来对事件和情感（例如，喜悦、悲伤）进行体验 爱 弗洛伊德所假定的人类所具有的生的本能 这句话就很空泛！！！人类需要哪些生的本能？爱为什么是人类的生的本能？它在人类的生的过程中扮演了什么角色？起到了什么作用？ 交换关系 人们之间受公平需要（例如，收益和成本之间的某种平等的比率）主宰的人际关系 实验的现实性 一项实验对被试具有影响，促使他们认真对待并参与到实验中来，这一点即使在缺乏世俗的现实性时仍然有效。 外部理由 一个人对自己不协调行为的理由或解释，不是基于个人，而是基于情境（例如，某种奖励或惩罚）。 错误一致效应 过高估计人们在所有问题上赞同自己的比例的趋势 有避免以己度人的认识，那么什么时候更容易出现错误一致效应？ 虚假记忆综合征 对以往的某种创伤性经历的记忆，尽管这种经历实际上是虚假的，但人们仍然认为它发生过。 为什么会出现这种心理？对人们的有什么影响？ 登门槛技术 通过先提出人们容易接受的小要求，然后提出较大的要求，来促使人们按照更大的要求办事的策略 框架 在决策的过程中，是否呈现命题（或者是否为其设置框架）决定着是得还是失。 决策得失意味着决策成功还是失败？命题或者框架指的是什么？预先设置的目标吗？这句话指的是在决策之前要先制定好目标吗？ 挫折-攻击 因感到自己达到某个目标受阻而产生的挫折，会增加人们做出某种攻击性反应的可能性。 这叫恼羞成怒吗？ 基本归因错误 在对人们行为原因进行分析时所存在的、过高的估计人格和气质因素而过低估计情境和环境因素的趋势 得失效应 指的是这样一种理论：假如我们能够从他人的预期中获得（例如，这些人最初不喜欢我们，而现在喜欢我们），那我们便会最喜欢这些人；假如我们从他人那里丧失（例如，这些人最初喜欢我们，而现在不喜欢我们），那么我们会最不喜欢这些人。 分手了不能做朋友？可以这样解释吗？失去后最讨厌的人？ 群体思维 指的是这样的一种思维：为维持群体的一致而无视那些对事实所做的深思熟虑、事实求实的评价 ***的小圈子为了维持一致性也会做些考虑不周全的事情，那么是不是群体思维作祟？如何避免被群体思维裹挟？ 光环效应 指的是这样的一种偏见：对某个人良好的或者不好的总体印象，会影响到我们对这个人的推测和期望。 事后聪明偏差 一旦人们知道了某个事件的结果，他们便会强烈地倾向于（往往是错误地）认为，自己事先能预测到这一结果 同质性效应 与看待自己所在群体的成员相比，人们在看待某个外群体时会发现其成员之间存在更多相似性的趋势。 敌对性攻击 因愤怒感而起的一种攻击性行为，旨在施加痛苦和伤害。 还有哪些性质的攻击行为？ 敌意的性别歧视 对女性持有负向的定型化看法——例如，女性不如男性聪明 什么是定型化看法？ 液压理论 根据这一理论，没有表达出来的情绪会累积起来形成压力，必须采取某种形式将这种压力释放出来 如何正确、聪明的释放这些压力？ 虚伪 个体实际所做的与口头所说的之间存在差异而认知失调 认知失调，是在讲自己的状态还是对别人的一种评价措辞？虚伪是自己的一种状态，还是他人对自己的一种评价？ 认同 个体因希望与影响施加者相像而对社会影响做出的反应 认同等价于采取相同的行为模式。口头认同只是从众，避免来自影响施加者的压力。 虚假关联 在两个实际上不存在关联的事件之间发现关联或者相关的趋势 内群体 个体所认同或者感到自己所从属的群体 内群体偏爱 人们对自己所确定的内群体成员会持有正向的情感并给以特别的对待，而对其他人则持有负向的情感并给予不公平的对待，这样做仅仅是因为将这些人界定为外群体成员。 自变量 实验者用以考察其自身的改变或者变化是否会对另外一些变量产生影响的变量；研究者预测这种变量会导致其他一些变量的变化。 信息；由信息导致的社会影响 由于我们将他人作为指导自己行为的信息源，因而来自他人的信息会导致我们从众；研究者这种变量会导致其他一些变量的变化 这个名词解释有点莫名其妙！！！我怀疑它和上一条串了，从书本上确认了一下，电子版书籍和纸质书籍一致，具体解答有待更新！！！ 预防接种效应 通过先让人们接触少量与他们的态度不一致的观点，而使人们对改变他们的态度的企图产生免疫。 工具性攻击 将攻击作为实现某种目标的手段，而不仅仅是为了对他人造成痛苦。 不充分惩罚 当个体对拒绝自己期望的目标或者活动缺乏外部辩护理由而引起失调的时候，他们往往会贬低这个活动或者目标 这不就是吃不到葡萄说葡萄酸吗？ 内部理由 通过改变自身的某些方面（例如，一个人的态度或者行为）来减少失调。 内化 个体因希望自己正确而对社会影响作出反应 拼图技术 为减少孩子们的偏见和增强他们的自尊而设计的一种课堂结构，这种课堂将孩子们安排在规模很小、种族混杂的合作群体之中。 便捷式判断 为使自己的判断迅速而有效，人们所采取的的心理捷径。 这种心理捷径是什么？它是如何帮助人们人们做出快速有效的判断的？ 为努力进行辩护 个体会更喜爱他们经过努力而达到的某个目标的倾向 虚报低价 一些营销人员所采用的一种不择手段的策略，他们首先诱导消费者在一个很低的价位上购买商品，然后声称出错并提高价格；最终消费者往往会同意按提高了的价格购买商品。 最小群体范式 完全陌生的人通过微不足道的标准组成一个无意义的群体；最小群体成员之间仍然表现出内群体偏见。 世俗的现实性 实验室实验在多大的程度上与外部世界经常发生的事情类似 看法 坚持认为是正确的（无需评价和情感表露） 例如：请某人谈一下对某事情的看法？那如此来看的话，对这种问题是不是只需要说对错，无需说明缘由或者表达爱憎？ 外群体 不为个体所认同的群体 激情之爱 对另外一个人所感受到的强烈的渴望并伴有生理唤起的情感；假如这种爱得到回报，人们便会体验到巨大的实现感并欣喜若狂；假如没有得到回报，人们便会感到伤心失望。 说服的边缘路径 在这种情况下，人们不会对说服信息中的观点进行详细考虑，而是受到边缘线索的影响。 什么是说服过程中的边缘线索？ 出丑效应 指的是这样一种现象：一些失误现象会增加某个近乎完美的人的吸引力 偏见 仅仅依据特定群体中部分成员的特征而形成的、对整个群体的敌对的或者负向的态度。 首因效应 在某种特定的条件下，人们最先听到的论证会对他们产生特别的影响。 启动 启动过程基于这样一种观点：最近出现的或者被频繁激活的想法更可能出现在脑海里，因而被用于解释社会事件。 接近性 决定人们是否喜欢或者爱上一个人的重要因素之一是物理上的接近；人们更可能与居住在自己所在的城镇或者城镇附近的人、或者是居住地虽然远但是却在同一所大学的人坠入爱河。 随机分配 将被试机会均等的分配到任何一种实验条件的过程；通过随机分配，研究者可以比较有把握保证被试的人格或背景均匀地分布在各种条件之下。 近因效应 在某种特定的条件下，人们最后听到的论证会对他们产生特别的影响。 重构性记忆 人们对某个事件的记忆会受到他们在该事件发生后所接触信息歪曲的过程 又是一句看不懂的解释！！！请注意查证！！！！ 记忆恢复现象 对以往已经忘记的或者被压抑的事件（例如，性虐待）的回忆；这类记忆的准确性往往存在着大量的争议。 关系性攻击 一种非身体形式的攻击，诸如搬弄是非、散布虚假的谣言和排挤 相对剥夺 感觉自己（或者自己所属的群体）所得到的的，少于自己所应该得到的，少于自己所期望得到的，或者少于与自己相同的人所得到的。 代表性便捷式判断 人们对某一事物进行归类时所借助的心理捷径是该事物与某一典型事物之间的相似程度 浪漫之爱 根据斯滕伯格的观点，这是一种激情与亲密相结合的状态 替罪羊 个体倾向于将攻击矛头转向他们所不喜欢的、明显的而又相对弱小的群体。 脚本 人们从文化中潜移默化地习得的社会行为方式 次级收益 在作出依从行为之后，某种未曾预料的、有利的事态使得从众行为更具吸引力 自我概念 自我的内容，即人们对自身的想法、信念以及人格特征的感知 自尊 人们对自我价值的评价，即人们对自己的美德、能力和正派方面达到何种程度的看法 自证预言 人们对另外的一个人是什么样的人所抱有的期望，这种期望会影响到人们对待此人的行为方式，并会促使此人按照人们最初对他预判相一致的方式去行为。 自我辩护 为了维护自己的自尊二区证明自己的行为合理的倾向 自我知觉理论 指的是这样的一种理论：当我们的归因不确定或者模糊不清的时候，我们会根据自身行为的观测来对其加以推测。 这种推测有什么倾向？是素质归因还是情境归因？这种推测是否合理、正确？有没有其他的方法来帮助我们在这种情境下进行归因？ 自我图式 根据我们以往的经历，对我们自身的知识加以组织，以帮助我们理解、解释和预测我们自身的行为。 自利偏差 个体将自己的成功归因于素质，而将自己的失败归因于情境的情境。 相似性 人们往往会喜欢或者爱上与自己的看法、态度、价值和长相类似的人 社会认知 人们如何思考自身以及社会生活；具体而言，人们如何选择、解释、记忆和运用社会信息进行判断和决策。 社会影响 人们对他人的看法和行为所施加的影响 社会学习理论 这种理论认为：人们通过观察和模仿他人来习得社会行为（例如，攻击行为） 社会心理学 对受到真实的或想象的他人在场影响下的人们的思想、情感和行为方式的科学研究 定型 对某个群体的简单的概括，从个人所持偏见出发，赋予他们完全相同的特征。 定型威胁 少数族裔的成员对他们自身的行为方式与已有的文化定型相符合的担忧。这种担忧往往会降低他们取得成绩的能力。 坦率地谈话 一个人明确地说出自己的情感和心事，而且不对对方加以指责、挖苦或者嘲笑 那么在坦率的谈话情境下，如何才能让谈话的另外一方不产生其他的附带情绪？比如说出自己的情绪后，对方会不会觉得自己是在指责ta，然后继而道歉？然后坦率的谈话该如何把握谈话的方向？从而避免发展成为激烈的互相指责和争吵？ 睾丸素 与攻击性有关的一种激素 桑纳托斯 根据弗洛伊德的观点，这是一种促使人类走向死亡的本能的驱动力，会导致攻击行为。 弗洛伊德关于此观点的详细描述请加以查证！！！ 桑纳托斯是如何导致攻击性行为的？ 爱情三角 根据斯滕伯格的观点，爱情的三种成分是：激情、亲密和承诺 基本归隐偏差 在对特定人群进行整体归因时所出现的、与人们对该群体的偏见相一致的素质归因倾向。 读者大纲 第一章：社会心理学概念及分析 第一部分：什么是社会心理学？ 读者答：作者并没有直接给社会心理学直接下定义；而是通过通过一系列社会群体和个体对人们施加影响的案例来引导出“社会影响”这个关键论题。社会影响指的是人们对他人的想法产生的影响。 第二部分：社会心理学的几个问题 第一问：人们是怎么受到影响的？ 第二问：对人们而言这些影响的隐含意义是什么？或者说人们为什么会受到影响？读者注释：这个问题问的有点不明白！！！ 第三问：哪些因素会增强或者削弱社会影响 第四问：社会影响是长久的还是短暂的?这里讨论的是社会影响的持续性。 第五问：哪些因素会影响社会影响的持续性？ 第三部分：社会心理学实验 第一重点：强调社会心理学实验的重要性；不要有“显而易见”的心理； 第二重点：强调社会心理学实验的一些问题 重点一：社会心理学实验的组成要素 重点二：社会性理学实验的有利因素、不利因素、伦理难题、激动人心之处、棘手之处和令人痛心之处 第二章;从众 第一部分：什么是从众效应？群体压力和从众的关系 读者答：群体压力是从众效应的关键性因素之一 第二部分：什么导致了群体压力 第三部分：群体压力的本质是什么？（读者注解：第二部分和第三部分的问题解答应该是相似度很高的） 第四部分：群体压力带来的个体行为和意见的改变是真是假？ 第五部分：从众效应带来的改变是短暂还是长久的？ 第六部分：哪些因素会增强从众效应？ 第七部分：如何理解没有群体压力下的从众效应？ 第八部分：对社会影响的几个不同的反应 第九部分：从众者和旁观者的关系 第十部分:从众效应实验中应该注意的伦理问题 第三章：大众传播、宣传和说服 第一部分：人们生活中的常见的几种宣传、说服的例子 第二部分：说服的两种路径 第三部分;宣传的可信性和宣传的性质以及如何加强宣传的影响？ 第四部分；说服接受者的一些特征 第五部分：如何发挥传播、宣传和说服原则的作用？换言之，我们如何利用这些原则来扩大社会影响 第四章：社会认知 第一部分：社会认知和人们进行行为决策的关系 第二部分:我们应该如何理解世界？换言之，我们应该如何建立我们的社会认知？哪些因素会影响我们的社会认知进而影响我们的行为决策和意见？ 第三部分：在社会认知下的几种判断方式和运用这些判断方式的时机 第四部分：社会认知下人们如何对事物和人物进行分类以及分类之后所产生的结果？分类和社会定型的关系？ 第五部分:记忆作为社会交往重要部分，重构性记忆和自传性记忆的缺陷。 第六部分：什么是人类认知？人类认知存在哪些保守性？ 第七部；人们的态度和信念是如何影响决策并且指导行动的？ 第八部分：哪些因素导致了人们在解释和归因社会生活时出现了偏差（证实偏差、自我偏差、行动者-观察者偏差）？ 第九部分:影响人们社会认知的自我中心思维和自利偏差 第五章：自我辩护 第一部分：人们都会对自己的行为、信念和感受加以辩护，以便让自己或者他人相信自己所做事情的合理性，证明自己的正确性 第二部分：认知失调的理论的详解 第三部分：认知失调理论的实际应用 第六章：人类的攻击性 第一部分：人类的攻击性的定义个攻击性的分类 第二部分：攻击性行为的利弊 第三部分：攻击性行为的动机理论、人类的攻击性行为受哪些因素的影响 第四部分：任何降低人类的攻击性 第七章：偏见 第一部分：什么是偏见 第二部分：偏见是如何产生的？定型对偏见的产生有何影响？它的人类的言行有哪些威胁？ 第三部分：如何消除偏见 第八章：喜欢、爱和人际敏感性 第一部分：喜欢和不喜欢的定义？它是如何产生的？ 第二部分：从喜欢到爱的转变过程？这一过程是如何发生的？哪些因素会对这个过程产生影响 第三部分：爱随着时间的变化趋势？增强或者削弱爱的因素。 第八章：作为一门科学的社会性理学 第一部分:社会心理学的一些基本实验原理 第二部分：社会心理学实验中存在的一些问题挑战、 问题解答 这本书在谈什么？ 读者答：这本书在讨论的是社会心理学中的社会影响这个话题。讨论的问题包括什么是社会影响、社会影响有什么含义、增强或者减弱社会影响的因素有哪些、这些影响是短暂的还是持续性的、增强或者削弱影响持续性的一些因素 这本书架构如何？ 这本书主要包含一下几个部分 第一部分：主要是该书的第一章节内容；主要议题就是提出社会影响这个话题已经关于社会影响的几个问题；并且说明关于社会心理学实验的组成因素和社会心理学实验所面临的的问题。 第二部分:主要包含该书的第二章节~第八章节内容；主要讨论了 这本书分为哪些部分？ 这是什么类型的书籍？ 分析阅读 分析阅读概念笔记 包含内容：作者观点、论据、读者观点 作者论点、论据 好句摘录 读者观点 主题阅读 主题阅读概念笔记 包含内容：主题相关书籍中的作者观点、论据 主题观点、论据 读者反馈 这本书在谈什么 作者说明了哪些问题？又是怎么说明的？ 作者说的内容是否有道理？ 这本书和读者之间的关系？","link":"/2022/05/03/%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB%EF%BC%89/"},{"title":"《如何阅读一本书》读书笔记","text":"如何阅读一本书阅读的活力和艺术阅读就像是一场棒球赛；作者是投手,读者是捕手，既要投手投球投的好，也需要捕手接得住投手的球。提倡主动阅读:1、培养主动阅读、主动学习的习惯2、阅读越主动，效果越好；读者越主动，在阅读的世界里探索能力就强一些，收获多一些，自然也就高明一些；3、读者要求的越多，获得的就越多。 目标 获得资讯 求得理解 分类 指导型学习 自我发现型学习 阅读的两种意义 1、在阅读报纸、杂志或者其他的读物的时候，凭借我们的阅读技巧和聪明才智，一下子就可以融会贯通 2、试着阅读一开始并不怎么了解的东西 阅读层次大致分类基础阅读 目标 这个句子在说什么,拜托文盲状态,可以识字 基础阅读的四个阶段 阶段一：阅读准备阶段 身体准备：良好的听力和视力。 智力准备：起码的认知能力。 个人准备：能与他人一起学习的能力，保持注意力和服从等。 阶段二：学会阅读一些简单的食物，并且附带一些事物的观察 阶段三： 快速建立字汇的能力 阶段四： 精进和锻炼前三个阶段学会的阅读技巧 检视阅读 目标 这本书在谈什么 这本书的架构如何 这本书分为哪些部分 这是什么类型的书 有限的时间内，最好最完整的阅读 系统化略读, 检视阅读层次 第一层次：有系统的粗读或略读 检视阅读第一次层次建议 1.先看书名或者序言 如果有副标题也需要注意，或者其他的相关说明或者宗旨 2.研究目录页 对这本书的架构进行概括性的了解 3.检阅书中索引 了解本书所覆盖的议题范围 4.出版者介绍 1.吹牛皮 2.作者对本书的主旨摘要 5.挑选主题相关的篇章阅读 阅读书本开头或者结尾的主题相关篇章，他们通常会是整本书的摘要说明 6.全书翻阅一遍 1.寻找主要论点的信息 2.留意主题的基本脉动 3.重点阅读书本的最后几个篇章，通常情况下，作者会在最后几个篇章进行观点梳理 第二层次：粗浅的阅读 检视阅读第二层次建议 7.阅读规则：头一次面对一本阅读难读较大的书的时候，先从头到尾读一遍，碰到不懂的地方也不要停下来查询或者思考 阅读速度 1.我们应该依照读物的性质和复杂程度,使用不同的速度来阅读 2.检视阅读就是一种训练有素的快速阅读。但是检视阅读的快不是因为你读的快（虽然你确实读的快），而是因为我只是选择一部分进行阅读，并且这一部分的阅读速度还不一样 3.分析阅读通常情况下是比检视阅读慢一点的，但是我们同样不应该用相同的速度读完全书。 逗留与倒退 逗留现象 未受过阅读训练的读者在阅读的手，会在一行字的几个位置逗留，也就是眼睛移动时看不到，只有停下来了才能看到 倒退现象 不熟练的读者在阅读完几行内容后，眼睛会不自觉的倒退回远点。会倒退到原先读过的句子上去。 矫正要求 不能跟着眼部的慢速度来阅读，而是应该跟着脑部的快速度来阅读 矫正办法 手指指针法：用手指顺着一行一行的字移动下去，保证移动速度比眼睛的速度快一点，然后强迫自己的眼睛跟随手指的移动速度 理解的问题 问题：很多人觉得速度的时候无法理解文字内容？ 解答： 1.采用手指指针法来快速阅读的时候，不仅可以提高我们的阅读速度，也会让我们保证注意力的高度集中；随着阅读速度的提升，理解能力也会有相应的提高 2.优秀的阅读者在阅读的时候会专心致志，这对我们的理解能力会有帮助；但是如果需要深入的理解我们的读物，我们需要进行下一阶段的分析阅读；如果我们认定手上的读物无需全书进行分析阅读，我们也可以标记需要加强理解的内容，在完成检视阅读之后进行深入的分析和总结。 分析阅读 全盘的、系统的阅读，或者说优质的阅读 无限的时间内，最好最完整的的阅读 分析阅读擅长于寻求理解，如果只是获得资讯或者消遣，则没有必要进行分析阅读。 分析阅读的规则 1.读者要知道自己读的是哪一类的书，且越早知道越好 这里涉及到书籍的分类 虚构作品 小说 戏剧 史诗 抒情诗 …… 论说性作品 主要内容由一些观点、理论、假设和推断组成，并且作者多少表示了这些主张是有根据的，这种书籍就是传达知识的论说性书籍;不论读者是否同意书中的观点,都不会改变这本书的分类性质 历史类 哲学类 物理类 伦理类 …… 论说性作品基本分类准则 理论性作品 在教读者这是什么 典型陈述 是 没有 应当 理论性作品分类 哲学类 否则就是哲学类 科学类 如果一本理论的书所强调的内容，超过你日常、例行和经验，那么就是一本科学类书籍 实用性作品 在教读者如何去做读者想做的事情,或者是读者认为该做的事情 典型陈述: 某件事应该做完、做到 这样做某个东西是对的 这样做比那样做的结果好 这样选择比那样选择更好 总结：知与行的区别 知:知道这是怎么回事 行:我们想做些什么,我们应该怎么利用它 从书籍名称中获取更多的信息，最重要的是对书记进行分类 2.使用单一的句子或者最多几句话来概括本书的主要内容 结构和规划：叙述整本书的大意 要点 1.一位优秀的作者，会经常想要帮助读者来整理书中的要点 存在的问题 问题：大多数读者无法说出一本书的重要内容 原因： 1.人们不会用简明的语言表达自己 2.忽视了一些阅读的规则，比如没有阅读前言，目录或者后记这些重要内容 2.不要将作者提供的一些书本的重点，当做是绝对且唯一的说明 3.将书中的重要篇章列出来，看他们如何按照顺序组成一个整体的架构 驾驭复杂的内容：为一本书拟大纲的技巧 大纲模板 第一部分谈的什么 第一段落X 第一重点A 第二重点B 第三重点C …… 第二段落Y 第三段落Z …… 第二部分谈的什么 第四部分谈的什么 第五部分谈的什么 …… 4.找出作者要问的问题或者作者想要解决的问题 如何找出作者想要问的问题:常用的提问技巧 理论性的问题 某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是、什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的 实用性问题 有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？ 5.找出共通的词义 本规则的细分 找出重要的单字 确认这些单字在文中使用时的准确词义 单字和词义 1.单字词义完全相同 找到书中重要的单词,就能和作者达成共识 2.单字和词义不同 如果读者理解的词义和作者表达的此役出现偏差,那么沟通就会存在模糊地带,双方也就无法达成共识 什么是共识 共识就是通过文字的技巧,达到沟通沟通知识的目的 如何找出关键字(重要的单字) 读者角度 那些让你头疼的字 作者角度 1.作者强调的某些字,比如进行加粗、斜体、下划线等处理的字，或者某些特殊领域的专门用语 2.本书作者和其他作者产生歧义的字就是关键字 片语 如何确定字义 1.确定这个字是有一个还是多重含义 2.如果是多重含义，那么这些含义之间有何关联？ 3.结合文章上下文，判断每次出现这个字时的含义 6.从重要的句子中抓出作者想要表达的主旨 句子和主旨的关系（语言和思想的关系） 句子和段落 句子和段落是文法的单位、语言的单位 主旨和论述 主旨和论述是逻辑的单位，也就是思想和知识的单位 规则6细分 第一部分：找出关键句 从作者的角度来说，最重要的句子就是在论述的过程中标明作者判断的部分，有些作者会在这样的句子下面划线标注，也有少数的书会将主旨写在开头 从读者角度来说，那些难以理解的句子就是含有重要主旨的部分 第二部分：找出句子中的主旨（你必须要知道句子在说什么） 文字表达的意思和句子诠释的主旨之间的差异 1.主旨所牵涉的内容比文字表达的意思多 2.复杂的句子通常要说明的不止一个主旨。 如何检测读者找到了主旨 用自己的话来说 如果要求读者对某个重要句子做出解释，而读者只是重复作者的话，或者是在前后顺序上做一些小调整，那么读者最好是怀疑一下自己是否真的理解了这句话中所包含的主旨！ 举出一个读者经历的主旨内容描述的经验 7.找出作者的论述,重新架构这些论述的前因后果,以明白作者的主张 如何找出一本书中的论述 1.所有的论述中都包含了一些声明 其中有些声明是读者为什么要接受作者这个论述的理由 先找到结论，就去看看理由是什么 先找到理由，去看看这个理由会把你带到一个什么样的结论上去 2.两种论述的不同之处 归纳法和演绎法的区别 归纳法：以一个或者多个共同的事实来证明某个共同的概念 演绎法;以一连串的通则来证明更进一步的共通的概念 3.找出作者认为哪些事情是假设的,哪些事情是有根据的或者是能证明的,哪些是不需要证明的自明之理. 8.确定作者已经解决了哪些问题,还要哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 智慧礼节的一般规则 9.除非你已经完成大纲架构，可以完整的诠释一本书的内容了，否则不要轻易批评。（在你说出你懂了之前，不要说你同意、不同意或者是暂缓评论） 一般思维性的礼节 1.受教的美德 1.没有一本书会好到无懈可击 2.如果一本书可以启发读者，那么说明作者的水平是高于读者的，除非读者是完全了解了这本书，否则是不应该提出批评的。等到读者打到和作者相同的水平，那么读者应该运用自己的批评的才能，否则对作者来说是不公平的。因为作者已经完成了他的工作—让读者和自己齐头并进，那么读者应该也要变现的像一个同辈一样和作者进行对话。 2.修辞的作用 广义上来讲，修辞和人类的任何一种沟通都有关系的；在沟通的过程中，我们不仅希望别人能来了解我们，同样也希望别人能同意我们的话 从发言者角度：如果沟通的目的是认真的，我们希望能说服或者劝导对方—更准确的说，说服对方接受我们的理论，劝导对方最终受到我们的行为和理论的影响。 从倾听者角度：如果接收者一方也同样认真，那就不但应该有回应，还要做一个负责的倾听者；你对自己所听到的要有回应，还要注意对方背后的意图；同时你还要有自己的主见；如果倾听者不靠自己，只靠讲述者为自己做出判断，那你就是在做奴隶，不是自由的人了！ 3.暂缓评论的重要性 原则;除非你听清楚了,或者说你了解了,否则不要回话 在分析阅读的第三阶段中,除非读者很满意自己完成的分析阅读的前两个阶段,否则难以自由的表达观点;也只有完成了前两个阶段,读者才能有权利去批评,同样也有义务这么做! 在你说出”我同意”或者“我反对”或者“我暂缓评论”前，请一定要能肯定的说“我了解了”！ 请坦诚的说出“我不懂“—其中并没有错在读者身上的可能也请小心的说出”我懂了“—慢慢地举起你评论的长矛 10.不要争强好胜，非辩到底不可 作者忠告:大多数人以赢得辩论为目标,却没想到要学习的是真理 把谈话当作是战争的人，要赢得战争就得为反对而反对，不论自己对错，都要反对成功。抱持着这种心态来阅读的人，只是想在书中找出反对的地方而已 11.在说出自己的观点前，读者要能区别的出真正的知识和个人观点的不同 批评观点的特别标准 12.证明作者的知识不足 13.证明作者的知识错误 14.证明作者不合逻辑 15.证明作者的分析和理由是不完整的 主题阅读 最复杂最系统化的阅读，也称为比较阅读；在进行主题阅读的时候，读者通常会阅读主题相关的多本书籍，并且列举出这些书籍的相关之处。 主题阅读和检视阅读、分析阅读的关系 复习1、检视阅读中的两个步骤 浏览：读的是什么主题，能说明这是什么样的书，并拟出大纲架构 粗浅地阅读：能够与作者达成共识，说明他的主旨，跟随他的论述，才能够诠释整本书的内容 分析阅读的困难之处：同一个主题几百本书，不可能全部读完，只需要选择关键的书进行分析阅读 子主题 2 主题阅读和分析阅读之间的误区：一旦你检视过，确定某些书跟你研究的主题相关后，你就可以开始做主题阅读了。要注意的是，我们并没有像你以为的说：“开始做分析阅读”。当然，你需要研读每一本书，再组合起跟你主题相关的资料，你在做分析阅读时就已经学会了这些技巧。但是绝不要忘了，分析阅读的技巧只适用于单一的作品，主要的目标是要了解这本书。而我们会看到，主题阅读的目标却大不相同。 主题阅读的五个步骤： 主题阅读步骤一：找到相关的章节 当然，我们假设你已经学会分析阅读了，如果你愿意，你能把所有相关的书都看透彻了。但是你可能会把阅读单本的书放在第一顺位，而把自己的主题放在其次。事实上，这个顺序应该颠倒过来，在主题阅读中，你及你关心的主题才是基本的重点，而不是你阅读的书。 在你已经确定哪些书是相关的之后，主题阅读的第一个步骤就是把这些书整体检视阅读一遍。你的目标是找出书中与你的主题极为相关的章节。你选择的书不太可能全本都与你的主题或问题相关。就算是如此，也一定是少数，你应该很快地把这本书读完。你不该忘了，你的阅读是别有用心的—也就是说，你是为了要解决自己的问题才阅读—而不是为了这本书本身的目的而阅读。 主题阅读步骤二：带引作者与你达成共识。 真正的困难在于要强迫作者使用你的语言，而不是使用他的语言 拒绝接受某一位作者的词汇，避免与某位作者词汇相同的情况；要建立一组词汇，首先帮助我们了解所有的作者，而不是其中一两个作者；其次帮助我们解决我们的问题 主题阅读步骤三：厘清问题 根据步骤二建立词汇，然后建立读者的主旨，并且提出一些问题，由某些作者来回答这个问题； 有的时候没有作者能回答读者问题； 主题阅读步骤四：界定议题 如果一个问题很清楚，如果我们也确定各个作者会用不同的方式来回答—不论赞成或反对—那么这个议题就被定义出来了。这是介于用这种方法回答问题的作者，和用另外一种（可能是相反的）方法来回答问题的作者之间的议题。 当两个作者对同一个问题有相当的了解，所作的回答却完全相反或矛盾时，这才是一个真正有参与的议题 主题阅读步骤五：分析讨论。 事实上，我们所做的可能超过这些。对一个问题完整地分析过后，将来其他人对同一个问题要作研究时，我们的分析讨论就会提供他一个很好的研究基础。那会清除一些障碍，理出一条路，让一个原创性的思考者能突破困境。如果没有这个分析的工作，就没法做到这一点，因为这个问题的各个层面就无法显现出来。 主题阅读所追求的这种特质，可以用这句话来作总结：“辩证的客观。”主题阅读就是要能面面俱到，而自己并不预设立场 主题阅读中的矛盾问题 除非你知道要读些什么书，你没法使用主题阅读。但是除非你能做主题阅读，否则你不知道该读些什么书。换句话说，这可以算是主题阅读中的根本问题。也就是说，如果你不知道从何开始，你就没法做主题阅读。就算你对如何开始有粗浅的概念，你花在寻找相关书籍与篇章的时间，远超过其他步骤所需时间的总和 主题工具书 启动阅读，建议阅读．指导阅读《 西 方 世 界 的 经 典 名著》(GreatBooksoftheWesternWorld） 主题阅读精华摘要：一、观察研究范围：主题阅读的准备阶段 (1)针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。(2)浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。二、主题阅读：阅读所有第一阶段收集到的书籍(1)浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。(2)根据主题创造出一套中立的词汇，带引作者与你达成共识—无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。(3)建立一个中立的主旨，列出一连串的问题—无论作者是否明白谈过这些问题，所有的作者，或者至少大多数的作者都要能解读为针对这些问题提供了他们的回答。(4)界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。(5)分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。 如何提升读者的自我要求好句推荐 弗兰西斯.培根：有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是需要咀嚼和消化的。 在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于理解和满足 一个人如果说他知道自己在想些什么，但是又说不出来，通常是他其实并不知道自己在想什么 你必须要读出言外之意，才会有更大的收货。 一个人只要学习过一个复杂的技巧，就会知道要学习一项新技巧，一开始的复杂过程是不足为惧的。 读的很好这句话，我们生活中通常是用来衡量一个读者读的量，而不是质，不得不承认，生活中的大多数情况下都是这样 一个读的很广泛，却读不精的人，与其值得赞美，不如值得同情 霍布斯：如果我想一个一般人一样多那么多书，我就跟他们一样愚蠢了。 主动阅读的四个基础 主动阅读过程中应该提出的四个问题 1.整体来说，这本书在谈什么？ 找出这本书的主题，作者如何一次发展这个主题的，如何逐步从核心议题分解出关键的从属议题来的？ 2.作者细说了什么，怎么说的？ 找出主要的想法、声明和论点，这些内容组成作者想要穿达的主要信息。 3.这本书说的有道理吗？ 是部分有道理还是全部有道理？ 4.这本书和读者有什么关系？ 如果一本书给了读者一些资讯，那么一定要反问一下这些资讯对读者有什么意义？为什么作者认为这件事对读者很重要？读者有必要去了解吗？有没有给读者一些其他的启示？ 作为一个有自我要求的阅读者，要学会在阅读的过程中提出各种各样的问题，其中以上面四个最为重要。只有可以完整的回答上面的四个问题，我们进行的检视阅读才算是功德圆满。 在阅读的过程中，读者要养成提出问题的习惯，并且精准、正确的回答这些问题。 如何让一本书属于自己 在书上做笔记 好处 1.保持十分清醒，集中注意力 2.主动阅读也是一种思考，既然是思考，我们就应该可以表达出来，不管是用写的还是说的。 常用方法： 1.画底线 主要的重点、重要切有力的句子 2.底线栏外再画一条线 着重强调1的重要性，并且避免底线过长。 3.空白处画星号或其他符号 标记书中少数十分重要的声明或者段落；还可以折角加以标记。慎用！ 4.空白处编号 作者的某个重要论点发展出来的一系列重要论述。 5.空白处记下其他的页码 标记作者在书中其他位置相同相似的论点甚至是相反的论点；这样可以让全书散落的想法统一起来。CF(参照或者比较) 6.关键字或句子圈出来 作用同1 7.书页中的空白处做笔记 1.记录读者的一些问题或者答案 2.将复杂的论点简化说明 3.记录全书主要论点的发展顺序 4.书中最后一页作为读者索引,依序记录作者主要观点 8.在最后一页写下读者索引,在第一页写下本书大纲,写出本书整体架构,列出基本大纲和前后篇章次序 三种笔记 结构笔记 检视阅读的三个问题 这是一本什么样的书 整本书在谈什么 作者借着什么样的架构,来发展他的观点或者陈述他对这个主题的理解 笔记的重点是全书的结构,而不是内容,至少不是细节 概念笔记 什么是概念笔记 概念既是作者的观点,在我们进行检视阅读的时候,读者也许可以掌握作者所要表达的一些观点。但是对这些观点的准确性和意义，我们需要在分析阅读中去寻找答案。当读者阅读的深度和广度增加之后，自然也会出现自己的观点。 另一种概念笔记 在我们进行主题阅读的时候，我们会阅读主题相关的多本书籍，这个时候的笔记应该也是概念笔记。只是这个时候我们在书中空白页处记下 的页码不再是本书的，也有些是其他书中的。 辩证笔记 辅助阅读 内在阅读 指的是阅读书籍本身，与其他的书籍是无关的 外在阅读 借助其他书籍来阅读一本书 外在阅读的不利影响 1.在我们理解和批评一本书的过程中，内在阅读和外在阅读容易混淆；在批评、诠释和做大纲的过程中，难免会受经验主义的影响； 2.有些读者过于依赖外在阅读；在我们拿到一本书的时候，我们的第一目标是培养我们的独立的阅读思考的习惯，而不是借助外在阅读的帮助。 外在辅助的来源 1.相关经验 问：读者如何适当的使用自己的经验，来帮助自己读懂一本书？ 答：读者应该问问自己，在读者自己自认为了解了的某个点上，能不能举出一个实例来。 2.其他的书 这一部分的工作在后面的主题阅读中运用的非常多 许多伟大的作品不只是互相之间有关联，而且写作时还有先后顺序； 3.导论和摘要 要求：要聪明的使用导论和摘要这种外在辅助阅读，也就是尽量少用。 原因： 1.一本书的导读不一定都是对的 2.即使一本书的导读都是对的，也可能不全面；过于依赖导读和摘要，可能会限制读者对于书籍的理解。 3.过度使用导读和摘要会让读者养成不良的阅读习惯，这对于主动阅读者来说并不友好。 导论和摘要的正确打开方式 1.摘要和导论可以唤醒读者对于一本书的记忆；这样的摘要，读者在进行检视阅读的时候就应该完成。 2.摘要和导论在读者进行主题阅读的时候，能够帮助读者快速确认某些议题是否和读者的阅读主题紧密相关；摘要不可以代替真正的阅读，但是却可以告诉读者，想不想或者需不需要读这本书。 4.工具书 使用工具书的四个基本知识 1.读者想要知道什么？就是读者要清楚的知道自己的问题是什么。 2.读者要知道在哪里可以找自己想要的问题答案。读者要知道自己的问题是哪一类的问题，而又在哪一类的工具书中可以找到答案。 3.读者必须知道对应的工具书的内容是如何组织的。 4.读者必须知道自己想要找的是什么，在哪一种工具书中可以找到这些内容。 工具书使用举例 字典 对于字典文字的四个认识 1.文字是物质的——可以写成字，也可以发出声音 2.文字是语言的一部分——文字有多重用法，在不同的情境中有不同的意义 3.文字是符号的——这些符号有一种甚至多重意义 4.文字是约定俗成的——每个文字都有自己的演化历史， 字典是关于文字的 百科全书 对于百科全书事实的四个认识 事实是一种说法，说明一种事实的时候，会用一组文字来表达； 事实是一种真实的说法，而不是观点； 事实是真相的反应：1.事实可能是一个资讯；2.不受怀疑的推论 事实是某种程度上的约定俗成，但是这种约定俗成的事实也具有一定的时代局限性，即每个时代的事实可能存在差异 百科全书是关于事实的 阅读不同读物的通用方法实用性书籍 是什么是实用性书籍 包含了规则——原理和准则或者任何一种一般性指导的书籍 实用性书籍分类 说明规则，例如本书，或者一些驾驶指南和烹饪书籍 说明规则形成的原理，经济、政治和一些道德著作 实用性书籍的正确打开方式： 读出书中的言外之意，找出那些实用原理衍生出来的规则，并且找出这种衍生规则如何进行实用。如果一本实用的书没有被“实用的阅读”，那么就是失败的阅读。这也是评价一个实用性书籍的最高准则1 现实的真理和理论的真理 如果我们根据实用性书籍中的规则培养出的行为规则,他满足下面两个要求:1.真的有效;2.引导你到达正确的结果,满足你的期望.就可以称这个行为准则是真理,也就是现实的真理. 实用性书籍阅读的两个问题线索 作者的目的是什么? 他建议用什么办法达到这个目的? 实用性书籍阅读的四大问题: 这本书在谈什么? 列出这本实用性(论说性书籍的一种)的大纲 作者的目的是什么? 读者一定要搞清楚作者想要干什么,因为作者想干的就是作者想让读者去干的,所以这个非常重要! 作者想让读者做什么?作者想让读者这样做的目的是什么? 为了做到这一点,读者也需要找出这本书的内容和含义,需要列出这本书中作者的共识、主旨和论述 内容真实吗？ 读者能否接受作者的宗旨——作者的终极目标 读者能否接受作者介绍的达成终极目标的方法——这取决于读者理解到的终极目标的内容和合适的达到目标的方法 这和读者有何关系? 对比理论性的书籍，对读者产生的影响是可能改变读者对某些事物的看法，但是实用性的书籍对读者产生的影响是需要读者去采取行动的。 想象文学 想象文学阅读建议的讨论路线 从否定的说法谈起，而不是建立一些规则 用类推的方法，简短的将阅读非小说的规则类推到阅读小说的规则 讨论阅读特殊形态的想象文学作品时发生的问题，比如小说、戏剧和抒情诗 阅读想象文学的建议： 不要抗拒想象文学带给读者们的影响力 在想象文学中，不要试图去寻找书中的共识、主旨或者论述 不要用适用于传递知识的、与真理一直的标准去批评小说 阅读想象文学的一般规则： 读者必须将想象文学进行分类 比如抒情诗，主要是表达作者个人情绪的经验 读者要能抓住一本书的大意 主要是看读者能不能用几句简短的话来说明整本书的大意 不仅要能将整本书简化成大意，还要能发现整本书中的各个部分是如何架构起来的 想象文学的批评规则 在读者由衷的感谢作者给自己创造出的全新体验之前，不要轻易批评一部想象作品 故事、戏剧和诗 如何阅读故事书 快速、并且全心全意的去读 对于读者的要求：将阅读一本故事书的时间压缩到合理的长度 原因：读者时间有限 原因：时间拖的太久，会忘记相关的情节和人物 相信作品中的事情，不要有任何的怀疑和疑惑 在完成阅读之后，对整本书进行一个回顾，厘清其中的事件的关联和活动的前后顺序 如何阅读戏剧 如何阅读史诗 集中注意力，全心全力的参与并充分利用想象力 如何阅读戏剧（剧本） 1.将剧本搬上心灵的舞台进行演出 2.阅读戏剧和剧本时要一气呵成，才能掌握整体的感受 关于如何阅读悲剧 1.悲剧的精髓是在时间，或者说是缺乏时间 如何阅读抒情诗 1.无论读者懂不懂，都要一口气读完，不要暂停 2.重读一遍，并且大声的朗读出来，用耳朵和声音重新去体会诗歌中的韵味 3.了解诗歌的作者和相对应的时代背景 历史书籍 阅读历史书籍的两个要点; 1.对你感兴趣的历史或者时期，尽可能阅读一种以上的历史书籍 2.阅读历史时，不止要关心过去某个时间、地点真正发生了什么事情，还要读懂在任何时空之中，尤其是现在，人们为什么采取这种行动的原因 阅读历史书籍要提出的问题： 1.每本历史书都有一个特殊并且范围限定的主题 读者需要弄清楚这本历史书籍谈到了什么，同样也需要知道作者没有谈到的是什么 2.每本历史书都是在说特定时间内的一个故事 1.作者是用什么方法来这个故事的？ 2.作者依据什么将整本书划分为不同的章节？年代、时期还是世代？还是其他的规则来划分章节的 3.作者是不是在这一章节中谈那个时期的经济，然后在另外的章节中谈战争、宗教运动和文学作品的产生？这些内容哪个对作者来说最重要？ 如何阅读传记和自传 一种特别的历史书籍 如何阅读 尽可能去阅读你能找到的资料，包括他对自己一生的描述（如果他写过） 对于任何自传都要有一点怀疑心，同时别忘了，在你还不了解一本书之前，不要妄下论断。至于“这本书与我何干？’’这个问题，我们只能说：传记，就跟历史一样，可能会导引出某个实际的、良心的行动。传记是有启发性的。那是生命的故事，通常是成功者一生的故事—也可以当作我们生活的指引 阅读当前事件 阅读当前事件的几个问题 (1)这个作者想要证明什么 (2）他想要说服谁 (3)他具有的特殊知识是什么？ (4）他使用的特殊语言是什么？ (5)他真的知道自己在说些什么吗？ 作者真的知道事实吗？是否知道被报导的人物私下的思想与决定？他有足够的知识以写出一篇公平客观的报导吗？ 阅读文摘的注意事项 最好的文章，就像最好的书一样，是不可能经过浓缩而没有遗珠之憾的；在这样的情况下，浓缩的惟一功能就是激励我们去阅读原著 至于一般的作品，浓缩是可行的，而且通常要比原著还好。因为一般的文字主要都是与资讯有关的 数学和科学 两种形式的书 伟大的科学和数学的经典之作 现在科普著作 分析阅读的规则使用于科学与数学的作品的阅读 阅读科学经典著作的目的：了解科学的历史和哲学，而并不是成为这一领域的专家 阅读科学作品的两个主要问题： 1.关于论述的问题：科学中的两种论述方式分别是归纳法和演绎法；关于这一点的问题来源是：为了了解归纳法中的某些论点，读者必须了解作者引用为理论基础的证据！ 2.关于数学的问题：如何克服阅读科学著作是绵中的数学问题？ 1.把读者想象的基础程度的数学读的更明白 1.欧几里得：《几何原理》；克服对数学的恐惧心理 2.阿基米德 3.阿波罗乌尼斯 4.尼科马科斯 哲学 哲学的两个领域 存在与变化的问题 这个类型的问题是理论和思辨性的问题 好与坏、善与恶的问题 这个类型属于哲学中实用类型的问题 哲学书籍的终极目标：过好生活、或者是组织号一个社会 哲学的五种论述风格： 哲学对话：柏拉图《对话录》 哲学论文或者散文：《物理学》、《形上学》、《伦理学》等 面对异议：圣托马斯.阿奎那《神学大全》 哲学系统化：斯宾诺莎《伦理学》 格言形式：尼采《查拉图斯特拉如是说》 阅读哲学书籍的注意事项： 1、关注作者的词义和关键主旨 2、关注作者的归纳性总结 3、关注作者对于事物本质的解说，而不是关注那些对于事物本质的描写 子主题 1 4、厘清读者的思绪： 这里要避免的两个问题： 1、如何多个哲学家意见不合，那么这些问题不应该成为读者的困扰之处，他可能只是提出来了一个一直没有得到解决的重大问题； 2、哲学家的意见不合并不重要，关键是读者要厘清自己的思路，关注关键问题 关于神学的重点： 1：神学分为自然升学和教义神学，自然神学是哲学的一个分支，是形而上学的最后一部分；教义神学的关键是某个教派的所信奉的经文。 2、经书的阅读心态，读者不应该将它当做文学作品，而是当做神的话语。 社会科学 什么是社会科学： 社会科学的核心：人类学、经济学、政治学和社会学；周边学科包括法律、教育、公共行政和商业、社会服务的学科，最后加上大量的心理学作品 阅读社会科学的容易之处：通常取材于读者熟悉的经验，论述的方式通常是叙述 阅读社会科学的难处： 1、当读者投入时间去阅读社会科学作品的时候，一旦发现自己和作者观点不合，读者就会出现投入不忠的心理状态 2、社会科学中熟悉的术语和观点，也会成为阅读的障碍；某些特定术语有严格的使用限制，不知其所以然的情况下阅读相关作品会对读者造成困扰； 3、社会科学领域的作品混杂，而不是纯粹的论说性作品 如何阅读社会科学：社会科学需要我们就某一个关键问题阅读相关的多本书籍，这就需要读者进行主题阅读，也就是我们要讨论的第四个阅读方式。","link":"/2022/02/02/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}